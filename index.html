<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<title>Interactive Gene‑Expression Dashboard</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js" integrity="sha384-7TVmlZWH60iKX5Uk7lSvQhjtcgw2tkFjuwLcXoRSR4zXTyWFJRm9aPAguMh7CIra" crossorigin="anonymous"></script>
 <script>
 (function(){
   function initPlotlyHooks(){
     const Plotly = window.Plotly;
     if (!Plotly || !Plotly.d3 || typeof Plotly.d3.formatDefaultLocale !== 'function') {
       console.error('Plotly failed to load; interactive plots will be unavailable.');
       return;
     }
     // force d3 to use ASCII minus
     Plotly.d3.formatDefaultLocale({
     decimal:'.', thousands:',', grouping:[3], currency:['',''], minus:'-'
   });

   function coerceAxes(layout){
     if(!layout) return;
     layout.unicodeMinus = false;
     const paths = [
       'xaxis','yaxis','zaxis','coloraxis',
       'scene.xaxis','scene.yaxis','scene.zaxis',
       'polar.radialaxis','polar.angularaxis',
       'ternary.aaxis','ternary.baxis','ternary.caxis'
     ];
     paths.forEach(p=>{
       const segs=p.split('.');
       let obj=layout;
       for(const s of segs){
         obj=obj && obj[s];
       }
       if(obj) obj.unicodeMinus=false;
     });
     Object.keys(layout).forEach(k=>{
       if(/^[xyz]axis\d*$/.test(k) || /^coloraxis\d*$/.test(k)){
         layout[k]={...layout[k], unicodeMinus:false};
       }
     });
   }

  const MINUS_CHARS=/[\u2212\u2012-\u2015\u207b\u208b\u2796\uff0d\ufe63]/g;
  const MOJIBAKE_MINUS_SEQUENCES=['\u201a\u00e0\u00ed','\u201a\u00e2\u02c6\u2019'];
  const MOJIBAKE_MINUS_REGEX=new RegExp(MOJIBAKE_MINUS_SEQUENCES.join('|'),'g');

  function normalizeMinus(text){
    if(!text) return text;
    if(window.TextDecoder){
      const hasMojibake=MOJIBAKE_MINUS_SEQUENCES.some(seq=>text.includes(seq));
      const codes=[...text].map(ch=>ch.charCodeAt(0));
      const byteSafe=codes.every(code=>code<=0xff);
      const hasC1=codes.some(code=>code>=0x80 && code<=0x9f);
      if(byteSafe && (hasC1 || hasMojibake)){
        try{
          const bytes=new Uint8Array(codes.map(code=>code & 0xff));
          text=new TextDecoder('utf-8').decode(bytes);
        }catch(e){/* keep original text on decode failure */}
      }
    }
    text=text.replace(MOJIBAKE_MINUS_REGEX,'-');
    return text.replace(MINUS_CHARS,'-');
  }

  function sanitizeTextNode(node){
    if(!node || node.nodeType!==Node.TEXT_NODE) return;
    const original=node.textContent;
    const sanitized=normalizeMinus(original);
    if(sanitized!==original){
      node.textContent=sanitized;
    }
  }

  function sanitizeMinusInTree(root){
    if(!root) return;
    if(root.nodeType===Node.TEXT_NODE){
      sanitizeTextNode(root);
      return;
    }
    const walker=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
    let current;
    while((current=walker.nextNode())){
      sanitizeTextNode(current);
    }
  }

  function startMinusObserver(){
    const target=document.body;
    if(!target) return;
    sanitizeMinusInTree(target);
    const observer=new MutationObserver(mutations=>{
      for(const mutation of mutations){
        if(mutation.type==='characterData'){
          sanitizeTextNode(mutation.target);
        } else {
          mutation.addedNodes.forEach(node=>{
            if(node.nodeType===Node.TEXT_NODE){
              sanitizeTextNode(node);
            } else if(node.nodeType===Node.ELEMENT_NODE){
              sanitizeMinusInTree(node);
            }
          });
        }
      }
    });
    observer.observe(target,{childList:true,subtree:true,characterData:true});
  }

  function sanitizeTicks(gd){
    Plotly.d3.select(gd)
      .selectAll('.tick text, .cbtick text')
      .each(function(){
        this.textContent=normalizeMinus(this.textContent);
      });
  }

   function bindSanitize(gd){
     const cb=()=>sanitizeTicks(gd);
     ['plotly_afterplot','plotly_relayout','plotly_restyle'].forEach(ev=>gd.on(ev,cb));
     cb();
   }

   function wrap(name){
     const orig=Plotly[name];
     Plotly[name]=function(gd,data,layout,config){
       coerceAxes(layout);
       return orig(gd,data,layout,config).then(gd2=>{bindSanitize(gd2); return gd2;});
     };
   }
  ['newPlot','react','plot'].forEach(wrap);

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', startMinusObserver, {once:true});
  } else {
    startMinusObserver();
  }
  window.normalizeMinus = normalizeMinus;
  window.sanitizeMinusInTree = sanitizeMinusInTree;
   }

   if (window.Plotly && window.Plotly.d3 && typeof window.Plotly.d3.formatDefaultLocale === 'function') {
     initPlotlyHooks();
   } else {
     window.addEventListener('load', function handlePlotlyLoad(){
       if (window.Plotly && window.Plotly.d3 && typeof window.Plotly.d3.formatDefaultLocale === 'function') {
         initPlotlyHooks();
       } else {
         console.error('Plotly failed to load; interactive plots will be unavailable.');
       }
     }, { once: true });
   }
})();
</script>
<link href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" rel="stylesheet" integrity="sha384-AGH1YNmRghVFwHPLe/1yQlJZ3+2p9+wRBmvXrf5RuGjxKk8UjfVADoMXNfTvSx/1" crossorigin="anonymous">
<script defer src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js" integrity="sha384-O1JpKVMD58eq3U48XcwVq+pS1c0Q7gdbGHi3oBETeJYQhh6/9XJ9vjHWgtV+xn4o" crossorigin="anonymous"></script>
<link href="https://cdn.datatables.net/buttons/2.4.1/css/buttons.dataTables.min.css" rel="stylesheet">
<script defer src="https://cdn.datatables.net/buttons/2.4.1/js/dataTables.buttons.min.js"></script>
<script defer src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.html5.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js" integrity="sha384-rNlaE5fs9dGIjmxWDALQh/RBAaGRYT5ChrzHo6tRfgrZ36iRFAiquP5g41Jsv+0j" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/feather-icons@4.29.2/dist/feather.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin:20px; }
  .nav-tabs .nav-link.active { border-bottom:3px solid #0d6efd; font-weight:600; }
  .tabpane { display:none; }
  .tabpane.show { display:block; }
</style>
<style>
  /* ===== Design tokens ===== */
  :root{
    --font-sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    --bg: #fafafa; --surface:#ffffff; --border:#e6e8eb; --muted:#6b7280; --text:#0b1220;
    --brand:#0d6efd; --brand-600:#0b5ed7; --success:#16a34a; --warn:#f59e0b; --danger:#dc2626;
    --radius:16px; --shadow:0 1px 2px rgba(16,24,40,.04),0 10px 20px rgba(16,24,40,.06);
    --space-1:.25rem; --space-2:.5rem; --space-3:.75rem; --space-4:1rem; --space-6:1.5rem;
  }
  body{ font-family:var(--font-sans); background:var(--bg); color:var(--text); }
  .logoSVG{ opacity:.9; filter:grayscale(.1) saturate(.9); }
  /* Container rhythm */
  body > .d-flex{ margin-bottom:var(--space-4); }
  .tabpane{ display:none; } .tabpane.show{ display:block; }
  .tabpane .row{ row-gap: var(--space-4); }
  .enrichment-toolbar{ background:var(--surface); border:1px solid var(--border);
    border-radius:calc(var(--radius) - 6px); box-shadow:var(--shadow);
    padding:var(--space-3);
  }
  .segmented-control{ display:inline-flex; align-items:center; gap:.4rem;
    padding:.35rem; background:#e2e8f0; border-radius:999px; }
  .segmented-control .segment{ position:relative; }
  .segmented-control .segment input{ position:absolute; inset:0; opacity:0; cursor:pointer; }
  .segmented-control .segment label{ display:inline-flex; align-items:center; justify-content:center;
    padding:.4rem 1rem; border-radius:999px; font-size:.85rem; font-weight:600;
    color:#334155; transition:all .15s ease; white-space:nowrap; }
  .segmented-control .segment input:checked + label{ background:#ffffff;
    color:#0f172a; box-shadow:0 10px 20px rgba(15,23,42,0.12); }
  .enrichment-panels{ position:relative; }
  .enrichment-panel{ display:none; }
  .enrichment-panel.active{ display:block; }
  .plot-area{ width:100%; height:clamp(300px, calc(100vh - 200px), 800px); }
  .plot-wrapper{ position:relative; }
  .plot-badge{
    position:absolute;
    top:12px;
    left:16px;
    display:flex;
    align-items:center;
    gap:8px;
    font-size:.85rem;
    font-weight:600;
    color:var(--muted);
    background:rgba(255,255,255,.92);
    border:1px solid var(--border);
    border-radius:999px;
    padding:4px 12px;
    box-shadow:0 1px 2px rgba(15,23,42,.08);
    pointer-events:none;
    z-index:10;
  }
  .plot-badge.align-right{ left:auto; right:16px; }
  .plot-badge .feather{ width:18px; height:18px; }
  /* Nav styling */
  .nav-tabs{ border-bottom:1px solid var(--border); }
  .nav-tabs .nav-link{ border:0; color:var(--muted); font-weight:600; padding:.6rem 1rem; }
  .nav-tabs .nav-link.active{ color:var(--text); border-bottom:3px solid var(--brand); }
  .colorblind-switch{ display:inline-flex; align-items:center; gap:.4rem; font-size:.8rem; color:var(--muted); }
  .colorblind-switch .form-check-input{ cursor:pointer; }
  .colorblind-switch .form-check-label{ cursor:pointer; font-weight:600; }
  [data-color-mode="colorblind"] .plot-badge{ border-color:rgba(0,0,0,0.2); }
  /* Sticky per-tab toolbar (first .d-flex inside a tab) */
  .tabpane .d-flex.align-items-center{ position:sticky; top:0; z-index:5;
    background:var(--bg); padding:var(--space-3) var(--space-4); margin:-.5rem -.5rem var(--space-3);
    border-radius:calc(var(--radius) - 8px); border:1px solid var(--border); box-shadow:var(--shadow);
  }
  /* Card-like plot and table frames (no markup changes needed) */
  [id$="Plot_§DOM"], [id^="clusterPlot_"], [id^="genePlot_"], [id^="markerUMAP_"],
  [id^="btmPlot_§DOM"], [id^="hallmarkPlot_§DOM"], [id^="tfPlot_§DOM"], [id^="tfNetPlot_§DOM"],
    #compBar, #dirichletForest{
      background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding: var(--space-2);
    }
    .umapObsGrid{ display:grid; gap:var(--space-4); }
  .umapObsGrid > div{
      background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:var(--space-2); aspect-ratio:1; display:flex;
      align-items:center; justify-content:center;
    }
  [id^="umapObsPlot_"]{ background-color:#6c757d; border-color:#6c757d; }
  [id^="umapObsPlot_"]:hover,[id^="umapObsPlot_"]:focus,[id^="umapObsPlot_"]:active{ background-color:#6c757d; border-color:#6c757d; }
  /* Tables */
  table.table{ background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
    overflow:hidden; box-shadow:var(--shadow); }
  table.table thead th{ background:#f8fafc; font-weight:700; }
  table.table tbody tr:hover{ background:#f3f4f6; }
  table.table td, table.table th{ vertical-align:middle; white-space:nowrap; }
  #dgeTable caption{
    caption-side:top;
    padding-left:0;
    padding-right:0;
    margin-bottom:var(--space-2, .5rem);
  }
  .contrast-caption{
    margin:0 0 var(--space-2, .5rem);
    font-size:.85rem;
    font-weight:600;
    color:var(--muted, #6b7280);
    text-align:left;
  }
  #volcanoCaption{
    padding-left:0;
  }
  /* Small controls, tidy spacing */
  .form-label{ color:var(--muted); font-size:.85rem; }
  .form-select.form-select-sm, .form-control.form-control-sm{ border-radius:10px; }
  .btn.btn-sm{ border-radius:10px; }
  /* AI Insights typography */
  #biologyContent{
    max-width: 90ch;
    max-height: clamp(320px, calc(100vh - 240px), 720px);
    background:var(--surface);
    border:1px solid var(--border);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow-y:auto;
    scroll-behavior:smooth;
    position:relative;
  }
  #biologyContent h1,#biologyContent h2,#biologyContent h3{ margin-top:1.4em; }
  #biologyContent code, #biologyContent pre{ background:#f3f4f6; color:var(--text); border-radius:10px; padding:.4rem .6rem; }
  #biologyContent .insight-section{
    padding:var(--space-3);
    border-radius:var(--radius);
    border:1px solid transparent;
    margin-bottom:var(--space-3);
    transition:background-color .2s ease, box-shadow .2s ease, border-color .2s ease;
  }
  #biologyContent .insight-section h1,
  #biologyContent .insight-section h2,
  #biologyContent .insight-section h3,
  #biologyContent .insight-section h4,
  #biologyContent .insight-section h5,
  #biologyContent .insight-section h6{ margin-top:0; }
  #biologyContent .insight-section.active{
    border-color:rgba(13,110,253,0.35);
    background:rgba(13,110,253,0.08);
    box-shadow:0 0 0 2px rgba(13,110,253,0.08);
  }
  .card{ border-radius:var(--radius); border:1px solid var(--border); box-shadow:var(--shadow); }

  /* ===== Summary tab styling ===== */
  #overview .summary-wrapper{
    display:flex;
    flex-direction:column;
    gap:clamp(2rem, 3vw, 3rem);
    margin-bottom:clamp(3rem, 5vw, 4rem);
  }
  #overview .summary-hero{
    display:flex;
    flex-direction:column;
    align-items:flex-start;
    gap:clamp(2rem, 3vw, 3rem);
    padding:clamp(2rem, 3vw, 3rem);
    border-radius:calc(var(--radius) + 10px);
    background:linear-gradient(135deg, rgba(13,110,253,0.14) 0%, rgba(37,99,235,0.1) 48%, rgba(99,102,241,0.18) 100%);
    border:1px solid rgba(59,130,246,0.22);
    position:relative;
    overflow:hidden;
    box-shadow:0 20px 45px rgba(15,23,42,0.12);
  }
  #overview .summary-hero::before{
    content:"";
    position:absolute;
    inset:-35% 20% auto -20%;
    height:150%;
    background:radial-gradient(circle at 20% 20%, rgba(255,255,255,0.45), transparent 58%),
               radial-gradient(circle at 75% 25%, rgba(59,130,246,0.25), transparent 60%);
    opacity:.85;
    pointer-events:none;
    transform:rotate(-8deg);
  }
  #overview .summary-hero>*{
    position:relative;
    z-index:1;
    width:100%;
  }
  #overview .summary-hero-text{
    display:flex;
    flex-direction:column;
    gap:var(--space-3);
    max-width:min(1080px, 100%);
  }
  #overview .summary-hero-kicker{
    text-transform:uppercase;
    letter-spacing:.12em;
    font-weight:600;
    font-size:.75rem;
    color:rgba(15,23,42,0.72);
  }
  #overview .summary-hero-title{
    font-size:clamp(2rem, 4vw, 2.8rem);
    font-weight:720;
    margin:0;
    color:var(--text);
  }
  #overview .summary-hero-description{
    margin:0;
    font-size:1.05rem;
    line-height:1.6;
    color:rgba(15,23,42,0.75);
    max-width:72ch;
  }
  #overview .summary-hero-actions{
    display:flex;
    flex-wrap:wrap;
    gap:var(--space-2);
    margin-top:var(--space-3);
  }
  #overview .summary-btn{
    border-radius:999px;
    padding:.7rem 1.5rem;
    font-weight:600;
    border:1px solid transparent;
    transition:.2s ease;
  }
  #overview .summary-btn.primary{
    background:var(--brand);
    color:#fff;
    box-shadow:0 14px 30px rgba(13,110,253,0.28);
  }
  #overview .summary-btn.primary:hover{
    background:var(--brand-600);
    border-color:var(--brand-600);
    transform:translateY(-1px);
  }
  #overview .summary-btn.secondary{
    background:rgba(255,255,255,0.12);
    color:var(--text);
    border-color:rgba(255,255,255,0.28);
  }
  #overview .summary-btn.secondary:hover{
    background:rgba(255,255,255,0.28);
  }
  #overview #summaryHeroMetrics{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(160px,1fr));
    gap:var(--space-3);
    margin-top:var(--space-2);
  }
  #overview .summary-metric-card{
    background:rgba(255,255,255,0.95);
    border-radius:20px;
    border:1px solid rgba(148,163,184,0.22);
    box-shadow:0 18px 40px rgba(15,23,42,0.09);
    padding:var(--space-4);
    display:flex;
    flex-direction:column;
    gap:.4rem;
  }
  #overview .summary-metric-label{
    font-size:.75rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    color:rgba(15,23,42,0.55);
  }
  #overview .summary-metric-value{
    font-size:1.65rem;
    font-weight:700;
    color:var(--text);
  }
  #overview .summary-metric-note{
    font-size:.85rem;
    color:rgba(15,23,42,0.65);
  }
  #overview .summary-section{
    background:var(--surface);
    border-radius:calc(var(--radius) + 6px);
    border:1px solid rgba(148,163,184,0.22);
    box-shadow:0 22px 50px rgba(15,23,42,0.08);
    padding:clamp(1.75rem, 2.5vw, 2.5rem);
  }
  #overview .summary-section+.summary-section{
    margin-top:0;
  }
  #overview .summary-section-title{
    display:flex;
    align-items:center;
    gap:.6rem;
    font-size:1.35rem;
    font-weight:680;
    margin-bottom:var(--space-3);
    color:var(--text);
  }
  #overview .summary-section-icon{
    width:22px;
    height:22px;
    color:var(--brand);
  }
  #overview .summary-section-subtitle{
    margin:0;
    font-size:.95rem;
    color:rgba(15,23,42,0.6);
  }
  #overview #summaryHighlightsGrid{
    display:grid;
    gap:var(--space-4);
    grid-template-columns:repeat(auto-fit, minmax(248px,1fr));
  }
  #overview .summary-highlight-card{
    display:flex;
    gap:var(--space-3);
    align-items:flex-start;
    background:rgba(255,255,255,0.98);
    border-radius:24px;
    border:1px solid rgba(148,163,184,0.24);
    box-shadow:0 24px 55px rgba(15,23,42,0.11);
    padding:var(--space-4);
    transition:transform .25s ease, box-shadow .25s ease;
  }
  #overview .summary-highlight-card:hover{
    transform:translateY(-4px);
    box-shadow:0 32px 64px rgba(15,23,42,0.16);
  }
  #overview .summary-highlight-icon{
    flex:0 0 56px;
    height:56px;
    border-radius:18px;
    background:rgba(59,130,246,0.12);
    color:rgba(59,130,246,1);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:inset 0 0 0 1px rgba(59,130,246,0.22);
  }
  #overview .summary-highlight-icon .feather{
    width:26px;
    height:26px;
  }
  #overview .summary-highlight-content{
    display:flex;
    flex-direction:column;
    gap:.4rem;
  }
  #overview .summary-highlight-content h4{
    margin:0;
    font-size:1.2rem;
    font-weight:670;
    color:var(--text);
  }
  #overview .summary-highlight-content p{
    margin:0;
    font-size:.95rem;
    line-height:1.55;
    color:rgba(15,23,42,0.72);
  }
  #overview .summary-highlight-context{
    display:inline-flex;
    margin-top:.25rem;
    font-size:.8rem;
    color:rgba(15,23,42,0.65);
    background:rgba(59,130,246,0.1);
    border-radius:999px;
    padding:.35rem .75rem;
  }
  #overview .summary-metric-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    gap:var(--space-3);
    width:100%;
  }
  #overview .summary-card-grid{
    display:grid;
    gap:var(--space-3);
    grid-template-columns:repeat(auto-fit, minmax(240px,1fr));
  }
  #overview .summary-card{
    border:1px solid rgba(148,163,184,0.22);
    border-radius:20px;
    background:rgba(255,255,255,0.98);
    box-shadow:0 18px 42px rgba(15,23,42,0.08);
    padding:var(--space-4);
    display:flex;
    flex-direction:column;
    gap:.75rem;
  }
  #overview .summary-card h4{
    margin:0;
    font-size:1.05rem;
    font-weight:650;
    color:var(--text);
  }
  #overview .summary-card p{
    margin:0;
    color:rgba(15,23,42,0.7);
    font-size:.95rem;
    line-height:1.5;
  }
  #overview .summary-card small{
    color:rgba(15,23,42,0.55);
    font-size:.82rem;
  }
  #overview .summary-chip-list{
    list-style:none;
    display:flex;
    flex-wrap:wrap;
    gap:var(--space-2);
    padding:0;
    margin:0;
  }
  #overview .summary-chip{
    border-radius:999px;
    background:#eef2ff;
    color:#3730a3;
    font-weight:600;
    font-size:.85rem;
    padding:.35rem .9rem;
  }
  #overview .summary-chip.negative{
    background:#fee2e2;
    color:#b91c1c;
  }
  #overview .summary-chip.neutral{
    background:#f1f5f9;
    color:#475569;
  }
  #overview .summary-two-column{
    display:grid;
    gap:var(--space-4);
    grid-template-columns:repeat(auto-fit, minmax(240px,1fr));
  }
  #overview .summary-composition-list{
    display:flex;
    flex-direction:column;
    gap:var(--space-3);
  }
  #overview .summary-composition-item{
    background:rgba(255,255,255,0.96);
    border:1px solid rgba(148,163,184,0.22);
    border-radius:18px;
    padding:var(--space-3);
    box-shadow:0 14px 32px rgba(15,23,42,0.08);
  }
  #overview .summary-composition-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-weight:600;
    margin-bottom:.6rem;
    color:var(--text);
  }
  #overview .summary-composition-track{
    position:relative;
    width:100%;
    height:10px;
    border-radius:999px;
    background:rgba(148,163,184,0.18);
    overflow:hidden;
  }
  #overview .summary-composition-fill{
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:linear-gradient(90deg, rgba(13,110,253,0.8), rgba(99,102,241,0.9));
  }
  #overview .summary-composition-value{
    margin-top:.5rem;
    font-size:.85rem;
    font-weight:600;
    color:rgba(15,23,42,0.65);
  }
  #overview .summary-alert-list{
    display:flex;
    flex-direction:column;
    gap:var(--space-2);
  }
  #overview .summary-alert{
    padding:.85rem 1rem;
    border-radius:14px;
    background:rgba(248,113,113,0.12);
    border:1px solid rgba(220,38,38,0.2);
    color:#991b1b;
    font-weight:600;
  }
  #overview .summary-list{
    list-style:none;
    margin:0;
    padding:0;
    display:flex;
    flex-direction:column;
    gap:var(--space-2);
  }
  #overview .summary-list-item{
    padding:.35rem 0;
    font-size:.95rem;
    color:rgba(15,23,42,0.72);
  }
  #overview .summary-list-item h4{
    font-size:1rem;
    margin-bottom:.2rem;
  }
  #overview .summary-markdown{
    width:100%;
    max-width:100%;
    margin-inline:0;
    line-height:1.6;
    color:rgba(15,23,42,0.75);
  }
  #overview .summary-narrative-toolbar{
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:var(--space-3);
    padding:var(--space-3) var(--space-4);
    margin-bottom:var(--space-3);
    background:linear-gradient(92deg, rgba(13,110,253,0.08), rgba(99,102,241,0.12));
    border:1px solid rgba(13,110,253,0.18);
    border-radius:calc(var(--radius) - 6px);
    box-shadow:var(--shadow);
  }
  #overview .summary-narrative-label{
    font-size:.75rem;
    font-weight:700;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:rgba(15,23,42,0.54);
  }
  #overview .summary-narrative-toc{
    display:flex;
    flex-wrap:wrap;
    gap:var(--space-2);
    flex:1 1 auto;
  }
  #overview .summary-toc-chip{
    border:1px solid rgba(13,110,253,0.2);
    background:rgba(13,110,253,0.08);
    color:#0d47a1;
    font-weight:600;
    padding:.35rem .9rem;
    border-radius:999px;
    font-size:.85rem;
    transition:background .18s ease, color .18s ease, box-shadow .18s ease, transform .18s ease;
  }
  #overview .summary-toc-chip:hover,
  #overview .summary-toc-chip:focus{
    background:rgba(13,110,253,0.18);
    color:#0b1220;
    box-shadow:0 8px 16px rgba(13,110,253,0.18);
    transform:translateY(-1px);
  }
  #overview .summary-toc-chip.active{
    color:#ffffff;
    background:linear-gradient(120deg, rgba(13,110,253,0.95), rgba(79,70,229,0.95));
    box-shadow:0 10px 24px rgba(37,99,235,0.3);
  }
  #overview .summary-narrative-actions{
    display:flex;
    flex-wrap:wrap;
    gap:var(--space-2);
  }
  #overview .summary-narrative-action{
    border:1px solid rgba(15,23,42,0.12);
    background:#ffffff;
    color:rgba(15,23,42,0.75);
    font-weight:600;
    padding:.35rem .85rem;
    border-radius:10px;
    font-size:.8rem;
    transition:background .18s ease, color .18s ease, box-shadow .18s ease;
  }
  #overview .summary-narrative-action:hover,
  #overview .summary-narrative-action:focus{
    background:rgba(15,23,42,0.05);
    color:rgba(15,23,42,0.9);
    box-shadow:0 8px 16px rgba(15,23,42,0.08);
  }
  #overview .summary-narrative-block{
    position:relative;
    margin-bottom:var(--space-4);
    border-radius:var(--radius);
    border:1px solid rgba(148,163,184,0.24);
    background:rgba(255,255,255,0.98);
    box-shadow:0 14px 32px rgba(15,23,42,0.08);
    overflow:hidden;
  }
  #overview .summary-narrative-block::before{
    content:"";
    position:absolute;
    inset:0 auto 0 0;
    width:6px;
    background:linear-gradient(180deg, rgba(13,110,253,0.95), rgba(79,70,229,0.85));
  }
  #overview .summary-narrative-toggle{
    width:100%;
    border:0;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:var(--space-3);
    padding:var(--space-4);
    font-size:1.05rem;
    font-weight:700;
    color:rgba(15,23,42,0.85);
    text-align:left;
    cursor:pointer;
  }
  #overview .summary-narrative-toggle:focus{
    outline:2px solid rgba(13,110,253,0.35);
    outline-offset:4px;
  }
  #overview .summary-narrative-title{
    flex:1 1 auto;
  }
  #overview .summary-narrative-icon{
    flex:0 0 auto;
    width:1.1rem;
    height:1.1rem;
    border-radius:50%;
    border:1px solid rgba(79,70,229,0.35);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size:.8rem;
    color:rgba(79,70,229,0.9);
    transition:transform .2s ease;
  }
  #overview .summary-narrative-icon::before{
    content:">";
    transform:translateX(1px);
  }
  #overview .summary-narrative-block.is-open .summary-narrative-icon{
    transform:rotate(90deg);
  }
  #overview .summary-narrative-body{
    padding:0 var(--space-4) var(--space-4);
    background:linear-gradient(180deg, rgba(248,250,252,0.7), rgba(255,255,255,0.95));
    border-top:1px solid rgba(148,163,184,0.24);
  }
  #overview .summary-narrative-body > :last-child{
    margin-bottom:0;
  }
  #overview .summary-narrative-body p{
    margin-bottom:.85rem;
    color:rgba(15,23,42,0.8);
  }
  #overview .summary-narrative-body h3{
    display:flex;
    align-items:center;
    gap:var(--space-2);
    margin-top:var(--space-4);
    margin-bottom:.6rem;
    font-size:1rem;
    font-weight:700;
    color:rgba(79,70,229,0.95);
  }
  #overview .summary-narrative-body h3::before{
    content:"";
    width:.6rem;
    height:.6rem;
    border-radius:50%;
    background:linear-gradient(120deg, rgba(79,70,229,0.95), rgba(13,110,253,0.85));
    box-shadow:0 0 0 2px rgba(79,70,229,0.15);
  }
  #overview .summary-narrative-body ul{
    padding-left:1.1rem;
  }
  #overview .summary-narrative-body li{
    margin-bottom:.55rem;
  }
  #overview .summary-narrative-body code{
    background:rgba(15,23,42,0.07);
    border-radius:6px;
    padding:.1rem .35rem;
  }
  @media (max-width: 768px){
    #overview .summary-narrative-toolbar{
      flex-direction:column;
      align-items:flex-start;
    }
    #overview .summary-narrative-actions{
      width:100%;
    }
    #overview .summary-narrative-toggle{
      padding:var(--space-3);
    }
    #overview .summary-narrative-body{
      padding:0 var(--space-3) var(--space-3);
    }
  }
  .summary-harmonized-table{
    width:100%;
    border-collapse:separate;
    border-spacing:0;
    background:rgba(255,255,255,0.98);
    border:1px solid rgba(148,163,184,0.22);
    border-radius:18px;
    overflow:hidden;
    box-shadow:0 16px 36px rgba(15,23,42,0.08);
  }
  .summary-harmonized-table th,
  .summary-harmonized-table td{
    padding:.75rem 1rem;
    white-space:normal;
    vertical-align:top;
    font-size:.9rem;
  }
  .summary-harmonized-table thead th{
    background:#f1f5f9;
    font-weight:600;
    color:rgba(15,23,42,0.72);
  }
  .summary-harmonized-table tbody tr:nth-child(even){
    background:rgba(148,163,184,0.1);
  }
  .summary-harmonized-table tbody tr:hover{
    background:rgba(59,130,246,0.1);
  }
  .summary-harmonized-table .muted{
    color:rgba(15,23,42,0.6);
  }
  #overview .summary-metadata-grid{
    display:grid;
    gap:var(--space-2);
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
  }
  #overview .summary-metadata-grid dt{
    font-weight:600;
    color:var(--text);
  }
  #overview .summary-metadata-grid dd{
    margin:0 0 var(--space-2);
    color:rgba(15,23,42,0.7);
  }

  /* Footer tagline */
  .about-tagline { position:relative; padding-right:.25rem; }
  .about-tagline .about-dot { display:inline-block; width:.4rem; height:.4rem; border-radius:50%; background:#0d6efd; margin:0 .15rem; opacity:.4; }
  .about-tagline .about-text { margin-left:.4rem; font-weight:700; color:var(--brand); letter-spacing:.3px; }
  #globalFooter{position:fixed; bottom:.5rem; right:.5rem;}
  /* Accessible focus */
  :focus-visible{ outline:3px solid color-mix(in oklab, var(--brand) 40%, white); outline-offset:2px; border-radius:12px; }
  /* Help slide-over */
  #helpOverlay{position:fixed;top:0;right:0;bottom:0;width:360px;max-width:90%;background:var(--surface);
    border-left:1px solid var(--border);box-shadow:var(--shadow);transform:translateX(100%);transition:transform .3s;z-index:1050;
    overflow-y:auto;padding:var(--space-4);}
  #helpOverlay.show{transform:translateX(0);}
  #helpBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.3);z-index:1040;opacity:0;transition:opacity .3s;display:none;}
  #helpBackdrop.show{display:block;opacity:1;}
  #tourOverlay{
    position:fixed;
    inset:0;
    background:rgba(15,23,42,0.65);
    color:#fff;
    display:none;
    z-index:1100;
    align-items:center;
    justify-content:center;
    text-align:left;
    padding:1rem;
    backdrop-filter:blur(3px);
  }
  #tourOverlay.show{display:flex;}
  #tourOverlay .tour-dialog{
    background:rgba(15,23,42,0.92);
    border:1px solid rgba(255,255,255,0.15);
    border-radius:18px;
    padding:1.25rem;
    max-width:380px;
    width:100%;
    box-shadow:0 18px 48px rgba(8,15,40,0.45);
    display:flex;
    flex-direction:column;
    gap:1rem;
    pointer-events:auto;
  }
  #tourOverlay .tour-dialog button{align-self:flex-end;}
  #tourFrame{
    position:fixed;
    border:3px solid rgba(13,110,253,0.85);
    box-shadow:0 0 0 6px rgba(13,110,253,0.25),0 18px 48px rgba(13,110,253,0.35);
    border-radius:18px;
    z-index:1201;
    display:none;
    pointer-events:none;
    transition:all .2s ease;
  }
</style>
<script>
  const PLOTLY_THEME = {
    layout: {
      font:{family:'', size:13},
      paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      margin:{l:10,r:10,t:28,b:10},
      unicodeMinus:false,
      xaxis:{visible:false,zeroline:false,showgrid:false, unicodeMinus:false},
      yaxis:{visible:false,zeroline:false,showgrid:false, scaleanchor:'x', scaleratio:1, unicodeMinus:false},
      hoverlabel:{align:'left',namelength:-1, bgcolor:'rgba(255,255,255,.9)', font:{color:'#0b1220'}}
    },
    config:{
      displaylogo:false,
      responsive:true,
      modeBarButtonsToRemove:['lasso2d','select2d','toggleSpikelines'],
      toImageButtonOptions:{format:'svg'}
    }
  };
  const initPlotlyThemeFont = () => {
    const target = document.body || document.documentElement;
    if (!target) return;
    PLOTLY_THEME.layout.font.family = getComputedStyle(target).fontFamily;
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPlotlyThemeFont, { once: true });
  } else {
    initPlotlyThemeFont();
  }
  // Use like: Plotly.react(container, traces, {...PLOTLY_THEME.layout, title:'My title'}, PLOTLY_THEME.config)
</script>
<script>
  function onVisible(el, cb) {
    const run = () => {
      if (el.offsetParent !== null) {
        cb();
        return true;
      }
      return false;
    };
    if (run()) return;
    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            obs.disconnect();
            cb();
          }
        });
      });
      io.observe(el);
    } else if ('MutationObserver' in window) {
      const mo = new MutationObserver(() => {
        if (run()) mo.disconnect();
      });
      mo.observe(document.documentElement, { attributes:true, childList:true, subtree:true });
    } else {
      const interval = setInterval(() => {
        if (run()) clearInterval(interval);
      }, 200);
    }
  }
</script>
</head>
<body>
<svg style="position:absolute;width:0;height:0;overflow:hidden" aria-hidden="true">
  <defs>
    <g id="logoSymbol">
      <!-- Colors: Dark blue outline/stroke (#000080), yellow fill (#FFD700), light blue fill (#00BFFF), brown fill (#8B4513), purple fill (#800080) -->
      <!-- Yellow circle (left) -->
      <circle cx="60" cy="90" r="35" fill="#FFD700" stroke="#000080" stroke-width="8" />
      <!-- Horizontal main line -->
      <line x1="95" y1="90" x2="340" y2="90" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <!-- Upward curved branch to light blue circle -->
      <path d="M130 90 C150 50, 170 50, 190 70" fill="none" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <circle cx="190" cy="70" r="20" fill="#00BFFF" stroke="#000080" stroke-width="8" />
      <!-- Downward curved branch to brown square -->
      <path d="M220 90 C240 130, 260 130, 280 110" fill="none" stroke="#000080" stroke-width="8" stroke-linecap="round" />
      <rect x="270" y="95" width="25" height="25" rx="5" fill="#8B4513" stroke="#000080" stroke-width="8" />
      <!-- Purple triangle (right arrow‑like) -->
      <polygon points="340,70 370,90 340,110" fill="#800080" stroke="#000080" stroke-width="8" stroke-linejoin="round" />
      <!-- Text "STREAM" below -->
      <text x="70" y="200" fill="#000080" font-family="sans-serif" font-weight="bold" font-size="70">STREAM</text>
    </g>
  </defs>
</svg>
<!-- compact logo + title bar -->
<div class="d-flex align-items-center flex-wrap gap-3 mb-3">
  <svg class="logoSVG" style="max-width:220px;" viewBox="0 0 400 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="STREAM logo"><use href="#logoSymbol"/></svg>
  <div class="ms-2">
    <h1 class="display-6 fw-semibold mb-1" id="pageProjectTitle">Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics</h1>
    <p class="text-muted small mb-0" id="pageToolkitTagline">Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics</p>
  </div>
</div>
<ul class="nav nav-tabs mb-3">
  <li class="nav-item">
    <a class="nav-link active" data-tab="overview" href="#">Summary</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="dge" href="#">DGE</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="volcano" href="#">Volcano</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="umap" href="#">Clusters &amp; Genes</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="umapobs" href="#">Sample/Condition</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="btm" href="#">Enrichment Explorer</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="tfnet" href="#">TF network</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="biology" href="#">AI Insights</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="methods" href="#">Methods</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" data-tab="about" href="#">About</a>
  </li>
  <li class="nav-item ms-auto d-flex align-items-center">
    <div class="form-check form-switch mb-0 colorblind-switch">
      <input class="form-check-input" type="checkbox" id="colorblindToggle_§DOM" aria-label="Toggle colorblind-friendly color palette">
      <label class="form-check-label" for="colorblindToggle_§DOM">Colorblind mode</label>
    </div>
  </li>
  <li class="nav-item d-flex align-items-center">
    <button id="helpChip" class="btn btn-sm btn-outline-secondary">Help</button>
  </li>
</ul>
<div id="expLoader" class="alert alert-info d-none" role="status">
  <div class="d-flex align-items-center gap-2">
    <span class="spinner-border spinner-border-sm" aria-hidden="true"></span>
    <span>Decoding RNA expression matrix…</span>
  </div>
</div>
  <div id="umap" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="geneInput_§DOM">RNA</label>
      <input list="geneList_§DOM" id="geneInput_§DOM" class="form-control form-control-sm" style="max-width:260px" aria-describedby="geneFeedback_§DOM" placeholder="e.g., LST1" />
      <datalist id="geneList_§DOM"></datalist>
      <label class="form-label mb-0 protCtrl" for="proteinInput_§DOM">Protein</label>
      <input list="protList_§DOM" id="proteinInput_§DOM" class="form-control form-control-sm protCtrl" style="max-width:260px" placeholder="e.g., CD3">
      <datalist id="protList_§DOM"></datalist>
      <label class="form-label mb-0 protCtrl" for="viewToggle_§DOM">View:</label>
      <div class="btn-group btn-group-sm protCtrl" role="group" id="viewToggle_§DOM">
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewRNA_§DOM" value="RNA" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewRNA_§DOM">RNA</label>
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewPROT_§DOM" value="PROT" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewPROT_§DOM">Protein</label>
        <input type="radio" class="btn-check" name="umapView_§DOM" id="viewBOTH_§DOM" value="BOTH" autocomplete="off">
        <label class="btn btn-outline-secondary" for="viewBOTH_§DOM">Both</label>
      </div>
      <div class="form-check form-switch mb-0 protCtrl">
        <input class="form-check-input" type="checkbox" id="linkRanges_§DOM" checked>
        <label class="form-check-label" for="linkRanges_§DOM">Link ranges</label>
      </div>
      <button id="plotCluster_§DOM" class="btn btn-sm btn-secondary">Plot clusters</button>
    </div>
    <div id="geneFeedback_§DOM" class="visually-hidden" aria-live="polite"></div>
    <div class="row">
      <div class="col-md-6 col-lg-4" id="clustCol_§DOM">
        <div id="clusterPlot_§DOM" class="plot-area"></div>
      </div>
      <div class="col-md-6 col-lg-4" id="rnaCol_§DOM">
        <div id="genePlot_§DOM" class="plot-area"></div>
      </div>
      <div class="col-md-6 col-lg-4 d-none" id="protCol_§DOM">
        <div id="protPlot_§DOM" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="umapobs" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0 protCtrl" for="umapObsMod_§DOM">Modality</label>
      <select id="umapObsMod_§DOM" class="form-select form-select-sm protCtrl" style="max-width:130px">
        <option value="RNA">RNA</option>
        <option value="Protein">Protein</option>
      </select>
      <label class="form-label mb-0" for="umapObsFeat_§DOM">Feature</label>
      <input id="umapObsFeat_§DOM" class="form-control form-control-sm" style="max-width:260px" list="geneList_§DOM" placeholder="e.g., LST1" />
      <label class="form-label mb-0" for="obsGroupSel_§DOM">Group by</label>
      <select id="obsGroupSel_§DOM" class="form-select form-select-sm" style="max-width:200px"></select>
      <label class="form-label mb-0" for="umapObsView_§DOM">View</label>
      <div class="btn-group btn-group-sm" role="group" id="umapObsView_§DOM">
        <input type="radio" class="btn-check" name="umapObsView_§DOM" id="umapObsViewUMAP_§DOM" value="umap" autocomplete="off" checked>
        <label class="btn btn-outline-secondary" for="umapObsViewUMAP_§DOM">UMAP</label>
        <input type="radio" class="btn-check" name="umapObsView_§DOM" id="umapObsViewViolin_§DOM" value="violin" autocomplete="off">
        <label class="btn btn-outline-secondary" for="umapObsViewViolin_§DOM">Violin</label>
      </div>
      <label class="form-label mb-0" for="umapObsPoints_§DOM">Points</label>
      <select id="umapObsPoints_§DOM" class="form-select form-select-sm" style="max-width:150px">
        <option value="all" selected>All</option>
        <option value="none">None</option>
        <option value="suspectedoutliers">Outliers</option>
      </select>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="umapObsJitter_§DOM" value="0.3">
        <label class="form-check-label" for="umapObsJitter_§DOM">Jitter</label>
      </div>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="obsShowBackground_§DOM" checked>
        <label class="form-check-label" for="obsShowBackground_§DOM">Show background</label>
      </div>
      <button id="umapObsPlot_§DOM" class="btn btn-sm btn-secondary">Plot clusters</button>
    </div>
    <h5 id="umapObsTitle_§DOM" class="text-center mb-3"></h5>
    <div id="umapObsGrid_§DOM" class="umapObsGrid"></div>
    <div id="umapObsViolin_§DOM" class="plot-area" style="display:none;"></div>
  </div>
  <div id="btm" class="tabpane">
    <div class="enrichment-toolbar d-flex flex-wrap align-items-center gap-3 mb-3">
      <div class="segmented-control" id="enrichmentToggle_§DOM" role="group" aria-label="Select enrichment source">
        <div class="segment">
          <input type="radio" name="enrichmentSource_§DOM" id="enrichBTM_§DOM" value="btm" checked>
          <label for="enrichBTM_§DOM">BTM enrichment</label>
        </div>
        <div class="segment">
          <input type="radio" name="enrichmentSource_§DOM" id="enrichHallmark_§DOM" value="hallmarks">
          <label for="enrichHallmark_§DOM">Hallmark enrichment</label>
        </div>
        <div class="segment">
          <input type="radio" name="enrichmentSource_§DOM" id="enrichTF_§DOM" value="tf">
          <label for="enrichTF_§DOM">TF enrichment</label>
        </div>
        <div class="segment">
          <input type="radio" name="enrichmentSource_§DOM" id="enrichReceptor_§DOM" value="receptor">
          <label for="enrichReceptor_§DOM">Receptor enrichment</label>
        </div>
        <div class="segment d-none" id="enrichCustomSegment_§DOM">
          <input type="radio" name="enrichmentSource_§DOM" id="enrichCustom_§DOM" value="custom">
          <label for="enrichCustom_§DOM">Custom enrichment</label>
        </div>
      </div>
    </div>
    <div class="enrichment-panels">
      <section class="enrichment-panel active" data-enrichment="btm">
        <div class="row">
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="btmStatSel_§DOM">Stats</label>
              <select id="btmStatSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="gsea" selected>GSEA</option>
                <option value="gsva">GSVA</option>
              </select>
              <label class="form-label mb-0" for="btmCelltypeSel_§DOM">Cell type</label>
              <select id="btmCelltypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
              <label class="form-label mb-0" for="btmVisSel_§DOM">View</label>
              <select id="btmVisSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="bar" selected>Barplot</option>
                <option value="dot">Dotplot</option>
              </select>
              <label class="form-label mb-0" for="btmTopSel_§DOM">Top</label>
              <select id="btmTopSel_§DOM" class="form-select form-select-sm" style="max-width:100px">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="25" selected>25</option>
              </select>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="trending-up" aria-hidden="true"></i>
                <span>GSEA</span>
              </span>
              <div id="btmPlot_§DOM" class="plot-area"></div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="btmGsvaInput_§DOM">Gene set</label>
              <input id="btmGsvaInput_§DOM" list="btmGsvaList_§DOM" class="form-control form-control-sm" style="max-width:180px"/>
              <datalist id="btmGsvaList_§DOM"></datalist>
              <button id="btmGsvaDownload_§DOM" class="btn btn-sm btn-outline-secondary ms-auto">Download CSV</button>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="bar-chart-2" aria-hidden="true"></i>
                <span>GSVA</span>
              </span>
              <div id="btmBox_§DOM" class="plot-area"></div>
            </div>
          </div>
        </div>
      </section>
      <section class="enrichment-panel" data-enrichment="hallmarks">
        <div class="row">
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="hallmarkStatSel_§DOM">Stats</label>
              <select id="hallmarkStatSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="gsea" selected>GSEA</option>
                <option value="gsva">GSVA</option>
              </select>
              <label class="form-label mb-0" for="hallmarkCelltypeSel_§DOM">Cell type</label>
              <select id="hallmarkCelltypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
              <label class="form-label mb-0" for="hallmarkVisSel_§DOM">View</label>
              <select id="hallmarkVisSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="bar" selected>Barplot</option>
                <option value="dot">Dotplot</option>
              </select>
              <label class="form-label mb-0" for="hallmarkTopSel_§DOM">Top</label>
              <select id="hallmarkTopSel_§DOM" class="form-select form-select-sm" style="max-width:100px">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="25" selected>25</option>
              </select>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="trending-up" aria-hidden="true"></i>
                <span>GSEA</span>
              </span>
              <div id="hallmarkPlot_§DOM" class="plot-area"></div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="hallmarkGsvaInput_§DOM">Gene set</label>
              <input id="hallmarkGsvaInput_§DOM" list="hallmarkGsvaList_§DOM" class="form-control form-control-sm" style="max-width:180px"/>
              <datalist id="hallmarkGsvaList_§DOM"></datalist>
              <button id="hallmarkGsvaDownload_§DOM" class="btn btn-sm btn-outline-secondary ms-auto">Download CSV</button>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="bar-chart-2" aria-hidden="true"></i>
                <span>GSVA</span>
              </span>
              <div id="hallmarkBox_§DOM" class="plot-area"></div>
            </div>
          </div>
        </div>
      </section>
      <section class="enrichment-panel" data-enrichment="tf">
        <div class="row">
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="tfStatSel_§DOM">Stats</label>
              <select id="tfStatSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="gsea" selected>GSEA</option>
                <option value="gsva">GSVA</option>
              </select>
              <label class="form-label mb-0" for="tfCelltypeSel_§DOM">Cell type</label>
              <select id="tfCelltypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
              <label class="form-label mb-0" for="tfVisSel_§DOM">View</label>
              <select id="tfVisSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="bar" selected>Barplot</option>
                <option value="dot">Dotplot</option>
              </select>
              <label class="form-label mb-0" for="tfTopSel_§DOM">Top</label>
              <select id="tfTopSel_§DOM" class="form-select form-select-sm" style="max-width:100px">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="25" selected>25</option>
              </select>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="trending-up" aria-hidden="true"></i>
                <span>GSEA</span>
              </span>
              <div id="tfPlot_§DOM" class="plot-area"></div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="tfGsvaInput_§DOM">Gene set</label>
              <input id="tfGsvaInput_§DOM" list="tfGsvaList_§DOM" class="form-control form-control-sm" style="max-width:180px"/>
              <datalist id="tfGsvaList_§DOM"></datalist>
              <button id="tfGsvaDownload_§DOM" class="btn btn-sm btn-outline-secondary ms-auto">Download CSV</button>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="bar-chart-2" aria-hidden="true"></i>
                <span>GSVA</span>
              </span>
              <div id="tfBox_§DOM" class="plot-area"></div>
            </div>
          </div>
        </div>
      </section>
      <section class="enrichment-panel" data-enrichment="receptor">
        <div class="row">
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="receptorStatSel_§DOM">Stats</label>
              <select id="receptorStatSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="gsea" selected>GSEA</option>
                <option value="gsva">GSVA</option>
              </select>
              <label class="form-label mb-0" for="receptorCelltypeSel_§DOM">Cell type</label>
              <select id="receptorCelltypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
              <label class="form-label mb-0" for="receptorVisSel_§DOM">View</label>
              <select id="receptorVisSel_§DOM" class="form-select form-select-sm" style="max-width:140px">
                <option value="bar" selected>Barplot</option>
                <option value="dot">Dotplot</option>
              </select>
              <label class="form-label mb-0" for="receptorTopSel_§DOM">Top</label>
              <select id="receptorTopSel_§DOM" class="form-select form-select-sm" style="max-width:100px">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="25" selected>25</option>
              </select>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="trending-up" aria-hidden="true"></i>
                <span>GSEA</span>
              </span>
              <div id="receptorPlot_§DOM" class="plot-area"></div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="d-flex gap-2 align-items-center mb-2">
              <label class="form-label mb-0" for="receptorGsvaInput_§DOM">Gene set</label>
              <input id="receptorGsvaInput_§DOM" list="receptorGsvaList_§DOM" class="form-control form-control-sm" style="max-width:180px"/>
              <datalist id="receptorGsvaList_§DOM"></datalist>
              <button id="receptorGsvaDownload_§DOM" class="btn btn-sm btn-outline-secondary ms-auto">Download CSV</button>
            </div>
            <div class="plot-wrapper">
              <span class="plot-badge">
                <i data-feather="bar-chart-2" aria-hidden="true"></i>
                <span>GSVA</span>
              </span>
              <div id="receptorBox_§DOM" class="plot-area"></div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>
  <div id="tfnet" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="tfNetCelltypeSel_§DOM">Cell type</label>
      <select id="tfNetCelltypeSel_§DOM" class="form-select form-select-sm" style="max-width:180px"></select>
      <label class="form-label mb-0" for="tfNetTopSel_§DOM">Top TFs</label>
      <input id="tfNetTopSel_§DOM" type="number" min="1" value="10" class="form-control form-control-sm" style="max-width:80px" data-default="10" />
      <label class="form-label mb-0" for="tfNetTargetSel_§DOM">Targets</label>
      <input id="tfNetTargetSel_§DOM" type="number" min="1" value="5" class="form-control form-control-sm" style="max-width:80px" data-default="5" />
      <button id="tfNetReset_§DOM" type="button" class="btn btn-sm btn-secondary ms-auto">Reset</button>
    </div>
    <p class="text-muted small mb-3" id="tfNetLegend">
      <span data-color-desc="default">Squares represent transcription factors, circles are target genes. Node colour reflects log fold change (red = higher in the test group, blue = higher in the reference group). Green edges indicate positive influence; red edges indicate negative influence.</span>
      <span data-color-desc="colorblind" class="d-none">Squares represent transcription factors, circles are target genes. Node colour reflects log fold change using a purple–orange scale (purple = higher in the test group, orange = higher in the reference group). Teal edges indicate positive influence; orange edges indicate negative influence.</span>
      Hovering highlights neighbours and clicking a node updates the expression box plot on the right.
    </p>
    <div class="row">
      <div class="col-md-6"><div id="tfNetPlot_§DOM" class="plot-area"></div></div>
      <div class="col-md-6"><div id="tfNetBox_§DOM" class="plot-area"></div></div>
    </div>
  </div>
  <div id="volcano" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="volcanoCelltype">Cell type</label>
      <select id="volcanoCelltype" class="form-select form-select-sm" style="max-width:160px"></select>
      <button id="volcanoReset" class="btn btn-sm btn-secondary">Reset</button>
    </div>
    <p id="volcanoCaption" class="contrast-caption text-muted small d-none" aria-live="polite"></p>
    <div class="row g-3">
      <div class="col-md-6"><div id="volcanoPlot" class="plot-area"></div></div>
      <div class="col-md-6"><div id="volcanoBox" class="plot-area"></div></div>
    </div>
  </div>
  <div id="dge" class="tabpane">
    <div class="d-flex gap-2 align-items-center mb-2">
      <label class="form-label mb-0" for="dgeCelltype">Cell type</label>
      <select id="dgeCelltype" class="form-select form-select-sm" style="max-width:160px"></select>
    </div>
    <div class="row g-3">
      <div class="col-md-6">
        <table id="dgeTable" class="table table-sm table-hover">
          <caption id="dgeTableCaption" class="contrast-caption text-muted small d-none" aria-live="polite"></caption>
        </table>
      </div>
      <div class="col-md-6">
        <div id="dgeBox" class="plot-area"></div>
      </div>
    </div>
  </div>
  <div id="biology" class="tabpane">
    <div class="row g-3">
      <div class="col-md-6"><div id="aiInsightsUMAP_§DOM" class="plot-area"></div></div>
      <div class="col-md-6">
        <div class="d-flex justify-content-end mb-2">
          <button id="downloadInsightsBtn" class="btn btn-sm btn-outline-secondary">Download table</button>
        </div>
        <div id="biologyContent" class="p-3">Loading...</div>
      </div>
    </div>
  </div>
  <div id="overview" class="tabpane show">
    <div id="summaryWrapper" class="summary-wrapper">
      <section id="summaryHero" class="summary-hero">
        <div class="summary-hero-text">
          <div id="summaryHeroKicker" class="summary-hero-kicker d-none"></div>
          <h2 id="summaryHeroTitle" class="summary-hero-title">Integrated tissue overview</h2>
          <p id="summaryHeroDescription" class="summary-hero-description"></p>
          <div id="summaryHeroMetrics" class="summary-metric-grid"></div>
          <div class="summary-hero-actions">
            <button type="button" class="summary-btn primary" data-target="btm">Explore pathways</button>
            <button type="button" class="summary-btn secondary" data-target="biology">AI insights</button>
          </div>
        </div>
      </section>
      <section id="summaryNarrativeSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="file-text" class="summary-section-icon"></i>Detailed narrative</h3>
        <div id="summaryMarkdown" class="summary-markdown"></div>
      </section>
      <section id="summaryPerCellSection" class="summary-section">
        <h3 class="summary-section-title">
          <i data-feather="grid" class="summary-section-icon"></i>
          Per-celltype quick card
        </h3>
        <div id="summaryCelltypePills" class="mb-3 d-flex flex-wrap gap-2"></div>
        <div id="summaryCelltypeCard" class="row g-3"></div>
      </section>
      <section id="summaryWarnings" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="alert-triangle" class="summary-section-icon"></i>Alerts</h3>
        <div id="summaryWarningsList" class="summary-alert-list"></div>
      </section>
      <section id="summaryHighlightsSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="star" class="summary-section-icon"></i>Key findings</h3>
        <div id="summaryHighlightsGrid" class="summary-card-grid"></div>
      </section>
      <section id="summaryCompositionSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="pie-chart" class="summary-section-icon"></i>Composition shifts</h3>
        <div id="summaryCompositionList" class="summary-composition-list"></div>
      </section>
      <section id="summaryGenesSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="activity" class="summary-section-icon"></i>Tissue-level genes</h3>
        <div class="summary-two-column">
          <div>
            <h4 class="summary-subtitle">Top upregulated</h4>
            <ul id="summaryGenesUp" class="summary-chip-list"></ul>
          </div>
          <div>
            <h4 class="summary-subtitle">Top downregulated</h4>
            <ul id="summaryGenesDown" class="summary-chip-list"></ul>
          </div>
        </div>
      </section>
      <section id="summaryPathwaysSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="layers" class="summary-section-icon"></i>Pathway programs</h3>
        <div id="summaryPathwaysGrid" class="summary-card-grid"></div>
      </section>
      <section id="summaryRegulatorsSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="cpu" class="summary-section-icon"></i>Candidate regulators</h3>
        <div id="summaryRegulatorsList" class="summary-card-grid"></div>
      </section>
      <section id="summaryInteractionsSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="share-2" class="summary-section-icon"></i>Cell–cell interactions</h3>
        <div id="summaryInteractionsList" class="summary-card-grid"></div>
      </section>
      <section id="summaryDiseaseSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="target" class="summary-section-icon"></i>Disease links &amp; therapeutics</h3>
        <div id="summaryDiseaseList" class="summary-card-grid"></div>
      </section>
      <section id="summaryHypothesesSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="zap" class="summary-section-icon"></i>Hypotheses &amp; validation ideas</h3>
        <div id="summaryHypothesesList" class="summary-card-grid"></div>
      </section>
      <section id="summarySensitivitySection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="shield" class="summary-section-icon"></i>Robustness &amp; anomalies</h3>
        <div id="summarySensitivityList" class="summary-list"></div>
      </section>
      <section id="summaryMetadataSection" class="summary-section d-none">
        <h3 class="summary-section-title"><i data-feather="info" class="summary-section-icon"></i>Run metadata</h3>
        <dl id="summaryMetadataList" class="summary-metadata-grid"></dl>
      </section>
    </div>
  </div>
  <div id="methods" class="tabpane">
    <div class="card p-4 mb-3">
      <h4 class="mb-3">Methods — STREAM v2.0 dashboard build</h4>
      <h5 class="mt-3">Data inputs &amp; preprocessing</h5>
      <ul class="small mb-3">
        <li><strong>Input object:</strong> the notebook expects a preprocessed <code>AnnData</code> object with <code>X_umap</code> coordinates, a clustering column (<code>§LEIDEN</code>), QC metrics, and optional nearest-neighbour connectivities. When “CITE-seq (MuData)” is enabled the RNA modality is extracted from <code>MuData</code> and paired with an antibody/protein modality for ADT plots.</li>
        <li><strong>Layer selection:</strong> the chosen expression layer (default: active layer) is used when encoding per-cell expression vectors. Users can restrict payloads to the union of edgeR-significant marker genes (“Markers only”).</li>
        <li><strong>Metadata:</strong> categorical annotations in <code>adata.obs</code> are collected with their palette stored in <code>adata.uns[&lt;cat&gt;_colors]</code>. QC arrays (<code>n_counts</code>, <code>n_genes</code>, mitochondrial/ribosomal percentages, doublet scores) plus optional <code>batch</code> and <code>cell_cycle</code> labels are exported for the QC tab. If a connectivities matrix is present, its CSR indices are sent so the client can recompute cluster neighbourhoods.</li>
        <li><strong>Cluster rendering:</strong> UMAP colours are derived with an adjacency-aware greedy colouring that avoids assigning identical hues to touching clusters. Cluster sizes and per-cluster cell IDs are cached for downstream tabs.</li>
      </ul>

      <h5 class="mt-3">Per-cell-state pseudobulk differential expression</h5>
      <ul class="small mb-3">
        <li>For each annotated cell state (<code>adata.obs[celltype_var]</code>) we load precomputed edgeR likelihood-ratio results from <code>./STREAM/Pseudobulk/&lt;cell&gt;_{contrast_var}_edgeR_results.csv</code>. Column names are normalised (<code>gene_symbol</code>, <code>LR</code>, <code>FDR</code>, <code>log2FoldChange</code>/<code>logFC</code>).</li>
        <li>Genes with <code>FDR &lt; 0.05</code> define the marker union used to seed volcano plots, DE tables, and (optionally) the subset of genes delivered to the browser. Separate up/down lists (top 50 by fold-change sign) are cached for AI prompts.</li>
        <li>TMM-normalised counts emitted by edgeR (<code>_edgeR_results.csv</code>) together with metadata (<code>_metadata.csv</code>) back the box plots and GSVA panels. The first metadata column names the sample ID; the column <code>Group_var</code> (set elsewhere in the notebook) specifies the experimental grouping shown in the UI.</li>
      </ul>

      <h5 class="mt-3">Gene-set, pathway, and regulator scoring</h5>
      <ul class="small mb-3">
        <li><strong>BTM modules:</strong> decoupler’s <code>mt.ulm</code> is applied to edgeR LR statistics against the curated <code>BTM_for_GSEA_20131008_fixed.gmt</code> network. Terms with <code>padj &lt; 0.05</code> are prioritised by adjusted p-value (tie-breaking on activity) and the top 25 per cell type are stored (top 5 power the “BTM markers” chips). Sample-level GSVA scores are recomputed from the TMM-normalised expression matrix embedded in <code>_edgeR_results.csv</code> and tested versus <code>Group_var</code> using an ANOVA/Spearman helper (<code>global_test</code>), populating the box plots and summary stats.</li>
        <li><strong>Hallmark pathways:</strong> the same workflow runs on <code>dc.op.hallmark(organism="human")</code>, keeping pathways with significant activity. GSVA-derived distributions and FDR-adjusted global tests are exposed alongside the enrichment table.</li>
        <li><strong>Regulators:</strong> transcription-factor enrichment uses <code>dc.op.collectri</code> as the regulatory network. ULM scores are filtered at <code>padj &lt; 0.05</code>, and the resulting TF network is decorated with per-target log fold-changes. Additional GSVA analyses reuse the TMM-normalised expression matrix to deliver per-group activity distributions for the “TF activity” tab.</li>
      </ul>

      <h5 class="mt-3">Expression payload &amp; rendering</h5>
      <ul class="small mb-3">
        <li>For each retained gene we pull the selected expression layer, extract non-zero values, rescale them between the 20th and 99th percentiles, and quantise to 8-bit integers. Indices and quantised vectors are gzip-compressed and base64-encoded for the browser. Optional ADT counts undergo the same procedure for the chosen protein layer.</li>
        <li>A custom 256-colour grey→rainbow palette (light grey for low signal, rainbow for higher deciles) is generated from Matplotlib and ColorCET and supplied to all expression plots, ensuring consistency across RNA and protein views.</li>
        <li>Vendor assets referenced in the template are inlined after writing the HTML so that the exported dashboard is a single, offline-friendly file.</li>
      </ul>

      <h5 class="mt-3">AI insights — optional</h5>
      <p class="mb-2">
        Enabling “Generate biology insights” triggers LLM-backed summaries per cell type. The model receives only aggregate artefacts (cluster sizes, edgeR up/down lists, top BTM/Hallmark/TF hits and their scores) together with study context from <code>PROJECT_TITLE</code>/<code>PROJECT_CONTEXT</code>/<code>CONTRAST_VAR</code>. Outputs are harmonised into a strict Markdown template with canonical/fine labels, confidence, and key markers, and an overview prompt synthesises tissue-wide takeaways. Raw counts or per-cell matrices never leave the session.
      </p>

      <h5 class="mt-3">Dashboard tabs — content, statistics, AI usage</h5>
      <ul class="small mb-3">
        <li><strong>Summary:</strong> What you see — hero metrics, per-celltype cards, optional alerts and narratives; Statistics — reuses edgeR markers, GSVA summaries, and metadata counts prepared upstream with no extra testing in the browser; AI — if enabled, the same aggregated payload seeds the hero summary and per-celltype quick cards.</li>
        <li><strong>DGE:</strong> What you see — edgeR likelihood-ratio results per cell type (log<sub>2</sub>FC, LR, FDR) alongside log1p TMM-normalised box plots by <code>Group_var</code>; Statistics — edgeR LRT against the active contrast with Benjamini-Hochberg FDR, box plots display log-transformed edgeR-normalised counts; AI — top up/down lists here are passed verbatim to the LLM prompts.</li>
        <li><strong>Volcano:</strong> What you see — log<sub>2</sub> fold-change versus -log<sub>10</sub>(FDR) scatter plus per-gene TMM-normalised boxes; Statistics — identical edgeR LRT/FDR values power the highlights; AI — the highlighted genes mirror the DGE payload consumed by AI insights.</li>
        <li><strong>Clusters &amp; Genes:</strong> What you see — integrated UMAP coordinates with RNA/ADT overlays using the 20-99% rescaled expression palette; Statistics — descriptive only (no additional tests beyond the upstream UMAP fit); AI — expression tiles are not consumed by the AI pipeline.</li>
        <li><strong>Sample/Condition:</strong> What you see — faceted UMAPs and optional violin plots grouped by any categorical <code>adata.obs</code> field; Statistics — descriptive distributions built from the same quantised expression vectors, no new inference; AI — baseline cell fractions (and optional deltas if provided during build) are forwarded as <code>baseline_fraction</code>/<code>delta_fraction</code> in the prompts.</li>
        <li><strong>BTM enrichment:</strong> What you see — top module bar/dot plots plus GSVA box plots; Statistics — decoupler ULM scores on edgeR LR values with Benjamini-Hochberg filtering, per-sample GSVA tested via <code>global_test</code> (ANOVA for categorical <code>Group_var</code>, Spearman otherwise); AI — the ranked modules and q-values are embedded in each cell-type prompt.</li>
        <li><strong>Hallmark enrichment:</strong> What you see — MSigDB Hallmark activity charts and GSVA distributions; Statistics — same ULM + GSVA + <code>global_test</code> workflow as BTM; AI — significant pathways and FDR values are injected into the prompts.</li>
        <li><strong>TF enrichment:</strong> What you see — transcription-factor activity bar/dot plots and GSVA box plots; Statistics — decoupler <code>collectri</code> ULM scores with BH-adjusted padj plus GSVA/<code>global_test</code>; AI — the top TFs and q-values populate the regulator section of the AI payload.</li>
        <li><strong>TF network:</strong> What you see — interactive graph of the top enriched TFs with target connections; Statistics — node ranking derives from the same ULM scores, edge colours use edgeR log<sub>2</sub>FC values, no additional testing; AI — regulators surfaced here are identical to the TF enrichment payload consumed by the LLM.</li>
        <li><strong>AI Insights:</strong> What you see — per-celltype Markdown plus an optional dataset-level overview generated by the LLM; Statistics — no further hypothesis testing in-browser; AI — output reflects the prompt assembled from DGE, BTM, Hallmark, TF, and composition inputs.</li>
        <li><strong>QC:</strong> What you see — metric-specific UMAPs, histograms, per-cluster violins, and batch/mixing panels (including iLISI when available); Statistics — descriptive summaries driven by gating thresholds, percentile cut-offs, and upstream integration scores; AI — QC metrics are not transmitted to the AI workflow.</li>
        <li><strong>Custom gene-set tabs (if enabled):</strong> What you see — additional enrichment/GSVA panels mirroring the BTM/Hallmark layout; Statistics — same decoupler ULM and <code>global_test</code> pipeline applied to the user-supplied GMT; AI — significant terms are appended to the custom section of each prompt.</li>
        <li><strong>About:</strong> What you see — toolkit and dataset metadata; Statistics — informational only; AI — not used by the AI pipeline.</li>
      </ul>

      <details class="mt-2">
        <summary class="small text-muted">Show general AI prompt</summary>
        <pre class="legal-pre small">ROLE
You are “GeneSage,” a PhD-level molecular biologist and single-cell bioinformatics specialist.

OBJECTIVE
Predict the most likely cell type for {leiden} cluster {cluster} in dataset {dataset_name} using ONLY the inputs provided.

INPUTS
Cluster size: {size}
{top_marker_lines}
Additional marker genes per method (JSON): {cl_markers}
BTM modules (JSON): {cl_btm_json}
Hallmark pathways (JSON): {cl_hall_json}
Tissue context: {tissue_context}

OUTPUT
Return a concise markdown paragraph with the canonical label, an optional fine
label, confidence (High/Medium/Low), and key markers supporting the call.</pre>
      </details>

      <p class="small text-muted mt-3 mb-0">
        QC and composition tabs reflect the layer chosen at run time; when multiple layers are available the same dashboard can be regenerated for alternative normalisations.
      </p>
    </div>
  </div>
  <div id="about" class="tabpane">
  <div class="about-hero card shadow-sm p-4 mb-4">
    <div class="d-flex align-items-center gap-3 mb-3">
      <svg class="logoSVG" style="max-width:140px;" viewBox="0 0 400 250" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="STREAM logo"><use href="#logoSymbol"/></svg>
      <div>
        <h3 class="mb-1">STREAM</h3>
        <div class="text-muted">Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics</div>
      </div>
    </div>

    <!-- Expanded product sentence (requested) -->
    <p class="lead mb-2">
      Interactive data mining and analysis of bulk and single-cell expression data —
      delivered as a fast, shareable HTML dashboard with UMAPs, marker discovery,
      and enrichment for BTM modules and Hallmark pathways.
    </p>

    <!-- Mission (requested: accessibility + data mining help) -->
    <ul class="about-mission mb-0">
      <li><strong>Accessible bioinformatics:</strong> zero-install, point-and-click dashboards that work offline.</li>
      <li><strong>Ai assisted annotation:</strong> LLM-assisted, cluster-wise summaries with transparent prompts & inputs.</li>
      <li><strong>Faster insights:</strong> opinionated defaults for QC, markers and module activity to speed up data mining.</li>
      <li><strong>Reproducible & transparent:</strong> embedded metadata, versioned templates, and explicit sources for enrichment.</li>
      <li><strong>Shareable results:</strong> a single HTML file you can send to collaborators or attach to a preprint.</li>
    </ul>
  </div>

  <div class="row g-3 about-grid">
    <!-- Toolkit overview (concise) -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">About the toolkit</h5>
        <p class="small mb-0">
          STREAM is a zero-install workflow that transforms differential-expression analyses from bulk, single-cell and pseudobulk RNA-seq experiments into an interactive HTML dashboard. It is designed to make exploratory analysis reproducible and accessible by automating quality control (QC), clustering, marker discovery, enrichment analysis and multi-scale summarization. Instead of requiring collaborators to rerun notebooks, STREAM bundles all analyses, including interactive plots, statistics and provenance, into a single offline-capable web page.
        </p>
      </div>
    </div>

    <!-- Dataset metadata (clear, compact) -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">About this dataset</h5>
        <dl class="about-kv">
          <dt>Dataset</dt>             <dd id="about-ds">§DATA_NAME</dd>
          <dt>Layer</dt>               <dd id="about-layer">§LAYER</dd>
          <dt>Technology</dt>          <dd id="about-technology">§TECHNOLOGY</dd>
          <dt>Cells</dt>               <dd id="about-cells">–</dd>
          <dt>Median UMIs / cell</dt>  <dd id="about-umis-cell">–</dd>
          <dt>Total UMIs</dt>          <dd id="about-umis-total">–</dd>
          <dt>Median genes / cell</dt> <dd id="about-genes-cell">–</dd>
          <dt>Samples</dt>             <dd id="about-samples">–</dd>
          <dt>Generated</dt>           <dd>§GENERATED</dd>
          <dt>Version</dt>             <dd>2.0</dd>
        </dl>
        <div class="small text-muted mt-2">
          Notes: values shown reflect the current HTML build; analyses respect the selected layer.
        </div>
      </div>
    </div>

    <!-- People & support -->
    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">Contributors</h5>
        <ul class="list-unstyled mb-0">
          <li>
            Victor Barozi —
            <a href="mailto:V.Barozi@soton.ac.uk">V.Barozi@soton.ac.uk</a>
          </li>
          <li>
            Andres F. Vallejo —
            <a href="mailto:afvp1f17@soton.ac.uk">afvp1f17@soton.ac.uk</a>
          </li>
        </ul>
      </div>
    </div>

    <div class="col-lg-6">
      <div class="card h-100 p-4">
        <h5 class="mb-3">Support & Acknowledgements</h5>
        <p class="mb-2">Single Cell MultiOmics Lab</p>
      <p class="small mb-0">
        If you use STREAM in your work, please cite:
        <em>STREAM (v2.0) — Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics, generated §GENERATED.</em>
      </p>
    </div>
  </div>

      <!-- Legal & Licensing -->
      <div class="col-12">
        <div class="card h-100 p-4">
          <h5 class="mb-2">Legal & Licensing</h5>

          <!-- Disclaimer -->
          <div class="small">
            <p class="mb-2"><strong>Disclaimer.</strong> STREAM is a research and education tool. It is not intended for clinical, diagnostic, or patient-management decisions.</p>
            <ul class="mb-2">
              <li><strong>AI Insights (if enabled)</strong> are LLM-generated summaries that can be incomplete or incorrect; always validate with markers, BTM modules, and Hallmark pathways.</li>
              <li><strong>Privacy.</strong> This dashboard does not upload sample-level data to a server; rendering happens in your browser. (If you need strict offline use, bundle local JS/CSS assets instead of CDNs.)</li>
              <li><strong>Upstream AI usage.</strong> If you tick “Generate biology insights” during build, cluster-level summaries (markers, enrichment ranks, etc.) are sent to the configured AI provider to produce text; raw counts are not sent.</li>
              <li><strong>No warranty.</strong> Provided “AS IS” without warranty of any kind; you are responsible for verifying results and for compliance with any data-use terms.</li>
            </ul>
          </div>

          <!-- Licenses -->
          <div class="small">
            <div class="mb-1"><strong>STREAM code license:</strong> <span id="toolLicense">§TOOL_LICENSE</span></div>
            <div><strong>Dataset licence:</strong> <span id="dataLicense">§DATA_LICENSE</span></div>
          </div>

          <!-- Full license text (MIT by default) -->
          <details class="mt-2">
            <summary class="small text-muted">Show full STREAM license</summary>
            <pre class="legal-pre small">MIT License

Copyright (c) 2025 Single Cell MultiOmics Lab / STREAM Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</pre>
          </details>
        </div>
      </div>
  </div>

</div>
<div id="globalFooter" class="text-end">
  <div class="about-tagline">
    <span class="about-dot"></span>
    <span class="about-dot"></span>
    <span class="about-dot"></span>
    <span class="about-text">Make your omics flow</span>
  </div>
  <div class="small text-muted">
    See <a href="#about" onclick="setHash('about');">Legal & Licensing</a>.
  </div>
</div>
<div id="helpOverlay">
  <button type="button" class="btn-close help-close"></button>
  <div id="helpContent"></div>
  <button id="startTourBtn" class="btn btn-sm btn-primary mt-3">Start tour</button>
</div>
<div id="helpBackdrop"></div>
<div id="tourOverlay" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="tourText">
  <div class="tour-dialog" role="document">
    <p id="tourText" class="mb-0"></p>
    <button id="tourNext" type="button" class="btn btn-sm btn-light align-self-end">Next</button>
  </div>
</div>
<div id="tourFrame" aria-hidden="true"></div>
<script>
const BASE64_LOOKUP = (()=>{
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  const table = new Uint8Array(256);
  table.fill(255);
  for(let i=0;i<chars.length;i++){
    table[chars.charCodeAt(i)] = i;
  }
  return table;
})();

function b64ToUint8Array(b64){
  if(!b64) return new Uint8Array(0);
  const clean = b64.replace(/\s+/g,'');
  const len = clean.length;
  if(len % 4){ throw new Error('Invalid base64 length'); }
  const padding = clean.endsWith('==') ? 2 : clean.endsWith('=') ? 1 : 0;
  const outputLen = (len * 3 >> 2) - padding;
  const bytes = new Uint8Array(outputLen);
  let byteIndex = 0;
  for(let i=0;i<len;i+=4){
    const ch0 = clean.charCodeAt(i);
    const ch1 = clean.charCodeAt(i+1);
    const ch2 = clean.charCodeAt(i+2);
    const ch3 = clean.charCodeAt(i+3);
    const c0 = BASE64_LOOKUP[ch0];
    const c1 = BASE64_LOOKUP[ch1];
    const c2 = ch2 === 61 ? 0 : BASE64_LOOKUP[ch2];
    const c3 = ch3 === 61 ? 0 : BASE64_LOOKUP[ch3];
    if(c0 === 255 || c1 === 255 || (ch2 !== 61 && c2 === 255) || (ch3 !== 61 && c3 === 255)){
      throw new Error('Invalid base64 character encountered');
    }
    const triple = (c0 << 18) | (c1 << 12) | ((c2 & 63) << 6) | (c3 & 63);
    if(byteIndex < outputLen) bytes[byteIndex++] = (triple >> 16) & 0xFF;
    if(byteIndex < outputLen) bytes[byteIndex++] = (triple >> 8) & 0xFF;
    if(byteIndex < outputLen) bytes[byteIndex++] = triple & 0xFF;
  }
  return bytes;
}
function gunzipUint8Array(bin){
  const chunks=[];
  const inflator = new pako.Inflate({chunkSize:65536, to:'uint8array'});
  inflator.onData = chunk=>{ if(chunk && chunk.length) chunks.push(chunk); };
  const step=1<<17; // ~128 KiB to reduce pako recursion depth
  for(let offset=0; offset<bin.length; offset+=step){
    const slice = bin.subarray(offset, Math.min(bin.length, offset+step));
    inflator.push(slice, offset + step >= bin.length);
    if(inflator.err){ throw new Error(inflator.msg || 'Failed to gunzip'); }
  }
  let total=0;
  chunks.forEach(chunk=>{ total+=chunk.length; });
  const out=new Uint8Array(total);
  let pos=0;
  chunks.forEach(chunk=>{ out.set(chunk,pos); pos+=chunk.length; });
  return out;
}

function inflateExp(b64){
  if(!b64) return {};
  const bin = b64ToUint8Array(b64);
  const out = gunzipUint8Array(bin);
  return JSON.parse(new TextDecoder('utf-8').decode(out));
}
function inflateArray(packed, ctor){
  if(packed == null) return new ctor();
  if(Array.isArray(packed)){
    return new ctor(packed);
  }
  if(packed instanceof ctor){
    return packed;
  }
  if(ArrayBuffer.isView(packed)){
    return new ctor(packed.buffer.slice(packed.byteOffset, packed.byteOffset + packed.byteLength));
  }
  if(packed instanceof ArrayBuffer){
    return new ctor(packed);
  }
  if(typeof packed === 'string'){
    if(!packed) return new ctor();
    const bin = b64ToUint8Array(packed);
    const out = gunzipUint8Array(bin);
    return new ctor(out.buffer);
  }
  console.warn('Unsupported packed array format', packed);
  return new ctor();
}
const EXP_PTR = inflateArray(§EXP_PTR, Uint32Array);
const EXP_INDICES = inflateArray(§EXP_INDICES, Uint32Array);
const EXP_VALUES = inflateArray(§EXP_VALUES, Uint8Array);

function loadExp(){
  return Promise.resolve(true);
}
const SUMMARY_ENABLED = Boolean(§HAS_SUMMARY_TAB);
const SUMMARY_CELLTYPE_DATA = (() => {
  if(!SUMMARY_ENABLED) return {};
  try {
    return inflateExp(§SUMMARY_CELLTYPE_DATA);
  } catch(err){
    console.warn('Embedded per-cell summary unavailable.', err);
    return {};
  }
})();
const GENES = inflateExp(§GENES);
const CMAP_DEFAULT = §CMAP_DEFAULT;
const CMAP_COLORBLIND = §CMAP_COLORBLIND;
let CMAP = Array.isArray(CMAP_DEFAULT) ? CMAP_DEFAULT.slice() : [];
const COLORBAR = {len:0.6, thickness:10};
const VMIN  = inflateArray(§VMIN, Float32Array);
const VMAX  = inflateArray(§VMAX, Float32Array);
const PROT_EXP   = inflateExp(§PROT_EXP);
const PROT_GENES = inflateExp(§PROT_GENES);
const PROT_VMIN  = inflateArray(§PROT_VMIN, Float32Array);
const PROT_VMAX  = inflateArray(§PROT_VMAX, Float32Array);
const PROT_INDEX = Object.fromEntries(PROT_GENES.map((g,i)=>[g,i]));
const CELLS = inflateExp(§CELLS);
const NCELLS = CELLS.length;
const ABOUT_MEDIAN_UMIS = §ABOUT_MEDIAN_UMIS;
const ABOUT_MEDIAN_GENES = §ABOUT_MEDIAN_GENES;
const ABOUT_TOTAL_UMIS = §ABOUT_TOTAL_UMIS;
const DOM = "§DOM";
const PROJECT_TITLE = typeof §PROJECT_TITLE !== 'undefined' ? §PROJECT_TITLE : '';
const PROJECT_CONTEXT = typeof §PROJECT_CONTEXT !== 'undefined' ? §PROJECT_CONTEXT : '';
const HAS_PROT = PROT_GENES.length > 0;
let CURRENT_MODALITY = 'RNA';
let umapObsGeneConfirmed = false;
const NCOUNTS = §NCOUNTS?inflateArray(§NCOUNTS, Float32Array):null;
const NGENES = §NGENES?inflateArray(§NGENES, Float32Array):null;
const PCT_MT = §PCT_MT?inflateArray(§PCT_MT, Float32Array):null;
const PCT_RIBO = §PCT_RIBO?inflateArray(§PCT_RIBO, Float32Array):null;
const DBL_SCORE = §DBL_SCORE?inflateArray(§DBL_SCORE, Float32Array):null;
const BATCH = §BATCH;
const CELL_CYCLE = §CELL_CYCLE;
const NN_INDPTR = §NN_INDPTR?inflateArray(§NN_INDPTR, Int32Array):null;
const NN_INDICES = §NN_INDICES?inflateArray(§NN_INDICES, Int32Array):null;
const BTM_ENRICH = §BTM_ENRICH;
const BTM_GSVA = inflateExp(§BTM_GSVA);
const CUSTOM_GMT_TABS = §CUSTOM_GMT_TABS;
const HALLMARK_ENRICH = §HALLMARK_ENRICH;
const HALLMARK_GSVA = §HALLMARK_GSVA;
const TF_ENRICH = §TF_ENRICH;
const TF_GSVA = inflateExp(§TF_GSVA);
const TF_NETWORK = inflateExp(§TF_NETWORK);
const TF_NET_BOX = inflateExp(§TF_NET_BOX);
const RECEPTOR_ENRICH = §RECEPTOR_ENRICH;
const RECEPTOR_GSVA = inflateExp(§RECEPTOR_GSVA);
const RECEPTOR_NETWORK = inflateExp(§RECEPTOR_NETWORK);
const RECEPTOR_NET_BOX = inflateExp(§RECEPTOR_NET_BOX);

const GENESET_TABS = {
  btm: {
    slug: 'btm',
    navLabel: 'BTM enrichment',
    moduleLabel: 'BTM modules',
    downloadName: 'btm_gsva_results.csv',
    enrich: BTM_ENRICH,
    gsva: BTM_GSVA,
  },
};
if(Array.isArray(CUSTOM_GMT_TABS)){
  CUSTOM_GMT_TABS.forEach(cfg=>{
    if(!cfg || typeof cfg !== 'object') return;
    let slug = (typeof cfg.slug === 'string' && cfg.slug.trim()) ? cfg.slug.trim() : null;
    if(!slug){
      slug = `custom_${Object.keys(GENESET_TABS).length}`;
    }
    if(GENESET_TABS[slug]){
      let idx = 2;
      while(GENESET_TABS[`${slug}_${idx}`]) idx += 1;
      slug = `${slug}_${idx}`;
    }
    const navLabel = (typeof cfg.nav_label === 'string' && cfg.nav_label.trim()) ? cfg.nav_label.trim() : 'Custom enrichment';
    const moduleLabel = (typeof cfg.module_label === 'string' && cfg.module_label.trim()) ? cfg.module_label.trim() : `${navLabel} modules`;
    const downloadName = (typeof cfg.download_name === 'string' && cfg.download_name.trim()) ? cfg.download_name.trim() : `${slug}_gsva_results.csv`;
    let gsvaPayload = {};
    if(cfg.gsvaPacked){
      try{
        gsvaPayload = inflateExp(cfg.gsvaPacked);
      }catch(err){
        console.error('Failed to decompress custom GMT GSVA payload', err);
        gsvaPayload = {};
      }
    } else if(cfg.gsva){
      gsvaPayload = cfg.gsva;
    }
    const enrichPayload = cfg.enrich && typeof cfg.enrich === 'object' ? {...cfg.enrich} : {};
    GENESET_TABS[slug] = {
      slug,
      navLabel,
      moduleLabel,
      downloadName,
      enrich: enrichPayload,
      gsva: gsvaPayload,
    };
  });
}

const geneSetInit = {};
Object.keys(GENESET_TABS).forEach(key=>{ geneSetInit[key] = false; });

sanitizeAllGsva();

const LEIDEN = §LEIDEN;
const UMAP_X = inflateArray(§UMAP_X, Float32Array);
const UMAP_Y = inflateArray(§UMAP_Y, Float32Array);
function arrayExtents(arr){
  let min = Infinity;
  let max = -Infinity;
  for(let i=0;i<arr.length;i++){
    const v = arr[i];
    if(v < min) min = v;
    if(v > max) max = v;
  }
  return [min, max];
}
const [UMAP_X_MIN, UMAP_X_MAX] = arrayExtents(UMAP_X);
const [UMAP_Y_MIN, UMAP_Y_MAX] = arrayExtents(UMAP_Y);
const UMAP_SPAN = Math.max(UMAP_X_MAX-UMAP_X_MIN, UMAP_Y_MAX-UMAP_Y_MIN);
const UMAP_XRANGE = [(UMAP_X_MIN+UMAP_X_MAX)/2 - UMAP_SPAN/2,
                     (UMAP_X_MIN+UMAP_X_MAX)/2 + UMAP_SPAN/2];
const UMAP_YRANGE = [(UMAP_Y_MIN+UMAP_Y_MAX)/2 - UMAP_SPAN/2,
                     (UMAP_Y_MIN+UMAP_Y_MAX)/2 + UMAP_SPAN/2];
const CLUSTER_CODES = inflateArray(§CLUSTER_CODES, Uint16Array);
const CLUSTER_NAMES = inflateExp(§CLUSTER_NAMES);
const CLUSTERS = CLUSTER_NAMES;
const CLUSTER_COLORS_DEFAULT = typeof §CLUSTER_COLORS_DEFAULT !== 'undefined' ? §CLUSTER_COLORS_DEFAULT : null;
const CLUSTER_COLORS_COLORBLIND = typeof §CLUSTER_COLORS_COLORBLIND !== 'undefined' ? §CLUSTER_COLORS_COLORBLIND : null;
let CLUSTER_COLORS = {};
const CELLTYPE_VAR = (() => {
  if(typeof globalThis !== 'undefined'){
    if(globalThis.CELLTYPE_VAR) return globalThis.CELLTYPE_VAR;
    if(globalThis.celltype_var) return globalThis.celltype_var;
  }
  return null;
})();
const CLUSTER_PTS = Array.from({length: CLUSTERS.length}, () => ({xs: [], ys: []}));
for(let i=0;i<NCELLS;i++){
  const ci=CLUSTER_CODES[i];
  if(ci>=CLUSTERS.length)continue;
  const p=CLUSTER_PTS[ci];
  p.xs.push(UMAP_X[i]);
  p.ys.push(UMAP_Y[i]);
}
const CLUSTER_COUNTS = inflateExp(§CLUSTER_COUNTS);
const BIOLOGY_INFO = inflateExp(§BIOLOGY_INFO);
const CLUSTER_INDEX = Object.fromEntries(CLUSTER_NAMES.map((c,i)=>[c,i]));
const GENE_INDEX = Object.fromEntries(GENES.map((g,i)=>[g,i]));
const L_LEFT_POINT_SIZE = 5;
const L_LEFT_POINT_OPACITY = 0.9;

const OBS_CATS = §OBS_CATS;
const OBS_LEVELS = §OBS_LEVELS;
const OBS_COLORS_DEFAULT = §OBS_COLORS;
const OBS_COLORS_COLORBLIND = §OBS_COLORS_CB;
let OBS_COLORS = {};
const OBS_COL_MATRIX = Object.fromEntries(
  Object.entries(§OBS_COL_MATRIX||{}).map(([k,v])=>[k, inflateArray(v, Uint16Array)])
);

const DGE_DATA = DGE_DATA_PLACEHOLDER;
const DGE_CELLTYPES = DGE_CELLTYPES_PLACEHOLDER;

const VOLCANO_CACHE = new Map();
const VOLCANO_SIG_FDR = 0.05;

const EXP_CACHE = new Map();
const MAX_CACHE = 50;
const PSEUDOCOUNT = 0.000001;

const COLOR_PREF_KEY = `stream_color_mode_${DOM}`;
const COLORBLIND_CATEGORICAL = ['#000000','#E69F00','#56B4E9','#009E73','#F0E442','#0072B2','#D55E00','#CC79A7'];
let COLOR_MODE = 'default';

const TF_EDGE_COLORS_DEFAULT = {
  positive: 'rgba(27,158,119,0.7)',
  negative: 'rgba(217,95,80,0.7)',
  focus: 'rgba(80,80,100,0.8)'
};
const TF_EDGE_COLORS_COLORBLIND = {
  positive: 'rgba(27,158,119,0.65)',
  negative: 'rgba(217,95,2,0.65)',
  focus: 'rgba(40,40,40,0.75)'
};
let TF_EDGE_COLORS = TF_EDGE_COLORS_DEFAULT;
const TF_NODE_COLORSCALE_DEFAULT = [
  [0, '#0d47a1'],      // Deep vibrant blue
  [0.2, '#42a5f5'],    // Bright sky blue
  [0.4, '#90caf9'],    // Light crystal blue
  [0.5, '#ffffff'],    // Pure white center
  [0.6, '#ffcdd2'],    // Light rose glass
  [0.8, '#f44336'],    // Vibrant red
  [1, '#b71c1c']       // Deep ruby red
];
const TF_NODE_COLORSCALE_COLORBLIND = [
  [0, '#3f007d'],
  [0.5, '#f7f7f7'],
  [1, '#d95f0e']
];
let TF_NODE_COLORSCALE = TF_NODE_COLORSCALE_DEFAULT;

function fallbackOrdinalColor(index, total, mode = 'default'){
  if(mode === 'colorblind'){
    return COLORBLIND_CATEGORICAL[index % COLORBLIND_CATEGORICAL.length];
  }
  const denom = Math.max(total || 1, 1);
  return `hsl(${(360 * index) / denom},65%,50%)`;
}

function materializeClusterColors(source, mode){
  const palette = {};
  CLUSTER_NAMES.forEach((name, idx)=>{
    const fromSource = source && typeof source === 'object' ? source[name] : null;
    palette[name] = (typeof fromSource === 'string' && fromSource.trim())
      ? fromSource
      : fallbackOrdinalColor(idx, CLUSTERS.length || 1, mode);
  });
  return palette;
}

function buildObsColorMap(source, mode){
  const result = {};
  Object.entries(OBS_LEVELS).forEach(([category, levels])=>{
    const catSource = (source && typeof source === 'object' && source[category]) || {};
    const mapping = {};
    levels.forEach((level, idx)=>{
      const candidate = catSource[level];
      mapping[level] = (typeof candidate === 'string' && candidate.trim())
        ? candidate
        : fallbackOrdinalColor(idx, levels.length || 1, mode);
    });
    result[category] = mapping;
  });
  return result;
}

function refreshColorDependentViews(){
  let clusterUpdated = false;
  const clusterDiv = document.getElementById('clusterPlot_'+DOM);
  if(clusterDiv && clusterDiv.data && clusterDiv.data.length){
    plotClusters();
    clusterUpdated = true;
  }
  if(!clusterUpdated){
    const genePlot = document.getElementById('genePlot_'+DOM);
    if(genePlot && genePlot.data && genePlot.data.length){
      Plotly.restyle(genePlot, {'marker.colorscale':[buildPlotlyScale(CMAP)]});
    }
    const protPlot = document.getElementById('protPlot_'+DOM);
    if(protPlot && protPlot.data && protPlot.data.length){
      Plotly.restyle(protPlot, {'marker.colorscale':[buildPlotlyScale(CMAP)]});
    }
  }
  const obsGrid = document.getElementById(`umapObsGrid_${DOM}`);
  if(obsGrid && obsGrid.childElementCount){
    void drawUmapObs();
  }
  if(biologyInit){
    drawBiologyUMAP();
  }
  if(volcanoInit){
    renderVolcano();
  }
  if(tfNetInit){
    drawTFNetwork();
  }
}

function applyColorMode(mode, {refresh = true} = {}){
  const target = mode === 'colorblind' ? 'colorblind' : 'default';
  COLOR_MODE = target;
  CMAP = target === 'colorblind'
    ? (Array.isArray(CMAP_COLORBLIND) ? CMAP_COLORBLIND.slice() : [])
    : (Array.isArray(CMAP_DEFAULT) ? CMAP_DEFAULT.slice() : []);
  CLUSTER_COLORS = materializeClusterColors(
    target === 'colorblind' ? CLUSTER_COLORS_COLORBLIND : CLUSTER_COLORS_DEFAULT,
    target
  );
  OBS_COLORS = buildObsColorMap(
    target === 'colorblind' ? OBS_COLORS_COLORBLIND : OBS_COLORS_DEFAULT,
    target
  );
  TF_EDGE_COLORS = target === 'colorblind'
    ? TF_EDGE_COLORS_COLORBLIND
    : TF_EDGE_COLORS_DEFAULT;
  TF_NODE_COLORSCALE = target === 'colorblind'
    ? TF_NODE_COLORSCALE_COLORBLIND
    : TF_NODE_COLORSCALE_DEFAULT;
  VOLCANO_COLORS = target === 'colorblind'
    ? VOLCANO_COLORS_COLORBLIND
    : VOLCANO_COLORS_DEFAULT;
  document.documentElement.setAttribute('data-color-mode', target);
  try {
    localStorage.setItem(COLOR_PREF_KEY, target);
  } catch(err){
    /* ignore persistence errors */
  }
  VOLCANO_CACHE.clear();
  const toggleEl = document.getElementById('colorblindToggle_'+DOM);
  if(toggleEl && toggleEl.checked !== (target === 'colorblind')){
    toggleEl.checked = target === 'colorblind';
  }
  document.querySelectorAll('[data-color-desc]').forEach(node=>{
    const modeAttr = node.getAttribute('data-color-desc');
    node.classList.toggle('d-none', Boolean(modeAttr) && modeAttr !== target);
  });
  if(refresh){
    refreshColorDependentViews();
  }
}

const initialColorMode = (() => {
  try {
    const stored = localStorage.getItem(COLOR_PREF_KEY);
    return stored === 'colorblind' ? 'colorblind' : 'default';
  } catch(err){
    return 'default';
  }
})();
/* Initial colour mode is applied after dependent palettes are declared */

function aggregateCounts(sampleKey, groupby){
  const sampleIndex = OBS_COL_MATRIX[sampleKey];
  const groupIndex = OBS_COL_MATRIX[groupby];
  const sampleLabels = OBS_LEVELS[sampleKey]||[];
  const levels = OBS_LEVELS[groupby]||[];
  const nSamples = sampleLabels.length;
  const nGroups = levels.length;
  const counts = new Int32Array(nSamples * nGroups);
  if(!sampleIndex || !groupIndex) return {counts, props:new Float32Array(nSamples*nGroups), sample_labels:sampleLabels, group_labels:levels, n_groups:nGroups};
  for(let i=0;i<sampleIndex.length;i++){
    const r=sampleIndex[i], c=groupIndex[i];
    if(r>=0 && r<nSamples && c>=0 && c<nGroups) counts[r*nGroups+c]++;
  }
  const props = new Float32Array(nSamples * nGroups);
  for(let r=0;r<nSamples;r++){
    let rowSum=0;
    for(let c=0;c<nGroups;c++) rowSum+=counts[r*nGroups+c];
    const denom=rowSum>0?rowSum:1;
    for(let c=0;c<nGroups;c++) props[r*nGroups+c]=counts[r*nGroups+c]/denom;
  }
  return {counts, props, sample_labels:sampleLabels, group_labels:levels, n_groups:nGroups};
}

function getGroupColors(groupby, levels){
  const m = OBS_COLORS[groupby];
  if(m){
    return levels.map((level,i)=>{
      const colour = m[level];
      return (typeof colour === 'string' && colour.trim())
        ? colour
        : fallbackOrdinalColor(i, levels.length || 1, COLOR_MODE);
    });
  }
  return levels.map((_,i)=>fallbackOrdinalColor(i, levels.length || 1, COLOR_MODE));
}

function downloadTableCSV(filename, rows){
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

function sanitizeMinusText(value){
  if(value === null || value === undefined) return value;
  try{
    return window.normalizeMinus ? window.normalizeMinus(String(value)) : String(value).replace('\u2212','-');
  }catch(err){
    return value;
  }
}

function sanitizeNumericValue(value){
  if(value === null || value === undefined || value === '') return value;
  const text = sanitizeMinusText(value);
  const num = Number(text);
  return Number.isFinite(num) ? num : value;
}

function sanitizeNumericArray(arr){
  if(!Array.isArray(arr)) return arr;
  return arr.map(sanitizeNumericValue);
}

function sanitizeBoxSeries(series){
  if(!Array.isArray(series)) return series;
  return series.map(entry=>{
    if(!entry || typeof entry !== 'object') return entry;
    const clone = {...entry};
    clone.y = sanitizeNumericArray(clone.y || []);
    if(Array.isArray(clone.text)){
      clone.text = clone.text.map(sanitizeMinusText);
    } else if(typeof clone.text === 'string'){
      clone.text = sanitizeMinusText(clone.text);
    }
    if('name' in clone) clone.name = sanitizeMinusText(clone.name);
    return clone;
  });
}

function deepSanitizeEnrichment(list){
  if(!Array.isArray(list)) return list;
  list.forEach(item=>{
    if(!item || typeof item !== 'object') return;
    if('score' in item) item.score = sanitizeNumericValue(item.score);
    if('padj' in item) item.padj = sanitizeNumericValue(item.padj);
  });
  return list;
}

function sanitizeGsvaPayload(gsva){
  if(!gsva || typeof gsva !== 'object') return gsva;
  if(gsva.stats && typeof gsva.stats === 'object'){
    Object.values(gsva.stats).forEach(stat=>{
      if(!stat || typeof stat !== 'object') return;
      if('stat' in stat) stat.stat = sanitizeNumericValue(stat.stat);
      if('pval' in stat) stat.pval = sanitizeNumericValue(stat.pval);
      if('pval_adj' in stat) stat.pval_adj = sanitizeNumericValue(stat.pval_adj);
      if('pvalue' in stat) stat.pvalue = sanitizeNumericValue(stat.pvalue);
      if('padj' in stat) stat.padj = sanitizeNumericValue(stat.padj);
      if('t' in stat) stat.t = sanitizeNumericValue(stat.t);
      if('df' in stat) stat.df = sanitizeNumericValue(stat.df);
    });
  }
  if(gsva.ulm && typeof gsva.ulm === 'object'){
    Object.values(gsva.ulm).forEach(ulm=>{
      if(!ulm || typeof ulm !== 'object') return;
      if('score' in ulm) ulm.score = sanitizeNumericValue(ulm.score);
      if('padj' in ulm) ulm.padj = sanitizeNumericValue(ulm.padj);
    });
  }
  if(gsva.fdr && typeof gsva.fdr === 'object'){
    Object.keys(gsva.fdr).forEach(key=>{
      gsva.fdr[key] = sanitizeNumericValue(gsva.fdr[key]);
    });
  }
  if(gsva.boxData && typeof gsva.boxData === 'object'){
    Object.keys(gsva.boxData).forEach(key=>{
      const arr = gsva.boxData[key];
      if(!Array.isArray(arr)) return;
      gsva.boxData[key] = sanitizeBoxSeries(arr);
    });
  }
  return gsva;
}

function sanitizeAllGsva(){
  Object.values(GENESET_TABS).forEach(cfg=>{
    if(cfg.enrich && typeof cfg.enrich === 'object'){
      Object.keys(cfg.enrich).forEach(ct=>{
        cfg.enrich[ct] = deepSanitizeEnrichment(cfg.enrich[ct]);
      });
    }
    if(cfg.gsva && typeof cfg.gsva === 'object'){
      Object.keys(cfg.gsva).forEach(ct=>{
        cfg.gsva[ct] = sanitizeGsvaPayload(cfg.gsva[ct]);
      });
    }
  });
  if(HALLMARK_ENRICH && typeof HALLMARK_ENRICH === 'object'){
    Object.keys(HALLMARK_ENRICH).forEach(ct=>{ HALLMARK_ENRICH[ct] = deepSanitizeEnrichment(HALLMARK_ENRICH[ct]); });
  }
  if(TF_ENRICH && typeof TF_ENRICH === 'object'){
    Object.keys(TF_ENRICH).forEach(ct=>{ TF_ENRICH[ct] = deepSanitizeEnrichment(TF_ENRICH[ct]); });
  }
  if(HALLMARK_GSVA && typeof HALLMARK_GSVA === 'object'){
    Object.keys(HALLMARK_GSVA).forEach(ct=>{ HALLMARK_GSVA[ct] = sanitizeGsvaPayload(HALLMARK_GSVA[ct]); });
  }
  if(TF_GSVA && typeof TF_GSVA === 'object'){
    Object.keys(TF_GSVA).forEach(ct=>{ TF_GSVA[ct] = sanitizeGsvaPayload(TF_GSVA[ct]); });
  }
}

function downloadHallmarkGsvaCSV(){
  const header=['cell_type','gene_set','ulm_score','ulm_padj','stat','pval','pval_adj'];
  const rows=[header];
  Object.keys(HALLMARK_GSVA).forEach(ct=>{
    const gsva = HALLMARK_GSVA[ct] || {};
    const stats = (gsva && gsva.stats) || {};
    const ulmMap = (gsva && gsva.ulm) || {};
    const modules = Array.from(new Set([
      ...Object.keys(stats),
      ...Object.keys(ulmMap)
    ]));
    modules.sort((a,b)=>compareModulesByUlmPadj(a,b, ulmMap));
    modules.forEach(gs=>{
      const ulmEntry = ulmMap[gs] || {};
      const st = stats[gs] || {};
      rows.push([
        ct,
        gs,
        ulmEntry.score ?? '',
        ulmEntry.padj ?? '',
        st.stat ?? '',
        st.pval ?? '',
        st.pval_adj ?? ''
      ]);
    });
  });
  downloadTableCSV('hallmark_gsva_results.csv', rows);
}

function downloadTfGsvaCSV(){
  const header=['cell_type','gene_set','ulm_score','ulm_padj','stat','pval','pval_adj'];
  const rows=[header];
  Object.keys(TF_GSVA).forEach(ct=>{
    const gsva = TF_GSVA[ct] || {};
    const stats = (gsva && gsva.stats) || {};
    const ulmMap = (gsva && gsva.ulm) || {};
    const modules = Array.from(new Set([
      ...Object.keys(stats),
      ...Object.keys(ulmMap)
    ]));
    modules.sort((a,b)=>compareModulesByUlmPadj(a,b, ulmMap));
    modules.forEach(gs=>{
      const ulmEntry = ulmMap[gs] || {};
      const st = stats[gs] || {};
      rows.push([
        ct,
        gs,
        ulmEntry.score ?? '',
        ulmEntry.padj ?? '',
        st.stat ?? '',
        st.pval ?? '',
        st.pval_adj ?? ''
      ]);
    });
  });
  downloadTableCSV('tf_gsva_results.csv', rows);
}


let hallmarkInit=false, tfInit=false, tfNetInit=false, volcanoInit=false, dgeInit=false, biologyInit=false, overviewInit=false;
let activeEnrichmentSource='btm';
const CONTEXT_BUDGET=20;
let currentTab=null,currentSub='';
let umapObsPurged=false;

function purgePlotsIn(sel){
  const el=typeof sel==='string'?document.querySelector(sel):sel;
  if(!el) return 0;
  const plots=el.querySelectorAll('.js-plotly-plot');
  plots.forEach(gd=>Plotly.purge(gd));
  el.innerHTML='';
  return plots.length;
}

function baseGene(name){
  const idx = name.indexOf(' (');
  return idx>=0 ? name.slice(0, idx) : name;
}

function getGeneTensor(gene){
  const cached = EXP_CACHE.get(gene);
  if(cached) return cached;
  const geneIndex = GENE_INDEX[gene];
  if(geneIndex === undefined) return new Float32Array(NCELLS);
  const start = EXP_PTR[geneIndex];
  const end = EXP_PTR[geneIndex + 1];
  const vmin = VMIN[geneIndex];
  const vmax = VMAX[geneIndex];
  const rng = Math.max((vmax - vmin), 1e-6);
  const out = new Float32Array(NCELLS);
  for(let k=start;k<end;k++){
    const cellIndex = EXP_INDICES[k];
    const scaled = EXP_VALUES[k] / 255;
    out[cellIndex] = vmin + scaled * rng;
  }
  EXP_CACHE.set(gene, out);
  if(EXP_CACHE.size > MAX_CACHE){
    const oldest = EXP_CACHE.keys().next().value;
    EXP_CACHE.delete(oldest);
  }
  return out;
}

function getProtExp(name){
  const idx = PROT_INDEX[name];
  if(idx===undefined) return new Float32Array(NCELLS);
  const e = PROT_EXP[name];
  if(!e) return new Float32Array(NCELLS);
  const out = new Float32Array(NCELLS);
  const vmin = PROT_VMIN[idx], vmax = PROT_VMAX[idx], rng = Math.max(vmax - vmin, 1e-6);
  for(let k=0;k<e.i.length;k++){ out[e.i[k]] = vmin + (e.x[k]/255)*rng; }
  return out;
}

function buildPlotlyScale(hexArray){
  const n = hexArray.length - 1;
  return hexArray.map((c,i)=>[i/n, c]);}


/**
 * Draw UMAP with low → mid → high layering so high expr lands on top.
 * container: DOM id or node
 * x, y: Float32Array | number[]
 * expr: number[] (expression for current gene)
 */

function drawScoreUMAP(container, arr, title){
  const scores = Array.from(arr);
  const hover = Array.from(CLUSTER_CODES, i => CLUSTER_NAMES[i]);
  let vmin = Math.min(...scores), vmax = Math.max(...scores);
  if(!isFinite(vmin) || !isFinite(vmax) || vmin === vmax){vmin = 0; vmax = 1;}
  // Paint order: low → high expression so bright cells land on top
  const order = scores.map((v,i)=>i).sort((a,b)=>scores[a]-scores[b]);
  const xs = order.map(i=>UMAP_X[i]);
  const ys = order.map(i=>UMAP_Y[i]);
  const sortedScores = order.map(i=>scores[i]);
  const sortedHover = order.map(i=>hover[i]);
  const trace = {x:xs, y:ys, mode:'markers', type:'scattergl', text:sortedHover,
                 hovertemplate: LEIDEN+': %{text}<extra></extra>',
                 marker:{size:5, color:sortedScores, cmin:vmin, cmax:vmax,
                         colorscale:buildPlotlyScale(CMAP), showscale:true,
                         colorbar:{...COLORBAR}}};
  const layout = {...PLOTLY_THEME.layout, title:{text:title, x:0.5}};
  return Plotly.newPlot(container, [trace], layout, PLOTLY_THEME.config);
}

let CURRENT_GENE_EXPR=null;
let CURRENT_PROT_EXPR=null;
  const SYNC_IDS=new Set();
  let syncingRanges=false;
  function wireSync(id){
    const gd=document.getElementById(id);
    if(!gd||typeof gd.on!=='function'||gd.dataset.wired) return;
    gd.dataset.wired=1;
    SYNC_IDS.add(id);
    gd.on('plotly_relayout',ev=>{
      if(!document.getElementById('linkRanges_'+DOM).checked) return;
      if(syncingRanges||ev['xaxis.range[0]']===undefined) return;
      syncingRanges=true;
      const xr=[ev['xaxis.range[0]'],ev['xaxis.range[1]']], yr=[ev['yaxis.range[0]'],ev['yaxis.range[1]']];
      SYNC_IDS.forEach(o=>{if(o!==id) Plotly.relayout(o,{'xaxis.range':xr,'yaxis.range':yr});});
      syncingRanges=false;
    });
  }
function setUMAPView(view){
  const cl=$('#clustCol_'+DOM), rn=$('#rnaCol_'+DOM), pr=$('#protCol_'+DOM);
  if(view==='RNA'){
    pr.addClass('d-none');
    cl.removeClass('col-lg-4').addClass('col-lg-6');
    rn.removeClass('d-none').removeClass('col-lg-4').addClass('col-lg-6');
  } else if(view==='PROT'){
    rn.addClass('d-none');
    pr.removeClass('d-none').removeClass('col-lg-4').addClass('col-lg-6');
    cl.removeClass('col-lg-4').addClass('col-lg-6');
  } else {
    rn.removeClass('d-none').removeClass('col-lg-6').addClass('col-lg-4');
    pr.removeClass('d-none').removeClass('col-lg-6').addClass('col-lg-4');
    cl.removeClass('col-lg-6').addClass('col-lg-4');
  }
  wireSync('clusterPlot_'+DOM);
  wireSync('genePlot_'+DOM);
  if(view!=='RNA') wireSync('protPlot_'+DOM);
}

let CLUSTER_META=null;
let lastCursor=null;

function clusterMeta(){
  if(CLUSTER_META) return CLUSTER_META;
  const meta=[];
  for(let ci=0;ci<CLUSTERS.length;ci++){
    const {xs,ys}=CLUSTER_PTS[ci];
    const count=xs.length;
    let mx=0,my=0;
    for(let k=0;k<count;k++){mx+=xs[k];my+=ys[k];}
    mx/=Math.max(count,1); my/=Math.max(count,1);
    let best=0,bestD=Infinity,radSum=0;
    for(let k=0;k<count;k++){
      const dx=xs[k]-mx, dy=ys[k]-my; const d=dx*dx+dy*dy; radSum+=d; if(d<bestD){bestD=d;best=k;}
    }
    const radius=Math.sqrt(radSum/Math.max(count,1));
    meta[ci]={xs,ys,count,medoid:{x:xs[best]||0,y:ys[best]||0},radius};
  }
  CLUSTER_META=meta;
  return meta;
}

function convexHull(xs, ys){
  const pts = xs.map((x,i)=>({x, y:ys[i]})).sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  if(pts.length<3) return pts;
  const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower=[];
  for(const p of pts){
    while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop();
    lower.push(p);
  }
  const upper=[];
  for(let i=pts.length-1;i>=0;i--){
    const p=pts[i];
    while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop();
    upper.push(p);
  }
  upper.pop();
  lower.pop();
  return lower.concat(upper);
}

function autoFont(n){
  return Math.max(9, Math.min(14, 14 - 0.08 * Math.max(n - 10, 0)));
}

function computeClusterAnnotations(gd, cursor){
  const xaxis=gd._fullLayout.xaxis;
  const yaxis=gd._fullLayout.yaxis;
  const meta=clusterMeta();
  lastCursor = cursor || lastCursor;
  const order = meta.map((m,ci)=>({ci,count:m.count})).sort((a,b)=>b.count-a.count);
  const ann=[], boxes= lastCursor?[lastCursor]:[], shapes=[];
  const fontSize = autoFont(CLUSTERS.length);
  const margin=6;
  const golden=2.39996322972865332;
  order.forEach(({ci})=>{
    const raw=CLUSTERS[ci];
    const m=meta[ci];
    const p0x=xaxis.l2p(m.medoid.x);
    const p0y=yaxis.l2p(m.medoid.y);
    const dirs=[[1,0],[Math.SQRT1_2,Math.SQRT1_2],[0,1],[-Math.SQRT1_2,Math.SQRT1_2],[-1,0],[-Math.SQRT1_2,-Math.SQRT1_2],[0,-1],[Math.SQRT1_2,-Math.SQRT1_2]];
    const bins=new Array(8).fill(0);
    for(let k=0;k<m.count;k++){
      const dx=m.xs[k]-m.medoid.x;
      const dy=m.ys[k]-m.medoid.y;
      const dist=Math.hypot(dx,dy);
      if(dist<m.radius){
        let ang=Math.atan2(dy,dx);
        let bin=Math.round(((ang+Math.PI)/(2*Math.PI))*8)%8;
        bins[bin]++;
      }
    }
    let dir=dirs[0], min=bins[0];
    for(let b=1;b<8;b++){if(bins[b]<min){min=bins[b];dir=dirs[b];}}
    let px=p0x+dir[0]*12;
    let py=p0y+dir[1]*12;
    const label=raw;
    const pad=3;
    let w=label.length*fontSize*0.6+pad*2;
    let h=fontSize*1.6+pad*2;
    const collide=(x,y)=>boxes.some(b=>!(x+w/2+margin<b.x-b.w/2-margin || x-w/2-margin>b.x+b.w/2+margin || y+h/2+margin<b.y-b.h/2-margin || y-h/2-margin>b.y+b.h/2+margin));
    let step=0;
    while(step<150 && collide(px,py)){
      const r=2*step; const ang=golden*step; px+=Math.cos(ang)*r; py+=Math.sin(ang)*r; step++;
    }
    if(collide(px,py)){
      w=label.length*fontSize*0.6+pad*2;
      h=fontSize*1.6+pad*2;
      step=0;
      while(step<150 && collide(px,py)){
        const r=2*step; const ang=golden*step; px+=Math.cos(ang)*r; py+=Math.sin(ang)*r; step++;
      }
    }
    boxes.push({x:px,y:py,w:w,h:h});
    const dx=xaxis.p2l(px);
    const dy=yaxis.p2l(py);
    const lbl={x:dx,y:dy,text:label,fontSize};
    ann.push(...buildHaloAnnotationsForLabel(lbl,{steps:10,radius:2,shadowColor:'rgba(255,255,255,0.9)'}));
    ann.push(buildMainAnnotation(lbl));
    if(Math.hypot(px-p0x,py-p0y)>8){
      shapes.push({type:'line',x0:m.medoid.x,y0:m.medoid.y,x1:dx,y1:dy,line:{color:'rgba(0,0,0,0.3)',width:1}});
    }
  });
  return {annotations:ann, shapes};
}

function buildHaloAnnotationsForLabel(lbl, opts){
  const {steps=8, radius=1.5, shadowColor='rgba(255,255,255,0.9)'} = opts || {};
  const halos=[];
  for(let k=0;k<steps;k++){
    const ang=(2*Math.PI*k)/steps;
    halos.push({
      x:lbl.x,y:lbl.y,xref:'x',yref:'y',
      text:lbl.text,showarrow:false,
      xshift:Math.round(Math.cos(ang)*radius),
      yshift:Math.round(Math.sin(ang)*radius),
      font:{size:lbl.fontSize,color:shadowColor,family:'Inter, system-ui, sans-serif'},
      align:'center'
    });
  }
  return halos;
}

function buildMainAnnotation(lbl){
  return {
    x:lbl.x,y:lbl.y,xref:'x',yref:'y',
    text:lbl.text,showarrow:false,
    font:{size:lbl.fontSize,color:'#000',family:'Inter, system-ui, sans-serif'},
    align:'center'
  };
}

function highlightCluster(gd, clusterName){
  const n=gd.data.length;
  const opacities=new Array(n).fill(0.15);
  const targets=[];
  for(let i=0;i<n;i++){
    const nm=gd.data[i].name;
    if(nm===clusterName) opacities[i]=1.0;
    targets.push(i);
  }
  Plotly.restyle(gd,{opacity:opacities},targets);
  const anns=gd.layout.annotations||[];
  const newAnns=anns.map(a=>{
    const plain=typeof a.text==='string'?a.text.replace(/<[^>]*>/g,'').replaceAll('\u00A0',' '):'';
    const base=plain.split(' (n=')[0];
    if(base===clusterName && a.font?.color?.startsWith('rgba(255,255,255')){
      return {...a,font:{...a.font,color:'rgba(255,255,255,1)'}};
    }
    if(base===clusterName){
      return {...a,font:{...a.font,color:'#000'}};
    }
    return a;
  });
  Plotly.relayout(gd,{annotations:newAnns});
}

function clearHighlight(gd){
  const n=gd.data.length;
  Plotly.restyle(gd,{opacity:1},[...Array(n).keys()]);
  const anns=gd.layout.annotations||[];
  const restored=anns.map(a=>{
    if(a.font?.color?.startsWith('rgba(255,255,255')){
      return {...a,font:{...a.font,color:'rgba(255,255,255,0.9)'}};
    }
    return a;
  });
  Plotly.relayout(gd,{annotations:restored});
}

function bindLegendHighlight(gd){
  const enter=ev=>{
    const clusterName=gd.data[ev.curveNumber].name;
    highlightCluster(gd,clusterName);
  };
  const leave=()=>{clearHighlight(gd);};
  gd.on('plotly_legendhover',enter);
  gd.on('plotly_legendunhover',leave);
  gd.on('plotly_legendmouseenter',enter);
  gd.on('plotly_legendmouseleave',leave);
  gd.on('plotly_legendclick',ev=>{
    enter(ev);
    const clusterName=gd.data[ev.curveNumber].name;
    if(clusterName) focusBiologySection(clusterName);
    return false;
  });
  gd.on('plotly_legenddoubleclick',ev=>{leave(); return false;});
  document.addEventListener('click',e=>{
    const legendEl=gd.querySelector('.legend');
    if(legendEl && !legendEl.contains(e.target)) leave();
  });
}

function drawUMAP(){
  const container = "clusterPlot_"+DOM;
  const BIG = 250000;
  const MED = 100000;
  const layout = {
    ...PLOTLY_THEME.layout,
    title:{text:'UMAP', x:0.5},
    showlegend:true,
    margin:{l:20,r:160,t:40,b:30},
    legend:{x:1.02,y:1,xanchor:'left',yanchor:'top',orientation:'v',bgcolor:'rgba(255,255,255,0)',borderwidth:0,itemclick:false,itemdoubleclick:false},
    dragmode:false,
    hovermode:'closest'
  };
  const config = {
    staticPlot:false,
    displaylogo:false,
    responsive:true,
    scrollZoom:false,
    doubleClick:false,
    toImageButtonOptions:{format:'svg'}
  };
  CLUSTER_META=null; lastCursor=null;
  if(NCELLS > BIG){
    let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
    for(let i=0;i<NCELLS;i++){
      const x=UMAP_X[i], y=UMAP_Y[i];
      if(x<xmin)xmin=x; if(x>xmax)xmax=x;
      if(y<ymin)ymin=y; if(y>ymax)ymax=y;
    }
    const canvas=document.createElement('canvas');
    canvas.width=800; canvas.height=800;
    const ctx=canvas.getContext('2d');
    ctx.globalAlpha=L_LEFT_POINT_OPACITY;
    const sx=(x)=>((x-xmin)/(xmax-xmin))*canvas.width;
    const sy=(y)=>canvas.height-((y-ymin)/(ymax-ymin))*canvas.height;
    for(let ci=0;ci<CLUSTERS.length;ci++){
      ctx.fillStyle=CLUSTER_COLORS[CLUSTERS[ci]];
      const {xs,ys}=CLUSTER_PTS[ci];
      for(let k=0;k<xs.length;k++){
        ctx.beginPath();
        ctx.arc(sx(xs[k]), sy(ys[k]), L_LEFT_POINT_SIZE/2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    const url=canvas.toDataURL();
    layout.images=[{source:url,xref:'x',yref:'y',x:xmin,y:ymax,sizex:xmax-xmin,sizey:ymax-ymin,sizing:'stretch',layer:'below'}];
    const dummyTraces=CLUSTERS.map(c=>({x:[null],y:[null],type:'scatter',mode:'markers',name:c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:0,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'none'}));
    Plotly.newPlot(container, dummyTraces, layout, config).then(gd=>{
      const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
      refresh();
      bindLegendHighlight(gd);
      wireSync(container);
      gd.on('plotly_click',ev=>{
        if(!ev||!ev.points||!ev.points.length) return;
        const pt=ev.points[0];
        const candidates=[];
        if(pt.data){
          if(pt.data.name) candidates.push(pt.data.name);
          const meta=pt.data.meta||{};
          ['cluster_key','cluster','canonical_label','fine_label','celltype','cell_type'].forEach(k=>{ if(meta[k]) candidates.push(meta[k]); });
        }
        if(pt.text) candidates.push(pt.text);
        candidates.some(candidate=>candidate && focusBiologySection(candidate));
      });
    });
    return;
  }
  let traces;
  if(NCELLS > MED){
    const maxPts=50000;
    const perCl=Math.max(1,Math.floor(maxPts/CLUSTERS.length));
    traces=CLUSTERS.map((c,ci)=>{
      const pts=CLUSTER_PTS[ci];
      const xs=pts.xs.slice(0,perCl);
      const ys=pts.ys.slice(0,perCl);
      return {type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'none'};
    });
  } else {
    traces=CLUSTERS.map((c,ci)=>{
      const {xs,ys}=CLUSTER_PTS[ci];
      return {type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'none'};
    });
  }
  Plotly.newPlot(container, traces, layout, config).then(gd=>{
    const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
    refresh();
    bindLegendHighlight(gd);
    wireSync(container);
    gd.on('plotly_click',ev=>{
      if(!ev||!ev.points||!ev.points.length) return;
      const pt=ev.points[0];
      const candidates=[];
      if(pt.data){
        if(pt.data.name) candidates.push(pt.data.name);
        const meta=pt.data.meta||{};
        ['cluster_key','cluster','canonical_label','fine_label','celltype','cell_type'].forEach(k=>{ if(meta[k]) candidates.push(meta[k]); });
      }
      if(pt.text) candidates.push(pt.text);
      candidates.some(candidate=>candidate && focusBiologySection(candidate));
    });
  });
}

function drawBiologyUMAP(){
  const container = 'aiInsightsUMAP_'+DOM;
  const BIG = 250000;
  const MED = 100000;
  const layout = {
    ...PLOTLY_THEME.layout,
    title:{text:'UMAP', x:0.5},
    showlegend:true,
    margin:{l:20,r:160,t:40,b:30},
    legend:{x:1.02,y:1,xanchor:'left',yanchor:'top',orientation:'v',bgcolor:'rgba(255,255,255,0)',borderwidth:0,itemclick:false,itemdoubleclick:false},
    dragmode:false,
    hovermode:'closest'
  };
  const config = {
    staticPlot:false,
    displaylogo:false,
    responsive:true,
    scrollZoom:false,
    doubleClick:false,
    toImageButtonOptions:{format:'svg'}
  };
  if(NCELLS > BIG){
    let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
    for(let i=0;i<NCELLS;i++){
      const x=UMAP_X[i], y=UMAP_Y[i];
      if(x<xmin)xmin=x; if(x>xmax)xmax=x;
      if(y<ymin)ymin=y; if(y>ymax)ymax=y;
    }
    const canvas=document.createElement('canvas');
    canvas.width=800; canvas.height=800;
    const ctx=canvas.getContext('2d');
    ctx.globalAlpha=L_LEFT_POINT_OPACITY;
    const sx=(x)=>((x-xmin)/(xmax-xmin))*canvas.width;
    const sy=(y)=>canvas.height-((y-ymin)/(ymax-ymin))*canvas.height;
    for(let ci=0;ci<CLUSTERS.length;ci++){
      ctx.fillStyle=CLUSTER_COLORS[CLUSTERS[ci]];
      const {xs,ys}=CLUSTER_PTS[ci];
      for(let k=0;k<xs.length;k++){
        ctx.beginPath();
        ctx.arc(sx(xs[k]), sy(ys[k]), L_LEFT_POINT_SIZE/2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    const url=canvas.toDataURL();
    layout.images=[{source:url,xref:'x',yref:'y',x:xmin,y:ymax,sizex:xmax-xmin,sizey:ymax-ymin,sizing:'stretch',layer:'below'}];
    const dummyTraces=CLUSTERS.map(c=>({x:[null],y:[null],type:'scatter',mode:'markers',name:c,legendgroup:c,marker:{size:L_LEFT_POINT_SIZE,opacity:0,color:CLUSTER_COLORS[c],line:{width:0}},hoverinfo:'none'}));
    Plotly.newPlot(container, dummyTraces, layout, config).then(gd=>{
      const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
      refresh();
      bindLegendHighlight(gd);
      wireSync(container);
      gd.on('plotly_click',ev=>{
        if(!ev||!ev.points||!ev.points.length) return;
        const pt=ev.points[0];
        const candidates=[];
        if(pt.data){
          if(pt.data.name) candidates.push(pt.data.name);
          const meta=pt.data.meta||{};
          ['cluster_key','cluster','canonical_label','fine_label','celltype','cell_type'].forEach(k=>{ if(meta[k]) candidates.push(meta[k]); });
        }
        if(pt.text) candidates.push(pt.text);
        candidates.some(candidate=>candidate && focusBiologySection(candidate));
      });
    });
    return;
  }
  let traces;
  if(NCELLS > MED){
    const maxPts=50000;
    const perCl=Math.max(1,Math.floor(maxPts/CLUSTERS.length));
    traces=CLUSTERS.map((c,ci)=>{
      const pts=CLUSTER_PTS[ci];
      const xs=pts.xs.slice(0,perCl);
      const ys=pts.ys.slice(0,perCl);
      const info = BIOLOGY_INFO[c] || {};
      return {
        type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,
        marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},
        meta:{
          canonical_label: info.canonical_label || 'N/A',
          fine_label: info.fine_label || 'N/A',
          confidence: info.confidence || 'N/A',
          key_markers: (info.key_markers||[]).join(', ')
        },
        hoverinfo:'none'
      };
    });
  } else {
    traces=CLUSTERS.map((c,ci)=>{
      const {xs,ys}=CLUSTER_PTS[ci];
      const info = BIOLOGY_INFO[c] || {};
      return {
        type:'scattergl',mode:'markers',x:xs,y:ys,name:""+c,legendgroup:c,
        marker:{size:L_LEFT_POINT_SIZE,opacity:L_LEFT_POINT_OPACITY,color:CLUSTER_COLORS[c],line:{width:0}},
        meta:{
          canonical_label: info.canonical_label || 'N/A',
          fine_label: info.fine_label || 'N/A',
          confidence: info.confidence || 'N/A',
          key_markers: (info.key_markers||[]).join(', ')
        },
        hoverinfo:'none'
      };
    });
  }
  Plotly.newPlot(container, traces, layout, config).then(gd=>{
    const refresh=(cursor)=>{const res=computeClusterAnnotations(gd,cursor);Plotly.relayout(gd,{annotations:res.annotations, shapes:res.shapes});};
    refresh();
    bindLegendHighlight(gd);
    wireSync(container);
    gd.on('plotly_click',ev=>{
      if(!ev||!ev.points||!ev.points.length) return;
      const pt=ev.points[0];
      const candidates=[];
      if(pt.data){
        if(pt.data.name) candidates.push(pt.data.name);
        const meta=pt.data.meta||{};
        ['cluster_key','cluster','canonical_label','fine_label','celltype','cell_type'].forEach(k=>{ if(meta[k]) candidates.push(meta[k]); });
      }
      if(pt.text) candidates.push(pt.text);
      candidates.some(candidate=>candidate && focusBiologySection(candidate));
    });
  });
}
function populateGenes(){
  const dl=document.getElementById("geneList_"+DOM);
  GENES.forEach(g=>{
    const o=document.createElement("option");
    o.value=g;
    dl.appendChild(o);
  });
}
function populateProteins(){
  const dl=document.getElementById("protList_"+DOM);
  PROT_GENES.forEach(p=>{ const o=document.createElement("option"); o.value=p; dl.appendChild(o); });
}
async function drawGeneTo(id,g){
  const sym = baseGene(g);
  await loadExp();
  const expr = getGeneTensor(sym);
  CURRENT_GENE_EXPR = expr;
  await drawScoreUMAP(id, expr, 'Gene expression: '+g);
  wireSync(id);
  wireSync('clusterPlot_'+DOM);
}
function drawGene(g){
  return drawGeneTo("genePlot_"+DOM,g);
}
function drawProteinTo(id,p){
  const arr = getProtExp(p);
  CURRENT_PROT_EXPR = arr;
  drawScoreUMAP(id, arr, "Protein expression: "+p).then(()=>{
    wireSync(id);
    wireSync('clusterPlot_'+DOM);
  });
}
  function drawProtein(p){
    drawProteinTo("genePlot_"+DOM,p);
  }

function setRandomUmapObsFeature(modality){
  const arr = modality==='Protein' ? PROT_GENES : GENES;
  const feat = arr.length ? arr[Math.floor(Math.random()*arr.length)] : '';
  $('#umapObsFeat_'+DOM).val(feat);
  umapObsGeneConfirmed = false;
}

  function populateObsGroupBy(){
    const sel = $("#obsGroupSel_"+DOM);
    sel.empty();
    OBS_CATS.forEach(c=>sel.append(`<option value="${c}">${c}</option>`));
    let preferred = OBS_CATS.find(c=>/group/i.test(c));
    if(!preferred) preferred = OBS_CATS.find(c=>/sample/i.test(c));
    if(!preferred && OBS_CATS.length) preferred = OBS_CATS[0];
    if(preferred) sel.val(preferred);
  }

  async function drawUmapObs(){
    umapObsPurged=false;
    const groupby = $("#obsGroupSel_"+DOM).val();
    if(!groupby) return;
    const groupIdx = OBS_COL_MATRIX[groupby];
    const levels = OBS_LEVELS[groupby] || [];
    const colorsMap = OBS_COLORS[groupby] || {};
    const modality = HAS_PROT ? $("#umapObsMod_"+DOM).val() : 'RNA';
    let feature = $("#umapObsFeat_"+DOM).val().trim();
    if(modality==='RNA') feature = baseGene(feature);
    let expr=null, vmin=0, vmax=1, idx;
    if(feature){
      if(modality==='RNA'){
        idx = GENE_INDEX[feature];
        if(idx!==undefined){
          await loadExp();
          expr = getGeneTensor(feature);
          vmin = VMIN[idx];
          vmax = VMAX[idx];
        }
      } else {
        idx = PROT_INDEX[feature];
        if(idx!==undefined){ expr = getProtExp(feature); vmin = PROT_VMIN[idx]; vmax = PROT_VMAX[idx]; }
      }
    }
    const colorByExpr = umapObsGeneConfirmed && expr && idx!==undefined;
    const scale = buildPlotlyScale(CMAP);
    $('#umapObsTitle_'+DOM).text(colorByExpr ? feature : '');
    const view = $('input[name="umapObsView_'+DOM+'"]:checked').val() || 'umap';
      if(view==='violin'){
      $('#umapObsGrid_'+DOM).hide();
      $('#umapObsViolin_'+DOM).show();
        if(!colorByExpr){ Plotly.purge('umapObsViolin_'+DOM); return; }
          const scores = Array.from(expr, v => v + PSEUDOCOUNT);
          const traces = levels.map((level,i)=>{
            const yvals = scores.filter((_,j)=>groupIdx && groupIdx[j]===i);
            const n = yvals.length;
            const fallbackColor = fallbackOrdinalColor(i, levels.length || 1, COLOR_MODE);
            return {
              type:'violin',
              y:yvals,
              name:`${level} (n=${n})`,
              points:'all',
              jitter:0.3,
              pointpos:0,
              marker:{
                color:(colorsMap[level] && colorsMap[level].trim()) ? colorsMap[level] : fallbackColor,
                size:2,
                opacity:0.3
              },
              hovertemplate:`${groupby}: ${level}<br>n: ${n}<extra></extra>`,
              box:{visible:false}
            };
          });
        const vioLayout = createViolinLayout('Distribution of '+feature+' across '+groupby, levels);
        vioLayout.yaxis = {...vioLayout.yaxis, title:'Expression', type:'linear'};
        Plotly.newPlot('umapObsViolin_'+DOM,traces,vioLayout,PLOTLY_THEME.config)
          .then(gd=>requestAnimationFrame(()=>Plotly.Plots.resize(gd)));
        return;
    }
    $('#umapObsViolin_'+DOM).hide();
    const grid = $("#umapObsGrid_"+DOM).empty().show();
    const [rows, cols] = (function(n){
      if(n<=1) return [1,1];
      if(n===2) return [1,2];
      if(n===3) return [1,3];
      if(n===4) return [2,2];
      if(n<=6) return [2,3];
      if(n<=9) return [3,3];
      if(n<=12) return [3,4];
      if(n<=16) return [4,4];
      const c = Math.ceil(Math.sqrt(n));
      const r = Math.ceil(n/c);
      return [r,c];
    })(levels.length);
    grid.css({
      'grid-template-columns': `repeat(${cols}, 1fr)`,
      'grid-template-rows': `repeat(${rows}, 1fr)`
    });
    const showBackground = $('#obsShowBackground_'+DOM).prop('checked');
    for(let i=0;i<levels.length;i++){
      const level = levels[i];
      const div = document.createElement('div');
      div.id = `umapObsFacet_${DOM}_${i}`;
      const plotDiv = document.createElement('div');
      plotDiv.style.width = '100%';
      plotDiv.style.height = '100%';
      div.appendChild(plotDiv);
      grid.append(div);
      let xs=[], ys=[], h=[], vals=[];
      for(let j=0;j<NCELLS;j++){
        if(groupIdx && groupIdx[j]===i){
          xs.push(UMAP_X[j]);
          ys.push(UMAP_Y[j]);
          if(colorByExpr){
            vals.push(expr[j]);
            h.push(`${CELLS[j]}<br>${feature}:${expr[j].toFixed(2)}`);
          } else {
            h.push(CELLS[j]);
          }
        }
      }
      if(colorByExpr){
        const order = vals.map((v,k)=>k).sort((a,b)=>vals[a]-vals[b]);
        xs = order.map(k=>xs[k]);
        ys = order.map(k=>ys[k]);
        vals = order.map(k=>vals[k]);
        h = order.map(k=>h[k]);
      }
      const traces=[];
      if(showBackground){
        traces.push({x:UMAP_X,y:UMAP_Y,mode:'markers',type:'scattergl',marker:{color:'rgba(200,200,200,0.35)',size:3},hoverinfo:'skip'});
      }
      const fallbackColor = fallbackOrdinalColor(i, levels.length || 1, COLOR_MODE);
      const marker = colorByExpr
        ? {size:5,color:vals,cmin:vmin,cmax:vmax,colorscale:scale,showscale:true,
           colorbar:{...COLORBAR,orientation:'v',x:1.05,xanchor:'left',y:0.5,yanchor:'middle',title:feature}}
        : {size:5,color:(colorsMap[level] && colorsMap[level].trim()) ? colorsMap[level] : fallbackColor};
      traces.push({x:xs,y:ys,text:h,hovertemplate:'%{text}<extra></extra>',mode:'markers',type:'scattergl',marker});
      const layout={
        ...PLOTLY_THEME.layout,
        title:{text:level,x:0.5},
        xaxis:{visible:false,range:UMAP_XRANGE},
        yaxis:{visible:false,range:UMAP_YRANGE,scaleanchor:'x'},
        margin:{l:20,r:50,t:30,b:20}
      };
      Plotly.newPlot(plotDiv,traces,layout,PLOTLY_THEME.config)
        .then(gd=>requestAnimationFrame(()=>Plotly.Plots.resize(gd)));
    }
  }

function createViolinLayout(title, groups=CLUSTERS){
  const maxLabelLen = Math.max(0, ...groups.map(c=>c.length));
  const n = groups.length;
  const angle = (n>15 || maxLabelLen>10) ? -45 : 0;
  const fontSize = n>20 ? 8 : 10;
  const bottom = Math.max(80, fontSize*4 + maxLabelLen*7);
  return {
    ...PLOTLY_THEME.layout,
    title:{text:title, x:0.5},
    font:{family:'Helvetica', size:14},
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    yaxis:{
      title:'Score',
      showline:true,
      mirror:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000'
    },
    xaxis:{
      automargin:true,
      tickangle:angle,
      tickfont:{size:fontSize},
      showline:true,
      mirror:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000'
    },
    margin:{l:60,r:20,t:50,b:bottom},
    showlegend:false
  };
}
function populateGeneSetCelltypes(key){
  const cfg = GENESET_TABS[key];
  if(!cfg) return;
  const select = $(`#${key}CelltypeSel_${DOM}`);
  if(!select.length) return;
  select.empty();
  Object.keys(cfg.enrich || {}).forEach(ct=>select.append(`<option value="${ct}">${ct}</option>`));
  drawGeneSet(key);
}

const GENESET_PADJ_FIELDS = ['padj','pval_adj','pvalue_adj','adj_p','adj_pvalue','qval','q_value','fdr','padjust','padj_bh','p_adj'];
const GENESET_SCORE_FIELDS = ['score','activity','stat','t','nes','NES','estimate','effect','fc','logfc','logFC'];

function normalizeGeneSetKey(value){
  if(value === null || value === undefined) return null;
  return String(value).trim().toLowerCase().replace(/[^a-z0-9]+/g,'');
}

function getGeneSetPadj(entry){
  if(!entry || typeof entry !== 'object') return Number.POSITIVE_INFINITY;
  const raw = entry.padj;
  if(typeof raw === 'number' && Number.isFinite(raw) && raw >= 0){
    return raw;
  }
  return Number.POSITIVE_INFINITY;
}

function getGeneSetScore(entry){
  if(!entry || typeof entry !== 'object') return Number.NEGATIVE_INFINITY;
  const raw = entry.score;
  if(typeof raw === 'number' && Number.isFinite(raw)){
    return Math.abs(raw);
  }
  return Number.NEGATIVE_INFINITY;
}

function geneSetEntryComparator(a, b){
  const padjA = getGeneSetPadj(a);
  const padjB = getGeneSetPadj(b);
  if(padjA !== padjB){
    return padjA - padjB;
  }
  const scoreA = getGeneSetScore(a);
  const scoreB = getGeneSetScore(b);
  if(scoreA !== scoreB){
    return scoreB - scoreA;
  }
  const labelA = (a && a.label) ? String(a.label) : '';
  const labelB = (b && b.label) ? String(b.label) : '';
  return labelA.localeCompare(labelB, undefined, {sensitivity:'base'});
}

function compareModulesByUlmPadj(moduleA, moduleB, ulmMap){
  const ulmA = ulmMap && moduleA in ulmMap ? ulmMap[moduleA] : null;
  const ulmB = ulmMap && moduleB in ulmMap ? ulmMap[moduleB] : null;
  const entryA = ulmA ? {...ulmA, label: moduleA} : {label: moduleA};
  const entryB = ulmB ? {...ulmB, label: moduleB} : {label: moduleB};
  return geneSetEntryComparator(entryA, entryB);
}

function pickGeneSetLabel(entry, fallback){
  const candidates = [
    entry && entry.module,
    entry && entry.term,
    entry && entry.pathway,
    entry && entry.program,
    entry && entry.name,
    entry && entry.title,
    entry && entry.label,
    entry && entry.id,
    fallback
  ];
  for(const candidate of candidates){
    if(typeof candidate === 'string' && candidate.trim()){
      return candidate.trim();
    }
  }
  if(typeof fallback === 'number' && Number.isFinite(fallback)){
    return String(fallback);
  }
  return null;
}

function pickFirstFiniteNumber(sources, fields){
  for(const source of sources){
    if(!source || typeof source !== 'object') continue;
    for(const field of fields){
      if(!(field in source)) continue;
      const value = sanitizeNumericValue(source[field]);
      if(typeof value === 'number' && Number.isFinite(value)){
        return value;
      }
    }
  }
  return null;
}

function buildGeneSetDisplayEntry(moduleKey, ulmEntry, enrichEntry, statEntry){
  const label = pickGeneSetLabel(enrichEntry || statEntry || {}, moduleKey);
  if(!label) return null;
  const key = moduleKey || label;
  const normalizedKey = normalizeGeneSetKey(key);
  const normalizedLabel = normalizeGeneSetKey(label);
  const rawScore = pickFirstFiniteNumber([ulmEntry, enrichEntry, statEntry], GENESET_SCORE_FIELDS);
  const score = sanitizeNumericValue(rawScore);
  const rawPadj = pickFirstFiniteNumber([ulmEntry, enrichEntry, statEntry], GENESET_PADJ_FIELDS);
  const padj = sanitizeNumericValue(rawPadj);
  const ulmPadj = sanitizeNumericValue(pickFirstFiniteNumber([ulmEntry], GENESET_PADJ_FIELDS));
  const ulmScore = sanitizeNumericValue(pickFirstFiniteNumber([ulmEntry], GENESET_SCORE_FIELDS));
  const gsvaPadj = sanitizeNumericValue(pickFirstFiniteNumber([statEntry], GENESET_PADJ_FIELDS));
  const gsvaStat = sanitizeNumericValue(pickFirstFiniteNumber([statEntry], ['stat','score','NES','nes','t','estimate']));
  const enrichPadj = sanitizeNumericValue(pickFirstFiniteNumber([enrichEntry], GENESET_PADJ_FIELDS));
  const preferredPadj = (typeof padj === 'number' && Number.isFinite(padj) && padj >= 0)
    ? padj
    : (typeof ulmPadj === 'number' && Number.isFinite(ulmPadj) && ulmPadj >= 0 ? ulmPadj
      : (typeof gsvaPadj === 'number' && Number.isFinite(gsvaPadj) && gsvaPadj >= 0 ? gsvaPadj
        : (typeof enrichPadj === 'number' && Number.isFinite(enrichPadj) && enrichPadj >= 0 ? enrichPadj : null)));
  return {
    key,
    normalizedKey,
    normalizedLabel,
    label,
    score: (typeof score === 'number' && Number.isFinite(score)) ? score : null,
    padj: preferredPadj,
    source: ulmEntry ? 'ulm' : (enrichEntry ? 'enrich' : 'stats'),
    ulmEntry: ulmEntry || null,
    enrichEntry: enrichEntry || null,
    statEntry: statEntry || null,
    ulmPadj: (typeof ulmPadj === 'number' && Number.isFinite(ulmPadj) && ulmPadj >= 0) ? ulmPadj : null,
    gsvaPadj: (typeof gsvaPadj === 'number' && Number.isFinite(gsvaPadj) && gsvaPadj >= 0) ? gsvaPadj : null,
    enrichPadj: (typeof enrichPadj === 'number' && Number.isFinite(enrichPadj) && enrichPadj >= 0) ? enrichPadj : null,
    ulmScore: (typeof ulmScore === 'number' && Number.isFinite(ulmScore)) ? ulmScore : null,
    gsvaStat: (typeof gsvaStat === 'number' && Number.isFinite(gsvaStat)) ? gsvaStat : null
  };
}

function mergeGeneSetEntries(target, source){
  if(!target || !source) return;
  ['enrichEntry','statEntry','ulmEntry'].forEach(field=>{
    if(!target[field] && source[field]) target[field] = source[field];
  });
  ['ulmPadj','gsvaPadj','enrichPadj','ulmScore','gsvaStat'].forEach(field=>{
    if((target[field] === null || target[field] === undefined) && (source[field] !== null && source[field] !== undefined)){
      target[field] = source[field];
    }
  });
  if((target.score === null || target.score === undefined) && (source.score !== null && source.score !== undefined)){
    target.score = source.score;
  }
  if((target.padj === null || target.padj === undefined) && (source.padj !== null && source.padj !== undefined)){
    target.padj = source.padj;
  }
}

function collectGeneSetDisplayEntries(enrichList, statsMap, ulmMap, top){
  const stats = statsMap && typeof statsMap === 'object' ? statsMap : {};
  const ulm = ulmMap && typeof ulmMap === 'object' ? ulmMap : {};
  const ordered = [];
  const keyIndex = new Map();

  const register = (moduleKey, ulmEntry, enrichEntry, statEntry)=>{
    const displayEntry = buildGeneSetDisplayEntry(moduleKey, ulmEntry, enrichEntry, statEntry);
    if(!displayEntry) return;
    const candidates = [
      displayEntry.normalizedKey,
      displayEntry.normalizedLabel,
      normalizeGeneSetKey(moduleKey),
      normalizeGeneSetKey(displayEntry.key),
      normalizeGeneSetKey(displayEntry.label)
    ].filter(Boolean);
    let existingIndex = -1;
    for(const candidate of candidates){
      if(candidate && keyIndex.has(candidate)){
        existingIndex = keyIndex.get(candidate);
        break;
      }
    }
    if(existingIndex >= 0){
      const existing = ordered[existingIndex];
      mergeGeneSetEntries(existing, displayEntry);
      candidates.forEach(candidate=>{
        if(candidate && !keyIndex.has(candidate)){
          keyIndex.set(candidate, existingIndex);
        }
      });
      return;
    }
    const idx = ordered.push(displayEntry) - 1;
    candidates.forEach(candidate=>{
      if(candidate && !keyIndex.has(candidate)){
        keyIndex.set(candidate, idx);
      }
    });
  };

  (Array.isArray(enrichList) ? enrichList : []).forEach(entry=>{
    const moduleKey = (entry && typeof entry.module === 'string' && entry.module.trim())
      ? entry.module.trim()
      : pickGeneSetLabel(entry, entry && entry.module);
    const statEntry = moduleKey && stats[moduleKey] ? stats[moduleKey] : null;
    const ulmEntry = moduleKey && ulm[moduleKey] ? ulm[moduleKey] : null;
    register(moduleKey, ulmEntry, entry, statEntry);
  });

  Object.keys(stats).forEach(statKey=>{
    register(statKey, ulm[statKey], null, stats[statKey]);
  });

  Object.keys(ulm).forEach(ulmKey=>{
    register(ulmKey, ulm[ulmKey], null, stats[ulmKey]);
  });

  const sorted = ordered.sort(geneSetEntryComparator);
  if(Number.isFinite(top) && top > 0){
    const limit = Math.max(sorted.length, Math.max(1, Math.floor(top)));
    return sorted.slice(0, limit);
  }
  return sorted;
}

function prepareGeneSetPlot(entries, top, mode){
  if(!Array.isArray(entries) || !entries.length) return null;
  const normalizedMode = mode === 'gsva' ? 'gsva' : 'gsea';
  const padjField = normalizedMode === 'gsva' ? 'gsvaPadj' : 'ulmPadj';
  const xField = normalizedMode === 'gsva' ? 'gsvaStat' : 'ulmScore';
  const decorated = entries.map(entry=>{
    if(!entry || typeof entry !== 'object') return null;
    const padjRaw = sanitizeNumericValue(entry[padjField]);
    const padj = typeof padjRaw === 'number' && Number.isFinite(padjRaw) && padjRaw >= 0 ? padjRaw : null;
    if(padj === null) return null;
    const xRaw = sanitizeNumericValue(entry[xField]);
    const xValue = typeof xRaw === 'number' && Number.isFinite(xRaw) ? xRaw : null;
    return {entry, padj, xValue};
  }).filter(Boolean);
  if(!decorated.length) return null;
  decorated.sort((a,b)=>{
    if(a.padj !== b.padj) return a.padj - b.padj;
    const aStat = a.xValue !== null ? Math.abs(a.xValue) : -Infinity;
    const bStat = b.xValue !== null ? Math.abs(b.xValue) : -Infinity;
    if(aStat !== bStat) return bStat - aStat;
    const labelA = String(a.entry?.label ?? a.entry?.key ?? '');
    const labelB = String(b.entry?.label ?? b.entry?.key ?? '');
    return labelA.localeCompare(labelB, undefined, {sensitivity:'base'});
  });
  const limit = Number.isFinite(top) && top > 0 ? Math.min(decorated.length, Math.max(1, Math.floor(top))) : decorated.length;
  const selected = decorated.slice(0, limit);
  const modules = selected.map(item=>{
    const label = item.entry?.label ?? item.entry?.key ?? '';
    return typeof label === 'string' ? label : String(label);
  });
  const moduleKeys = selected.map(item=>item.entry?.key ?? item.entry?.label ?? '');
  const padjValues = selected.map(item=>item.padj);
  const padjDisplay = padjValues.map(p=> (typeof p === 'number' && Number.isFinite(p)) ? p.toExponential(2) : 'n/a');
  const colorValues = padjValues.map(p=>-Math.log10(Math.max(p, 1e-300)));
  const colorDisplay = colorValues.map(v=>Number.isFinite(v) ? v.toFixed(2) : 'n/a');
  const xValues = selected.map(item=> item.xValue === null ? 0 : item.xValue);
  const xDisplay = selected.map(item=> item.xValue === null ? 'n/a' : item.xValue.toFixed(2));
  const xLabel = normalizedMode === 'gsva' ? 'GSVA stat' : 'ULM score';
  const colorbarTitle = normalizedMode === 'gsva' ? '-log10(GSVA adj p)' : '-log10(ULM padj)';
  const titleSuffix = normalizedMode === 'gsva' ? 'GSVA' : 'GSEA';
  return {
    mode: normalizedMode,
    modules,
    moduleKeys,
    padjValues,
    padjDisplay,
    colorValues,
    colorDisplay,
    xValues,
    xDisplay,
    xLabel,
    colorbarTitle,
    titleSuffix
  };
}

function drawGeneSet(key){
  const cfg = GENESET_TABS[key];
  if(!cfg) return;
  const ct = $(`#${key}CelltypeSel_${DOM}`).val();
  const vis = $(`#${key}VisSel_${DOM}`).val();
  const top = parseInt($(`#${key}TopSel_${DOM}`).val(), 10) || 25;
  const statModeRaw = $(`#${key}StatSel_${DOM}`).val();
  const statMode = typeof statModeRaw === 'string' ? statModeRaw.toLowerCase() : 'gsea';
  const normalizedMode = statMode === 'gsva' ? 'gsva' : 'gsea';
  const plotId = `${key}Plot_${DOM}`;
  const gsvaPayload = (cfg.gsva && cfg.gsva[ct]) || {};
  const statsMap = (gsvaPayload && gsvaPayload.stats) || {};
  const ulmMap = (gsvaPayload && gsvaPayload.ulm) || {};
  const entries = collectGeneSetDisplayEntries((cfg.enrich && cfg.enrich[ct]) || [], statsMap, ulmMap, top * 3);
  if(!entries.length){
    Plotly.purge(plotId);
    updateGeneSetGsvaList(key);
    return;
  }
  const prepared = prepareGeneSetPlot(entries, top, normalizedMode);
  if(!prepared){
    Plotly.purge(plotId);
    updateGeneSetGsvaList(key);
    return;
  }
  const {modules, moduleKeys, padjValues, padjDisplay, colorValues, colorDisplay, xValues, xDisplay, xLabel, colorbarTitle, titleSuffix} = prepared;
  if(!modules.length){
    Plotly.purge(plotId);
    updateGeneSetGsvaList(key);
    return;
  }
  const sigMask = padjValues.map(p=>typeof p === 'number' && p < 0.05);
  const outlines = sigMask.map(s=>s?'black':'rgba(0,0,0,0)');
  const widths = sigMask.map(s=>s?2:0);
  const opacities = sigMask.map(s=>s?1:0.35);
  const finiteColors = colorValues.filter(v=>Number.isFinite(v));
  const cmax = finiteColors.length ? Math.max(...finiteColors, 1) : 1;
  const hovertemplate = `%{customdata[2]}<br>${xLabel}=%{customdata[4]}<br>adj p=%{customdata[1]}<br>-log10(adj p)=%{customdata[3]}<extra></extra>`;
  const pointData = modules.map((label, idx)=>[
    moduleKeys[idx] || label,
    padjDisplay[idx],
    label,
    colorDisplay[idx],
    xDisplay[idx]
  ]);
  let trace;
  if(vis==='dot'){
    trace={x:xValues,y:modules,mode:'markers',
      marker:{size:8,color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  } else {
    trace={x:xValues,y:modules,type:'bar',orientation:'h',
      marker:{color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  }
  const moduleLabel = cfg.moduleLabel || 'modules';
  const layout={
    xaxis:{title:xLabel},
    yaxis:{autorange:'reversed',automargin:true},
    margin:{l:190,r:140,t:100,b:90},
    title:`Top ${moduleLabel} for ${ct} (${titleSuffix})`,
    annotations:[{text:'Black border: padj < 0.05 · Transparent: padj ≥ 0.05',xref:'paper',yref:'paper',x:0,y:-0.2,xanchor:'left',yanchor:'top',showarrow:false,align:'left'}]
  };
  Plotly.newPlot(plotId,[trace],layout,PLOTLY_THEME.config).then(gd=>{
    const moduleKeyMap=new Map();
    modules.forEach((label,idx)=>{
      if(typeof label==='string'&&label){
        const keyVal=moduleKeys[idx]||label;
        moduleKeyMap.set(label,keyVal);
      }
    });
    gd.on('plotly_click',d=>{
      const point=d.points[0]||{};
      const custom=Array.isArray(point.customdata)?point.customdata:null;
      const gs=custom&&custom[0]?custom[0]:moduleKeyMap.get(point.y)||point.y;
      $(`#${key}GsvaInput_${DOM}`).val(gs);
      drawGeneSetBox(key);
    });
    const ticks=$(`#${plotId} .ytick text`);
    ticks.css('cursor','pointer').off('click').on('click',function(){
      const label=$(this).text();
      const gs=moduleKeyMap.get(label)||label;
      $(`#${key}GsvaInput_${DOM}`).val(gs);
      drawGeneSetBox(key);
    });
    requestAnimationFrame(()=>Plotly.Plots.resize(gd));
  });
  updateGeneSetGsvaList(key);
}

function updateGeneSetGsvaList(key){
  const cfg = GENESET_TABS[key];
  if(!cfg) return;
  const ct = $(`#${key}CelltypeSel_${DOM}`).val();
  const gsva = (cfg.gsva && cfg.gsva[ct]) || {};
  const fdrMap = gsva.fdr || {};
  const sets = Object.keys(gsva.boxData || {});
  sets.sort((a,b)=>{
    const fa = sanitizeNumericValue(fdrMap[a] ?? 1);
    const fb = sanitizeNumericValue(fdrMap[b] ?? 1);
    return (fa ?? 1) - (fb ?? 1);
  });
  const list = $(`#${key}GsvaList_${DOM}`);
  list.empty();
  sets.forEach(gs=>list.append(`<option value="${gs}">`));
  const input = $(`#${key}GsvaInput_${DOM}`);
  if(sets.length && !sets.includes(input.val())) input.val(sets[0]);
  drawGeneSetBox(key);
}

function renderGsvaBoxPlot(containerId, series, options={}){
  if(!Array.isArray(series) || !series.length){
    Plotly.purge(containerId);
    return;
  }
  const {
    title='',
    fdrValue=null,
    yAxisTitle='GSVA score',
    groupLabel=''
  } = options;
  const resolveFontFamily = () => {
    const target = document.body || document.documentElement;
    return target ? getComputedStyle(target).fontFamily : '"Helvetica Neue", Arial, sans-serif';
  };
  const fontFamily=(PLOTLY_THEME?.layout?.font?.family)||resolveFontFamily();
  const safeGroupLabel=groupLabel?sanitizeMinusText(groupLabel):'';
  const palette=['#29458C','#C4602C','#43701D','#8F3F7A','#3B6C7E','#9C4F17','#2478A6'];
  const normalizeHex=value=>{
    if(typeof value!=='string') return null;
    const trimmed=value.trim();
    if(/^#?[0-9a-fA-F]{6}$/.test(trimmed)){
      return trimmed.startsWith('#')?trimmed:`#${trimmed}`;
    }
    return null;
  };
  const clampChannel=v=>Math.min(255,Math.max(0,Math.round(v)));
  const hexToRgb=hex=>{
    const norm=normalizeHex(hex);
    if(!norm) return null;
    return [
      parseInt(norm.slice(1,3),16),
      parseInt(norm.slice(3,5),16),
      parseInt(norm.slice(5,7),16)
    ];
  };
  const rgbToHex=(r,g,b)=>{
    const channels=[r,g,b].map(v=>clampChannel(v).toString(16).padStart(2,'0'));
    return `#${channels.join('')}`;
  };
  const lightenHex=(hex,amount=0.55)=>{
    const rgb=hexToRgb(hex);
    if(!rgb) return null;
    const light=rgb.map(channel=>channel+(255-channel)*amount);
    return rgbToHex(light[0],light[1],light[2]);
  };
  const rgbaFromHex=(hex,alpha=0.35)=>{
    const rgb=hexToRgb(hex);
    const safeAlpha=Math.min(1,Math.max(0,Number(alpha)));
    if(!rgb) return `rgba(31,31,31,${safeAlpha||0.35})`;
    const [r,g,b]=rgb.map(clampChannel);
    return `rgba(${r},${g},${b},${safeAlpha})`;
  };
  let globalMin=Number.POSITIVE_INFINITY;
  let globalMax=Number.NEGATIVE_INFINITY;
  let allNonNegative=true;
  const traces=series.map((entry,idx)=>{
    const points=sanitizeNumericArray(entry?.y||[]);
    points.forEach(val=>{
      if(Number.isFinite(val)){
        if(val<globalMin) globalMin=val;
        if(val>globalMax) globalMax=val;
        if(val<0) allNonNegative=false;
      }
    });
    const rawName=sanitizeMinusText(entry?.name);
    const baseLabel=typeof rawName==='string'&&rawName.trim().length?rawName.trim():`Group ${idx+1}`;
    const sampleCount=points.length;
    const hasEmbeddedCount=/\(\s*n\s*=\s*\d+/i.test(baseLabel);
    const displayLabel=sampleCount&&!hasEmbeddedCount?`${baseLabel} (n=${sampleCount})`:baseLabel;
    const rawText=Array.isArray(entry?.text)?entry.text.map(sanitizeMinusText):sanitizeMinusText(entry?.text);
    const hoverLines=[];
    if(baseLabel){
      hoverLines.push(safeGroupLabel?`${safeGroupLabel}: ${baseLabel}`:baseLabel);
    }
    if(Array.isArray(rawText)){
      hoverLines.push('%{text}');
    }else if(typeof rawText==='string' && rawText.trim().length){
      hoverLines.push(rawText.trim());
    }
    hoverLines.push(`${yAxisTitle}=%{y:.3f}`);
    if(sampleCount) hoverLines.push(`n=${sampleCount}`);
    const providedLine=entry?.line&&typeof entry.line==='object'?entry.line:{};
    const providedMarker=entry?.marker&&typeof entry.marker==='object'?entry.marker:{};
    const baseHex=normalizeHex(providedLine.color||entry?.color||palette[idx%palette.length])||'#2A3F5F';
    const lineColor=providedLine.color||baseHex;
    const fillColor=typeof entry?.fillcolor==='string'?entry.fillcolor:rgbaFromHex(lightenHex(baseHex,0.62)||baseHex,0.45);
    const markerColor=providedMarker.color||rgbaFromHex(baseHex,0.8);
    const markerLine=providedMarker.line&&typeof providedMarker.line==='object'?providedMarker.line:{};
    const marker={
      size:providedMarker.size??6,
      opacity:providedMarker.opacity??0.78,
      color:markerColor,
      line:{
        width:markerLine.width??0,
        color:markerLine.color??rgbaFromHex(baseHex,0.9)
      }
    };
    if(markerLine&&typeof markerLine==='object'){
      marker.line={...marker.line,...markerLine};
    }
    const line={
      width:providedLine.width??2,
      color:lineColor
    };
    const xValues=Array(points.length).fill(displayLabel);
    const jitter=entry?.jitter??0.28;
    const pointPosition=entry?.pointpos??0;
    const boxpoints=entry?.boxpoints??'all';
    const whiskerWidth=entry?.whiskerwidth??0.45;
    const traceWidth=entry?.width??0.55;
    return {
      type:'box',
      x:xValues,
      y:points,
      name:displayLabel,
      text:rawText,
      customdata:points.map(()=>sampleCount||null),
      boxpoints,
      jitter,
      pointpos:pointPosition,
      marker,
      line,
      fillcolor:fillColor,
      whiskerwidth:whiskerWidth,
      width:traceWidth,
      boxmean:false,
      hovertemplate:`${hoverLines.join('<br>')}<extra></extra>`
    };
  });
  if(!Number.isFinite(globalMin)||!Number.isFinite(globalMax)){
    globalMin=0;
    globalMax=1;
  }
  const span=globalMax-globalMin;
  const padBase=span>0?span*0.08:Math.max(Math.abs(globalMax),1)*0.08;
  let lowerBound=allNonNegative?0:globalMin-padBase;
  let upperBound=globalMax+(allNonNegative?padBase*0.75:padBase);
  if(upperBound<=lowerBound){
    const fallbackSpan=span||Math.max(Math.abs(globalMax),1)||1;
    upperBound=lowerBound+fallbackSpan;
  }
  const categoryLabels=Array.from(new Set(traces.map(trace=>{
    if(Array.isArray(trace.x)&&trace.x.length){
      return typeof trace.x[0]==='string'?trace.x[0]:trace.name;
    }
    return trace.name;
  }).filter(Boolean)));
  const categoryRange=categoryLabels.length?[-0.5,categoryLabels.length-0.5]:null;
  const layout={
    autosize:true,
    font:{family:fontFamily,size:12,color:'#1a1a1a'},
    title:{text:sanitizeMinusText(title),x:0.5,xanchor:'center',font:{family:fontFamily,size:18,color:'#111111'}},
    margin:{t:200,r:140,b:100,l:120},
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    hovermode:'closest',
    boxmode:'group',
    boxgap:0.22,
    boxgroupgap:0.1,
    hoverlabel:{bgcolor:'#ffffff',bordercolor:'#1a1a1a',font:{family:fontFamily,size:11,color:'#1a1a1a'}},
    yaxis:{
      title:{text:yAxisTitle,standoff:14,font:{family:fontFamily,size:13,color:'#111111'}},
      showline:true,
      linecolor:'#1a1a1a',
      linewidth:1,
      gridcolor:'#d9d9d9',
      gridwidth:0.6,
      zeroline:allNonNegative,
      tickformat:'.2f',
      tickfont:{family:fontFamily,size:11,color:'#1a1a1a'},
      autorange:false,
      range:[lowerBound,upperBound],
      automargin:true
    },
    xaxis:{
      showline:true,
      linecolor:'#1a1a1a',
      linewidth:1,
      showgrid:false,
      zeroline:false,
      tickfont:{family:fontFamily,size:11,color:'#1a1a1a'},
      type:'category',
      categoryorder:'array',
      categoryarray:categoryLabels,
      tickmode:'array',
      tickvals:categoryLabels,
      ticktext:categoryLabels
    },
    legend:{
      orientation:'h',
      x:0,
      xanchor:'left',
      y:1,
      yanchor:'top',
      font:{family:fontFamily,size:11,color:'#1a1a1a'},
      itemwidth:80
    },
    shapes:[],
    annotations:[]
  };
  if(safeGroupLabel){
    layout.xaxis.title={text:safeGroupLabel,standoff:12,font:{family:fontFamily,size:13,color:'#111111'}};
  }
  if(categoryRange){
    const [xStart,xEnd]=categoryRange;
    const squeeze=Math.min(0.35,0.18+Math.max(0,categoryLabels.length-2)*0.04);
    const newStart=xStart+squeeze;
    const newEnd=xEnd-squeeze;
    layout.xaxis.range=newEnd>newStart?[newStart,newEnd]:categoryRange;
  }
  if(!allNonNegative){
    layout.yaxis.zerolinecolor='#b3b3b3';
    layout.yaxis.zerolinewidth=1;
  }else{
    layout.yaxis.rangemode='tozero';
  }
  if(fdrValue!=null && fdrValue!==undefined){
    const cleanFdr=sanitizeNumericValue(fdrValue);
    if(cleanFdr!=null){
      const isSig=cleanFdr<0.05;
      const badgeColor=isSig?'#0f766e':'#4b5563';
      const badgeLabel=isSig?'SIGNIFICANT':'NOT SIG';
      layout.annotations=[{
        text:`${badgeLabel} · FDR ${Number(cleanFdr).toExponential(2)}`,
        xref:'paper',yref:'paper',x:1,y:1.08,xanchor:'right',yanchor:'top',
        showarrow:false,
        font:{family:fontFamily,size:12,color:badgeColor},
        bgcolor:isSig?'rgba(16,185,129,0.15)':'rgba(148,163,184,0.2)',
        bordercolor:`${badgeColor}33`,
        borderwidth:1,
        borderpad:4,
        align:'right'
      }];
    }
  }
  Plotly.newPlot(containerId,traces,layout,PLOTLY_THEME.config)
    .then(gd=>requestAnimationFrame(()=>Plotly.Plots.resize(gd)));
}

function drawGeneSetBox(key){
  const cfg = GENESET_TABS[key];
  if(!cfg) return;
  const ct = $(`#${key}CelltypeSel_${DOM}`).val();
  const gs = $(`#${key}GsvaInput_${DOM}`).val();
  const gsva = (cfg.gsva && cfg.gsva[ct]) || {};
  const data = gsva.boxData && gsva.boxData[gs];
  const boxId = `${key}Box_${DOM}`;
  if(!data){
    Plotly.purge(boxId);
    return;
  }
  const fdr = gsva.fdr ? sanitizeNumericValue(gsva.fdr[gs]) : null;
  const sigText = fdr!=null ? (fdr<0.05 ? 'sig' : 'not sig') : '';
  const title = fdr!=null ? `${gs} | FDR=${Number(fdr).toExponential(2)} | ${sigText}` : gs;
  renderGsvaBoxPlot(boxId, data, {
    title,
    fdrValue: fdr,
    yAxisTitle: 'GSVA score',
    groupLabel: gsva.groupLabel || ''
  });
}

function downloadGeneSetGsvaCSV(key){
  const cfg = GENESET_TABS[key];
  if(!cfg) return;
  const header=['cell_type','gene_set','ulm_score','ulm_padj','stat','pval','pval_adj'];
  const rows=[header];
  Object.keys(cfg.gsva || {}).forEach(ct=>{
    const gsvaPayload = cfg.gsva[ct] || {};
    const stats = (gsvaPayload && gsvaPayload.stats) || {};
    const ulmMap = (gsvaPayload && gsvaPayload.ulm) || {};
    const modules = Array.from(new Set([
      ...Object.keys(stats),
      ...Object.keys(ulmMap)
    ]));
    modules.sort((a,b)=>compareModulesByUlmPadj(a,b, ulmMap));
    modules.forEach(gs=>{
      const ulmEntry = ulmMap[gs] || {};
      const st = stats[gs] || {};
      rows.push([
        ct,
        gs,
        ulmEntry.score ?? '',
        ulmEntry.padj ?? '',
        st.stat ?? '',
        st.pval ?? '',
        st.pval_adj ?? ''
      ]);
    });
  });
  const name = cfg.downloadName || `${key}_gsva_results.csv`;
  downloadTableCSV(name, rows);
}

function bindGeneSetEvents(key){
  $(`#${key}CelltypeSel_${DOM}`).off('.geneSet').on('change.geneSet',()=>drawGeneSet(key));
  $(`#${key}StatSel_${DOM}`).off('.geneSet').on('change.geneSet',()=>drawGeneSet(key));
  $(`#${key}VisSel_${DOM}`).off('.geneSet').on('change.geneSet',()=>drawGeneSet(key));
  $(`#${key}TopSel_${DOM}`).off('.geneSet').on('change.geneSet',()=>drawGeneSet(key));
  $(`#${key}GsvaInput_${DOM}`).off('.geneSet').on('input.geneSet',()=>drawGeneSetBox(key));
  $(`#${key}GsvaDownload_${DOM}`).off('.geneSet').on('click.geneSet',()=>downloadGeneSetGsvaCSV(key));
}

function setupGeneSetTabs(){
  const toggle=document.getElementById(`enrichmentToggle_${DOM}`);
  const template=document.getElementById(`enrichCustomSegment_${DOM}`);
  const panelsContainer=document.querySelector('#btm .enrichment-panels');
  const basePanel=document.querySelector('#btm .enrichment-panel[data-enrichment="btm"]');
  if(!toggle || !template || !panelsContainer || !basePanel) return;

  const customConfigs=Object.values(GENESET_TABS).filter(cfg=>cfg.slug!=='btm');
  if(!customConfigs.length){
    template.remove();
    return;
  }

  customConfigs.forEach((cfg,idx)=>{
    const segment=template.cloneNode(true);
    segment.classList.remove('d-none');
    segment.id=`enrichmentSegment_${cfg.slug}_${DOM}`;
    const input=segment.querySelector('input');
    const label=segment.querySelector('label');
    if(input){
      input.id=`enrich_${cfg.slug}_${DOM}`;
      input.value=cfg.slug;
      input.checked=false;
      input.setAttribute('aria-controls', `${cfg.slug}Panel_${DOM}`);
    }
    if(label){
      const labelText=idx===0
        ? (cfg.navLabel || 'Custom enrichment')
        : (cfg.navLabel || `Custom ${idx+1}`);
      const inputId=input?input.id:`enrich_${cfg.slug}_${DOM}`;
      label.htmlFor=inputId;
      label.textContent=labelText;
    }
    toggle.appendChild(segment);
  });
  template.remove();

  customConfigs.forEach(cfg=>{
    if(document.querySelector(`#btm .enrichment-panel[data-enrichment='${cfg.slug}']`)) return;
    const panelClone=basePanel.cloneNode(true);
    panelClone.classList.remove('active');
    panelClone.dataset.enrichment=cfg.slug;
    panelClone.id=`${cfg.slug}Panel_${DOM}`;
    panelClone.querySelectorAll('[id]').forEach(el=>{
      if(el.id.startsWith('btm')){
        el.id=cfg.slug+el.id.slice(3);
      }
    });
    panelClone.querySelectorAll('label[for]').forEach(label=>{
      if(label.htmlFor && label.htmlFor.startsWith('btm')){
        label.htmlFor=cfg.slug+label.htmlFor.slice(3);
      }
    });
    panelClone.querySelectorAll('[list]').forEach(input=>{
      const listId=input.getAttribute('list');
      if(listId && listId.startsWith('btm')){
        input.setAttribute('list', cfg.slug+listId.slice(3));
      }
    });
    panelsContainer.appendChild(panelClone);
    if(typeof TOUR_STEPS === 'object' && TOUR_STEPS && !TOUR_STEPS[cfg.slug]){
      TOUR_STEPS[cfg.slug]=TOUR_STEPS.btm;
    }
    if(!(cfg.slug in geneSetInit)){
      geneSetInit[cfg.slug]=false;
    }
  });

  if(window.feather && typeof window.feather.replace==='function'){
    window.feather.replace();
  }
}

function ensureGeneSetInitialized(key){
  if(!Object.prototype.hasOwnProperty.call(geneSetInit, key)) return;
  if(!geneSetInit[key]){
    populateGeneSetCelltypes(key);
    geneSetInit[key]=true;
  }
  drawGeneSet(key);
}

function activateEnrichmentSource(source){
  if(!source) return;
  activeEnrichmentSource=source;
  const toggle=document.getElementById(`enrichmentToggle_${DOM}`);
  if(toggle){
    const radios=toggle.querySelectorAll(`input[name="enrichmentSource_${DOM}"]`);
    radios.forEach(radio=>{
      radio.checked = (radio.value === source);
    });
  }
  const panels=document.querySelectorAll('#btm .enrichment-panel');
  panels.forEach(panel=>{
    const key=panel.dataset.enrichment;
    panel.classList.toggle('active', key===source);
  });
  if(Object.prototype.hasOwnProperty.call(geneSetInit, source)){
    ensureGeneSetInitialized(source);
  } else if(source==='hallmarks'){
    if(!hallmarkInit){
      populateHallmarkCelltypes();
      hallmarkInit=true;
    }
    drawHallmark();
  } else if(source==='tf'){
    if(!tfInit){
      populateTFCelltypes();
      tfInit=true;
    }
    drawTF();
  }
  if(currentTab==='btm'){
    const desiredSub=(source && source!=='btm') ? source : '';
    if(currentSub!==desiredSub){
      currentSub=desiredSub;
      setHash('btm', desiredSub || undefined);
    }
  }
}

function populateHallmarkCelltypes(){
  const cSel=$("#hallmarkCelltypeSel_"+DOM); cSel.empty();
  Object.keys(HALLMARK_ENRICH).forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
  drawHallmark();
}
function drawHallmark(){
  const ct=$("#hallmarkCelltypeSel_"+DOM).val();
  const vis=$("#hallmarkVisSel_"+DOM).val();
  const top=parseInt($("#hallmarkTopSel_"+DOM).val(),10)||25;
  const statModeRaw=$("#hallmarkStatSel_"+DOM).val();
  const statMode=typeof statModeRaw==='string'?statModeRaw.toLowerCase():'gsea';
  const normalizedMode=statMode==='gsva'?'gsva':'gsea';
  const plotId='hallmarkPlot_'+DOM;
  const gsvaPayload=HALLMARK_GSVA[ct]||{};
  const statsMap=(gsvaPayload && gsvaPayload.stats)||{};
  const ulmMap=(gsvaPayload && gsvaPayload.ulm)||{};
  const entries=collectGeneSetDisplayEntries(HALLMARK_ENRICH[ct]||[],statsMap,ulmMap,top*3);
  if(!entries.length){Plotly.purge(plotId);return;}
  const prepared=prepareGeneSetPlot(entries,top,normalizedMode);
  if(!prepared){Plotly.purge(plotId);return;}
  const {modules,moduleKeys,padjValues,padjDisplay,colorValues,colorDisplay,xValues,xDisplay,xLabel,colorbarTitle,titleSuffix}=prepared;
  if(!modules.length){Plotly.purge(plotId);return;}
  const sigMask=padjValues.map(p=>typeof p==='number'&&p<0.05);
  const outlines=sigMask.map(s=>s?'black':'rgba(0,0,0,0)');
  const widths=sigMask.map(s=>s?2:0);
  const opacities=sigMask.map(s=>s?1:0.35);
  const finiteColors=colorValues.filter(v=>Number.isFinite(v));
  const cmax=finiteColors.length?Math.max(...finiteColors,1):1;
  const hovertemplate=`%{customdata[2]}<br>${xLabel}=%{customdata[4]}<br>adj p=%{customdata[1]}<br>-log10(adj p)=%{customdata[3]}<extra></extra>`;
  const pointData=modules.map((label,idx)=>[
    moduleKeys[idx]||label,
    padjDisplay[idx],
    label,
    colorDisplay[idx],
    xDisplay[idx]
  ]);
  let trace;
  if(vis==='dot'){
    trace={x:xValues,y:modules,mode:'markers',
      marker:{size:8,color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  }else{
    trace={x:xValues,y:modules,type:'bar',orientation:'h',
      marker:{color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  }
  const layout={xaxis:{title:xLabel},yaxis:{autorange:'reversed',automargin:true},margin:{l:190,r:140,t:100,b:90},
    title:`Top Hallmark pathways for ${ct} (${titleSuffix})`,
    annotations:[{text:'Black border: padj < 0.05 · Transparent: padj ≥ 0.05',xref:'paper',yref:'paper',x:0,y:-0.2,xanchor:'left',yanchor:'top',showarrow:false,align:'left'}]};
  Plotly.newPlot(plotId,[trace],layout,PLOTLY_THEME.config).then(gd=>{
    const moduleKeyMap=new Map();
    modules.forEach((label,idx)=>{
      if(typeof label==='string'&&label){
        const keyVal=moduleKeys[idx]||label;
        moduleKeyMap.set(label,keyVal);
      }
    });
    gd.on('plotly_click',d=>{
      const point=d.points[0]||{};
      const custom=Array.isArray(point.customdata)?point.customdata:null;
      const gs=custom&&custom[0]?custom[0]:moduleKeyMap.get(point.y)||point.y;
      $('#hallmarkGsvaInput_'+DOM).val(gs);
      drawHallmarkBox();
    });
    const ticks=$('#'+plotId+' .ytick text');
    ticks.css('cursor','pointer').off('click').on('click',function(){
      const label=$(this).text();
      const gs=moduleKeyMap.get(label)||label;
      $('#hallmarkGsvaInput_'+DOM).val(gs);
      drawHallmarkBox();
    });
    requestAnimationFrame(()=>Plotly.Plots.resize(gd));
  });
  updateHallmarkGsvaList(ct);
}

function updateHallmarkGsvaList(ct){
  const gsva=HALLMARK_GSVA[ct]||{};
  const fdrMap=gsva.fdr||{};
  const sets=Object.keys(gsva.boxData||{});
  sets.sort((a,b)=>{
    const fa=sanitizeNumericValue(fdrMap[a]??1);
    const fb=sanitizeNumericValue(fdrMap[b]??1);
    return (fa??1)-(fb??1);
  });
  const list=$("#hallmarkGsvaList_"+DOM); list.empty();
  sets.forEach(gs=>list.append(`<option value="${gs}">`));
  const inp=$("#hallmarkGsvaInput_"+DOM);
  if(sets.length && !sets.includes(inp.val())) inp.val(sets[0]);
  drawHallmarkBox();
}

function drawHallmarkBox(){
  const ct=$("#hallmarkCelltypeSel_"+DOM).val();
  const gs=$("#hallmarkGsvaInput_"+DOM).val();
  const gsva=HALLMARK_GSVA[ct]||{};
  const data=gsva.boxData&&gsva.boxData[gs];
  if(!data){Plotly.purge('hallmarkBox_'+DOM);return;}
  const fdr=gsva.fdr?gsva.fdr[gs]:null;
  const cleanFdr=sanitizeNumericValue(fdr);
  const sigText=cleanFdr!=null?(cleanFdr<0.05?'sig':'not sig'):'';
  const title=cleanFdr!=null?`${gs} | FDR=${Number(cleanFdr).toExponential(2)} | ${sigText}`:gs;
  renderGsvaBoxPlot('hallmarkBox_'+DOM,data,{
    title,
    fdrValue:cleanFdr,
    yAxisTitle:'GSVA score',
    groupLabel:gsva.groupLabel||''
  });
}

function populateTFCelltypes(){
  const cSel=$("#tfCelltypeSel_"+DOM); cSel.empty();
  Object.keys(TF_ENRICH).forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
  drawTF();
}
function drawTF(){
  const ct=$("#tfCelltypeSel_"+DOM).val();
  const vis=$("#tfVisSel_"+DOM).val();
  const top=parseInt($("#tfTopSel_"+DOM).val(),10)||25;
  const statModeRaw=$("#tfStatSel_"+DOM).val();
  const statMode=typeof statModeRaw==='string'?statModeRaw.toLowerCase():'gsea';
  const normalizedMode=statMode==='gsva'?'gsva':'gsea';
  const plotId='tfPlot_'+DOM;
  const gsvaPayload=TF_GSVA[ct]||{};
  const statsMap=(gsvaPayload && gsvaPayload.stats)||{};
  const ulmMap=(gsvaPayload && gsvaPayload.ulm)||{};
  const entries=collectGeneSetDisplayEntries(TF_ENRICH[ct]||[],statsMap,ulmMap,top*3);
  if(!entries.length){Plotly.purge(plotId);return;}
  const prepared=prepareGeneSetPlot(entries,top,normalizedMode);
  if(!prepared){Plotly.purge(plotId);return;}
  const {modules,moduleKeys,padjValues,padjDisplay,colorValues,colorDisplay,xValues,xDisplay,xLabel,colorbarTitle,titleSuffix}=prepared;
  if(!modules.length){Plotly.purge(plotId);return;}
  const sigMask=padjValues.map(p=>typeof p==='number'&&p<0.05);
  const outlines=sigMask.map(s=>s?'black':'rgba(0,0,0,0)');
  const widths=sigMask.map(s=>s?2:0);
  const opacities=sigMask.map(s=>s?1:0.35);
  const finiteColors=colorValues.filter(v=>Number.isFinite(v));
  const cmax=finiteColors.length?Math.max(...finiteColors,1):1;
  const hovertemplate=`%{customdata[2]}<br>${xLabel}=%{customdata[4]}<br>adj p=%{customdata[1]}<br>-log10(adj p)=%{customdata[3]}<extra></extra>`;
  const pointData=modules.map((label,idx)=>[
    moduleKeys[idx]||label,
    padjDisplay[idx],
    label,
    colorDisplay[idx],
    xDisplay[idx]
  ]);
  let trace;
  if(vis==='dot'){
    trace={x:xValues,y:modules,mode:'markers',
      marker:{size:8,color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  }else{
    trace={x:xValues,y:modules,type:'bar',orientation:'h',
      marker:{color:colorValues,colorscale:'Viridis',cmin:0,cmax,
              colorbar:{title:colorbarTitle},line:{color:outlines,width:widths},opacity:opacities},
      customdata:pointData,
      hovertemplate};
  }
  const layout={xaxis:{title:xLabel},yaxis:{autorange:'reversed',automargin:true},margin:{l:190,r:140,t:100,b:90},
    title:`Top TFs for ${ct} (${titleSuffix})`,
    annotations:[{text:'Black border: padj < 0.05 · Transparent: padj ≥ 0.05',xref:'paper',yref:'paper',x:0,y:-0.2,xanchor:'left',yanchor:'top',showarrow:false,align:'left'}]};
  Plotly.newPlot(plotId,[trace],layout,PLOTLY_THEME.config).then(gd=>{
    const moduleKeyMap=new Map();
    modules.forEach((label,idx)=>{
      if(typeof label==='string'&&label){
        const keyVal=moduleKeys[idx]||label;
        moduleKeyMap.set(label,keyVal);
      }
    });
    gd.on('plotly_click',d=>{
      const point=d.points[0]||{};
      const custom=Array.isArray(point.customdata)?point.customdata:null;
      const gs=custom&&custom[0]?custom[0]:moduleKeyMap.get(point.y)||point.y;
      $('#tfGsvaInput_'+DOM).val(gs);
      drawTFBox();
    });
    const ticks=$('#'+plotId+' .ytick text');
    ticks.css('cursor','pointer').off('click').on('click',function(){
      const label=$(this).text();
      const gs=moduleKeyMap.get(label)||label;
      $('#tfGsvaInput_'+DOM).val(gs);
      drawTFBox();
    });
    requestAnimationFrame(()=>Plotly.Plots.resize(gd));
  });
  updateTfGsvaList(ct);
}

function updateTfGsvaList(ct){
  const gsva=TF_GSVA[ct]||{};
  const fdrMap=gsva.fdr||{};
  const sets=Object.keys(gsva.boxData||{});
  sets.sort((a,b)=>{
    const fa=sanitizeNumericValue(fdrMap[a]??1);
    const fb=sanitizeNumericValue(fdrMap[b]??1);
    return (fa??1)-(fb??1);
  });
  const list=$("#tfGsvaList_"+DOM); list.empty();
  sets.forEach(gs=>list.append(`<option value="${gs}">`));
  const inp=$("#tfGsvaInput_"+DOM);
  if(sets.length && !sets.includes(inp.val())) inp.val(sets[0]);
  drawTFBox();
}

function drawTFBox(){
  const ct=$("#tfCelltypeSel_"+DOM).val();
  const gs=$("#tfGsvaInput_"+DOM).val();
  const gsva=TF_GSVA[ct]||{};
  const data=gsva.boxData&&gsva.boxData[gs];
  if(!data){Plotly.purge('tfBox_'+DOM);return;}
  const fdr=gsva.fdr?gsva.fdr[gs]:null;
  const cleanFdr=sanitizeNumericValue(fdr);
  const sigText=cleanFdr!=null?(cleanFdr<0.05?'sig':'not sig'):'';
  const title=cleanFdr!=null?`${gs} | FDR=${Number(cleanFdr).toExponential(2)} | ${sigText}`:gs;
  renderGsvaBoxPlot('tfBox_'+DOM,data,{
    title,
    fdrValue:cleanFdr,
    yAxisTitle:'GSVA score',
    groupLabel:gsva.groupLabel||''
  });
}

function populateTFNetCelltypes(){
  const cSel=$("#tfNetCelltypeSel_"+DOM); cSel.empty();
  Object.keys(TF_NETWORK).forEach(c=>cSel.append(`<option value="${c}">${c}</option>`));
  drawTFNetwork();
}

function tfNetLayoutCircle(ids){
  const positions=new Map();
  const total=ids.length;
  if(!total) return positions;
  const step=2*Math.PI/total;
  const radius=1;
  ids.forEach((id,idx)=>{
    const key=String(id);
    positions.set(key,{x:radius*Math.cos(step*idx),y:radius*Math.sin(step*idx)});
  });
  return positions;
}

function computeTfClusterLayout(tfNodes, edges){
  const layout=new Map();
  const tfCount=tfNodes.length;
  if(!tfCount){
    return layout;
  }

  const radius=Math.max(2.5,1.2+0.4*tfCount);
  tfNodes.forEach((tf,idx)=>{
    const tfId=String(tf.id);
    const angle=(2*Math.PI*idx)/tfCount;
    layout.set(tfId,{
      x:radius*Math.cos(angle),
      y:radius*Math.sin(angle)
    });
  });

  const tfToEdges=new Map();
  const geneToParents=new Map();
  edges.forEach(edge=>{
    const src=String(edge.source);
    const tgt=String(edge.target);
    if(!tfToEdges.has(src)) tfToEdges.set(src,[]);
    tfToEdges.get(src).push(edge);
    if(!geneToParents.has(tgt)) geneToParents.set(tgt,[]);
    geneToParents.get(tgt).push(src);
  });

  tfToEdges.forEach((edgeList,tfId)=>{
    const center=layout.get(tfId)||{x:0,y:0};
    const ordered=edgeList
      .slice()
      .sort((a,b)=>Math.abs(Number(b.weight)||0)-Math.abs(Number(a.weight)||0));
    const count=ordered.length||1;
    const localRadius=Math.max(0.8,Math.min(1.4,0.7+0.08*count));
    ordered.forEach((edge,idx)=>{
      const geneId=String(edge.target);
      if(layout.has(geneId)) return;
      const angle=count>1 ? (2*Math.PI*idx)/count : Math.PI/2;
      layout.set(geneId,{
        x:center.x+localRadius*Math.cos(angle),
        y:center.y+localRadius*Math.sin(angle)
      });
    });
  });

  geneToParents.forEach((parents,geneId)=>{
    if(parents.length<=1) return;
    const centers=parents.map(pid=>layout.get(pid)).filter(Boolean);
    if(!centers.length) return;
    const centroid=centers.reduce((acc,pos)=>({x:acc.x+pos.x,y:acc.y+pos.y}),{x:0,y:0});
    centroid.x/=centers.length;
    centroid.y/=centers.length;
    layout.set(geneId,centroid);
  });

  let maxAbs=0;
  layout.forEach(pos=>{
    if(!pos) return;
    maxAbs=Math.max(maxAbs,Math.abs(pos.x),Math.abs(pos.y));
  });
  if(maxAbs>0){
    layout.forEach((pos,id)=>{
      if(!pos) return;
      layout.set(id,{x:pos.x/maxAbs,y:pos.y/maxAbs});
    });
  }
  return layout;
}

function normaliseTfNetCoords(nodes){
  if(!nodes||!nodes.length) return new Map();
  const finite=[];
  nodes.forEach(n=>{
    const x=Number(n.x);
    const y=Number(n.y);
    const id=String(n.id);
    if(Number.isFinite(x)&&Number.isFinite(y)){
      finite.push({id,x,y});
    }
  });
  let coords=new Map();
  if(!finite.length){
    return tfNetLayoutCircle(nodes.map(n=>String(n.id)));
  }
  const meanX=finite.reduce((sum,p)=>sum+p.x,0)/finite.length;
  const meanY=finite.reduce((sum,p)=>sum+p.y,0)/finite.length;
  const xs=finite.map(p=>p.x);
  const ys=finite.map(p=>p.y);
  const spanX=Math.max(...xs)-Math.min(...xs);
  const spanY=Math.max(...ys)-Math.min(...ys);
  let scale=Math.max(spanX,spanY);
  if(!Number.isFinite(scale)||scale<=1e-9){
    scale=1;
  }
  finite.forEach(p=>{
    coords.set(p.id,{x:(p.x-meanX)/scale,y:(p.y-meanY)/scale});
  });
  const missing=nodes.map(n=>String(n.id)).filter(id=>!coords.has(id));
  if(missing.length){
    const fallback=tfNetLayoutCircle(missing);
    fallback.forEach((pos,id)=>coords.set(id,pos));
  }
  const tol=1e-3;
  const buckets=new Map();
  coords.forEach((pos,id)=>{
    const key=`${Math.round(pos.x/tol)}|${Math.round(pos.y/tol)}`;
    if(!buckets.has(key)) buckets.set(key,[]);
    buckets.get(key).push(id);
  });
  const jitter=Math.max(0.15,0.9/Math.max(nodes.length,1));
  buckets.forEach(ids=>{
    if(ids.length<=1) return;
    const step=(2*Math.PI)/ids.length;
    ids.forEach((id,idx)=>{
      const base=coords.get(id)||{x:0,y:0};
      coords.set(id,{
        x:base.x+jitter*Math.cos(step*idx),
        y:base.y+jitter*Math.sin(step*idx)
      });
    });
  });
  let maxAbs=0;
  coords.forEach(pos=>{
    if(Number.isFinite(pos.x)&&Number.isFinite(pos.y)){
      maxAbs=Math.max(maxAbs,Math.abs(pos.x),Math.abs(pos.y));
    }
  });
  if(maxAbs>0){
    coords.forEach((pos,id)=>{
      if(Number.isFinite(pos.x)&&Number.isFinite(pos.y)){
        coords.set(id,{x:pos.x/maxAbs,y:pos.y/maxAbs});
      } else {
        coords.set(id,{x:0,y:0});
      }
    });
  }
  return coords;
}

function drawTFNetwork(){
  const ct=$("#tfNetCelltypeSel_"+DOM).val();
  const topSel=$("#tfNetTopSel_"+DOM);
  let top=parseInt(topSel.val(),10);
  if(!Number.isFinite(top)||top<1){
    top=10;
  }
  topSel.val(String(top));
  const targetInput=$("#tfNetTargetSel_"+DOM);
  let nTargets=parseInt(targetInput.val(),10);
  if(!Number.isFinite(nTargets)||nTargets<1){
    nTargets=5;
  }
  targetInput.val(String(nTargets));
  const payload=TF_NETWORK[ct]||{};
  const nodesAll=(payload.nodes||[]).map(node=>({
    ...node,
    id:String(node.id)
  }));
  const edgesAll=payload.edges||[];
  if(!nodesAll.length){Plotly.purge('tfNetPlot_'+DOM);Plotly.purge('tfNetBox_'+DOM);return;}

  const nodeMap=new Map();
  nodesAll.forEach(n=>nodeMap.set(n.id,n));
  const tfNodes=nodesAll.filter(n=>n.type==='tf');
  const sortedTFs=[...tfNodes]
    .sort((a,b)=>Math.abs((b.score??0)) - Math.abs((a.score??0)))
    .slice(0,top);

  const edgesBySource={};
  edgesAll.forEach(edge=>{
    const src=String(edge.source);
    if(!edgesBySource[src]) edgesBySource[src]=[];
    edgesBySource[src].push(edge);
  });

  const displayEdges=[];
  const displayNodeIds=new Set();
  if(sortedTFs.length){
    sortedTFs.forEach(tf=>{
      const tfId=tf.id;
      displayNodeIds.add(tfId);
      const list=(edgesBySource[tfId]||[])
        .slice()
        .sort((a,b)=>Math.abs((b.weight??0)) - Math.abs((a.weight??0)))
        .slice(0,nTargets);
      list.forEach(edge=>{
        displayEdges.push(edge);
        displayNodeIds.add(String(edge.source));
        displayNodeIds.add(String(edge.target));
      });
    });
  }else{
    edgesAll.forEach(edge=>{
      displayEdges.push(edge);
      displayNodeIds.add(String(edge.source));
      displayNodeIds.add(String(edge.target));
    });
    nodesAll.forEach(node=>displayNodeIds.add(node.id));
  }

  const displayNodes=Array.from(displayNodeIds)
    .map(id=>nodeMap.get(id))
    .filter(n=>n);
  if(!displayNodes.length){Plotly.purge('tfNetPlot_'+DOM);Plotly.purge('tfNetBox_'+DOM);return;}

  const clusterLayout=computeTfClusterLayout(sortedTFs, displayEdges);
  let coordMap;
  if(clusterLayout.size){
    const layoutNodes=displayNodes.map(node=>{
      const id=node.id;
      const pos=clusterLayout.get(id);
      if(pos){
        return {...node, id, x:pos.x, y:pos.y};
      }
      const nx=Number(node.x);
      const ny=Number(node.y);
      return {...node, id, x:Number.isFinite(nx)?nx:0, y:Number.isFinite(ny)?ny:0};
    });
    coordMap=normaliseTfNetCoords(layoutNodes);
  } else {
    coordMap=normaliseTfNetCoords(displayNodes.map(node=>({
      ...node,
      id:node.id
    })));
  }

  const targetDegree=new Map();
  displayEdges.forEach(edge=>{
    const tgt=String(edge.target);
    targetDegree.set(tgt,(targetDegree.get(tgt)||0)+1);
  });

  const plotNodes=displayNodes.map(n=>{
    const pos=coordMap.get(n.id)||{x:0,y:0};
    return {...n, plotX:pos.x, plotY:pos.y};
  });

  const posEdges={x:[],y:[],mode:'lines',line:{color:TF_EDGE_COLORS.positive,width:1.5},opacity:0.5,hoverinfo:'skip'};
  const negEdges={x:[],y:[],mode:'lines',line:{color:TF_EDGE_COLORS.negative,width:1.5},opacity:0.5,hoverinfo:'skip'};
  const focusEdges={x:[],y:[],mode:'lines',line:{color:TF_EDGE_COLORS.focus,width:2.5},opacity:0.75,hoverinfo:'skip'};
  displayEdges.forEach(edge=>{
    const srcId=String(edge.source);
    const tgtId=String(edge.target);
    const srcPos=coordMap.get(srcId);
    const tgtPos=coordMap.get(tgtId);
    if(!srcPos||!tgtPos) return;
    const sx=Number(srcPos.x??0);
    const sy=Number(srcPos.y??0);
    const tx=Number(tgtPos.x??0);
    const ty=Number(tgtPos.y??0);
    const tr=(Number(edge.weight??0)>=0)?posEdges:negEdges;
    tr.x.push(sx,tx,null);
    tr.y.push(sy,ty,null);
  });

  const displayFcs=plotNodes.map(n=>Number(n.fc??0)||0);
  const maxAbs=displayFcs.reduce((m,v)=>Math.max(m,Math.abs(v)),0)||1;
  const markerSizes=plotNodes.map(n=>n.type==='tf'?18:12);
  const markerSymbols=plotNodes.map(n=>n.type==='tf'?'square':'circle');
  const lineColors=plotNodes.map(n=>n.type==='tf'?'rgba(255,255,255,0.6)':'rgba(255,255,255,0.4)');
  const lineWidths=plotNodes.map(n=>n.type==='tf'?3:2);
  const markerOpacity=plotNodes.map(()=>0.85);
  const customData=plotNodes.map(n=>{
    const typeLabel=n.type==='tf'?'TF':'Target';
    const detailParts=[];
    if(n.type==='tf'&&n.score!=null&&isFinite(n.score)){
      detailParts.push(`score=${Number(n.score).toFixed(2)}`);
    }
    if(n.type==='target'){
      const sharedCount=targetDegree.get(n.id)||0;
      if(sharedCount>1){
        detailParts.push(`shared TFs=${sharedCount}`);
      }
    }
    return [typeLabel, Number(n.fc??0)||0, detailParts.join('<br>')];
  });

  // Shadow layer for 3D depth effect
  const shadowTrace={
    type:plotNodes.length>300?'scattergl':'scatter',
    x:plotNodes.map(n=>Number(n.plotX??0)+0.015),
    y:plotNodes.map(n=>Number(n.plotY??0)-0.015),
    mode:'markers',
    marker:{
      size:markerSizes.map(s=>s+2),
      symbol:markerSymbols,
      color:'rgba(0,0,0,0.15)',
      line:{width:0}
    },
    hoverinfo:'skip',
    showlegend:false
  };

  // Main node trace with glass effect
  const nodeTrace={
    type:plotNodes.length>300?'scattergl':'scatter',
    x:plotNodes.map(n=>Number(n.plotX??0)),
    y:plotNodes.map(n=>Number(n.plotY??0)),
    text:plotNodes.map(n=>n.id),
    mode:'markers+text',
    textposition:'bottom center',
    customdata:customData,
    hovertemplate:'%{customdata[0]} %{text}<br>logFC=%{customdata[1]:.2f}<br>%{customdata[2]}<extra></extra>',
    marker:{
      size:markerSizes,
      symbol:markerSymbols,
      color:displayFcs,
      cmin:-maxAbs,
      cmax:maxAbs,
      colorscale:TF_NODE_COLORSCALE,
      colorbar:{title:'logFC'},
      opacity:markerOpacity,
      line:{color:lineColors,width:lineWidths}
    }
  };

  // Highlight layer for glass shine effect
  const glassHighlight={
    type:plotNodes.length>300?'scattergl':'scatter',
    x:plotNodes.map(n=>Number(n.plotX??0)-0.008),
    y:plotNodes.map(n=>Number(n.plotY??0)+0.008),
    mode:'markers',
    marker:{
      size:markerSizes.map(s=>s*0.4),
      symbol:markerSymbols,
      color:'rgba(255,255,255,0.5)',
      line:{width:0}
    },
    hoverinfo:'skip',
    showlegend:false
  };

  const layout={
    ...PLOTLY_THEME.layout,
    xaxis:{visible:false},
    yaxis:{visible:false},
    margin:{l:20,r:20,t:40,b:20},
    title:`TF network for ${ct}`
  };

  Plotly.newPlot('tfNetPlot_'+DOM,[posEdges,negEdges,shadowTrace,focusEdges,nodeTrace,glassHighlight],layout,PLOTLY_THEME.config)
    .then(gd=>{
      requestAnimationFrame(()=>Plotly.Plots.resize(gd));
      const defaultGene=plotNodes.find(n=>n.type==='target')?.id;
      drawTFNetBox(defaultGene);
      const nodeIndex=new Map();
      plotNodes.forEach((node,idx)=>nodeIndex.set(node.id,idx));
      const adjacency=new Map();
      displayEdges.forEach(edge=>{
        const src=String(edge.source);
        const tgt=String(edge.target);
        if(!adjacency.has(src)) adjacency.set(src,new Set());
        if(!adjacency.has(tgt)) adjacency.set(tgt,new Set());
        adjacency.get(src).add(tgt);
        adjacency.get(tgt).add(src);
      });
      const baseOpacity=markerOpacity.slice();
      const baseSizes=markerSizes.slice();
      const baseLineWidths=lineWidths.slice();
      const highlightTraceIndex=3;
      const nodeTraceIndex=4;
      const glassHighlightIndex=5;
      const minOpacity=0.15;
      function clearHighlight(){
        Plotly.restyle(gd,{
          'marker.opacity':[baseOpacity],
          'marker.size':[baseSizes],
          'marker.line.width':[baseLineWidths]
        },[nodeTraceIndex]);
        Plotly.restyle(gd,{x:[[]],y:[[]]},[highlightTraceIndex]);
      }
      function setHighlight(focusId){
        if(!focusId||!nodeIndex.has(focusId)){
          clearHighlight();
          return;
        }
        const focusSet=new Set([focusId]);
        (adjacency.get(focusId)||new Set()).forEach(id=>focusSet.add(id));
        const newOpacity=plotNodes.map(n=>focusSet.has(n.id)?1:minOpacity);
        const newSizes=baseSizes.map((sz,idx)=>{
          const id=plotNodes[idx].id;
          return focusSet.has(id)?sz+4:Math.max(6,sz-2);
        });
        const newLineWidths=baseLineWidths.map((lw,idx)=>focusSet.has(plotNodes[idx].id)?lw+1:Math.max(1,lw-1));
        const hx=[];
        const hy=[];
        displayEdges.forEach(edge=>{
          const src=String(edge.source);
          const tgt=String(edge.target);
          if(focusSet.has(src)&&focusSet.has(tgt)){
            const sp=coordMap.get(src);
            const tp=coordMap.get(tgt);
            if(sp&&tp){
              hx.push(sp.x,tp.x,null);
              hy.push(sp.y,tp.y,null);
            }
          }
        });
        Plotly.restyle(gd,{
          'marker.opacity':[newOpacity],
          'marker.size':[newSizes],
          'marker.line.width':[newLineWidths]
        },[nodeTraceIndex]);
        Plotly.restyle(gd,{x:[hx],y:[hy]},[highlightTraceIndex]);
      }
      gd.on('plotly_hover',ev=>{
        const pt=ev?.points&&ev.points[0];
        if(pt&&pt.text){
          setHighlight(pt.text);
        }
      });
      gd.on('plotly_unhover',()=>{
        clearHighlight();
      });
      gd.on('plotly_relayout',()=>{
        clearHighlight();
      });
      gd.on('plotly_click',ev=>{
        const pt=ev?.points&&ev.points[0];
        if(pt&&pt.text){
          drawTFNetBox(pt.text);
          setHighlight(pt.text);
        }
      });
      clearHighlight();
    });
}

function drawTFNetBox(gene){
  const ct=$("#tfNetCelltypeSel_"+DOM).val();
  const raw=(TF_NET_BOX[ct]||{})[gene]||[];
  const cleaned=raw.map(entry=>({
    name:sanitizeMinusText(entry?.name),
    y:sanitizeNumericArray(entry?.y||[]),
    text:Array.isArray(entry?.text)?entry.text.map(sanitizeMinusText):sanitizeMinusText(entry?.text),
    marker:entry?.marker,
    line:entry?.line,
    color:entry?.color,
    fillcolor:entry?.fillcolor
  }));
  renderGsvaBoxPlot('tfNetBox_'+DOM,cleaned,{
    title:gene,
    yAxisTitle:'log1p counts',
    groupLabel:(TF_GSVA?.[ct]?.groupLabel)||'',
    fdrValue:null
  });
}

const VOLCANO_COLORS_DEFAULT = {
  nonsignificant: {fill: 'rgba(54,162,235,0.7)', line: 'rgba(54,162,235,1)'},
  significant: {fill: 'rgba(255,99,132,0.7)', line: 'rgba(255,99,132,1)'}
};
const VOLCANO_COLORS_COLORBLIND = {
  nonsignificant: {fill: 'rgba(27,158,119,0.7)', line: 'rgba(27,158,119,1)'},
  significant: {fill: 'rgba(217,95,2,0.7)', line: 'rgba(217,95,2,1)'}
};
let VOLCANO_COLORS = VOLCANO_COLORS_DEFAULT;
// Now that volcano color constants are initialized, apply the initial color mode
applyColorMode(initialColorMode, {refresh:false});

function computeVolcanoPayload(cellType){
  const dge = materializeDge(cellType);
  const fallback = {
    volcanoTraces: [],
    boxData: {},
    boxDataTotal: 0,
    volcanoTotalPoints: 0,
    volcanoShownPoints: 0,
    volcanoGeneLimit: 0,
    defaultGene: null,
    groupLabel: '',
    geneStats: {}
  };
  if(!dge){
    return fallback;
  }
  const rows = dge._table || [];
  const geneStats = dge._geneStats || {};
  const groups = {
    nonsignificant: {x: [], y: [], text: [], customdata: []},
    significant: {x: [], y: [], text: [], customdata: []}
  };
  const epsilon = 1e-12;
  rows.forEach(row => {
    if(!row || typeof row !== 'object') return;
    const geneRaw = row.gene_symbol ?? row.gene;
    const gene = geneRaw ? sanitizeMinusText(geneRaw) : null;
    if(!gene) return;
    const log2fc = row.log2FoldChange;
    if(!Number.isFinite(log2fc)) return;
    const fdrVal = row.FDR;
    let fdr = Number.isFinite(fdrVal) && fdrVal >= 0 ? fdrVal : null;
    const target = (fdr !== null && fdr < VOLCANO_SIG_FDR) ? groups.significant : groups.nonsignificant;
    const clampedFdr = fdr === null ? null : Math.max(fdr, epsilon);
    const negLog10 = clampedFdr === null ? null : -Math.log10(clampedFdr);
    target.x.push(log2fc);
    target.y.push(Number.isFinite(negLog10) ? negLog10 : 0);
    target.text.push(gene);
    target.customdata.push(gene);
  });
  const traces = Object.entries(groups)
    .filter(([, data]) => data.x.length > 0)
    .map(([key, data]) => {
      const colors = VOLCANO_COLORS[key];
      return {
        type: 'scattergl',
        mode: 'markers',
        name: key === 'significant' ? `FDR<${VOLCANO_SIG_FDR}` : 'FDR≥0.05',
        hovertemplate: '%{text}<extra></extra>',
        x: data.x,
        y: data.y,
        text: data.text,
        customdata: data.customdata,
        marker: {
          size: 5,
          opacity: 0.7,
          color: colors.fill,
          line: {color: colors.line}
        }
      };
    });
  const shownPoints = traces.reduce((sum, trace) => sum + (Array.isArray(trace.x) ? trace.x.length : 0), 0);
  const boxData = dge.boxData || {};
  const groupNames = Array.isArray(dge.groupNames) ? dge.groupNames : [];
  const contrastLabel = dge.contrastLabel ?? '';
  const contrast = dge.contrast ?? contrastLabel;
  const comparison = dge.comparison ?? contrast;
  return {
    volcanoTraces: traces,
    boxData,
    boxDataTotal: dge.boxDataTotal ?? Object.keys(boxData).length,
    volcanoTotalPoints: dge.tableTotal ?? rows.length,
    volcanoShownPoints: shownPoints,
    volcanoGeneLimit: dge.tableLimit ?? rows.length,
    defaultGene: dge.defaultGene ?? null,
    groupLabel: dge.groupLabel ?? '',
    groupNames,
    contrastLabel,
    contrast,
    comparison,
    geneStats
  };
}


function getVolcanoPayload(cellType){
  if(VOLCANO_CACHE.has(cellType)){
    return VOLCANO_CACHE.get(cellType);
  }
  const payload = computeVolcanoPayload(cellType);
  VOLCANO_CACHE.set(cellType, payload);
  return payload;
}

function initVolcano(){
  const sel=document.getElementById('volcanoCelltype');
  DGE_CELLTYPES.forEach(ct=>{
    const opt=document.createElement('option'); opt.value=ct; opt.textContent=ct; sel.appendChild(opt);
  });
  sel.addEventListener('change', renderVolcano);
  const resetBtn=document.getElementById('volcanoReset');
  resetBtn.addEventListener('click',()=>Plotly.relayout('volcanoPlot',{xaxis:{autorange:true},yaxis:{autorange:true}}));
}

async function renderVolcano(){
  const ct=document.getElementById('volcanoCelltype').value;
  const res = getVolcanoPayload(ct);
  const volcanoCaptionEl=document.getElementById('volcanoCaption');
  if(volcanoCaptionEl){
    const captionText=buildContrastCaption(res);
    volcanoCaptionEl.textContent=captionText;
    volcanoCaptionEl.classList.toggle('d-none', !captionText);
  }
  const baseLayout={
    ...PLOTLY_THEME.layout,
    paper_bgcolor:'#ffffff',
    plot_bgcolor:'#ffffff',
    margin:{l:60,r:20,t:50,b:60},
    xaxis:{
      showline:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000',
      linecolor:'#000',
      automargin:true,
      zeroline:true,
      zerolinecolor:'#000',
      zerolinewidth:1,
      showgrid:true,
      gridcolor:'#e5e5e5'
    },
    yaxis:{
      showline:true,
      ticks:'outside',
      tickwidth:1,
      tickcolor:'#000',
      linecolor:'#000',
      automargin:true,
      showgrid:true,
      gridcolor:'#e5e5e5'
    },
    hoverlabel:{bgcolor:'#000',font:{color:'#fff',size:12}}
  };
  Plotly.react('volcanoPlot', res.volcanoTraces,
    {...baseLayout, xaxis:{...baseLayout.xaxis, title:'log2FC'}, yaxis:{...baseLayout.yaxis, title:'-log10(FDR)'}, hovermode:'closest'},
    PLOTLY_THEME.config);
  const plot=document.getElementById('volcanoPlot');
  plot.removeAllListeners && plot.removeAllListeners('plotly_click');
  function updateBox(gene){
    const cleaned=sanitizeBoxSeries(res.boxData[gene] || []);
    const stats = res.geneStats?.[gene];
    const fdrValue = stats ? sanitizeNumericValue(stats.FDR) : null;
    renderGsvaBoxPlot('volcanoBox',cleaned,{
      title:gene,
      yAxisTitle:'log1p counts',
      groupLabel:res.groupLabel||'',
      fdrValue
    });
  }
  updateBox(res.defaultGene);
  plot.on('plotly_click', ev => { updateBox(ev.points[0].customdata); });
}

function materializeDge(ct){
  const payload = DGE_DATA?.[ct];
  if(!payload) return null;
  if(!payload._decoded){
    const genes = Array.isArray(payload.genes) ? payload.genes : [];
    payload._genes = genes;
    payload._log2fc = payload.log2fc ? inflateArray(payload.log2fc, Float32Array) : new Float32Array(genes.length);
    payload._lr = payload.lr ? inflateArray(payload.lr, Float32Array) : new Float32Array(genes.length);
    payload._fdr = payload.fdr ? inflateArray(payload.fdr, Float32Array) : new Float32Array(genes.length);
    const table = [];
    const geneStats = {};
    for(let i=0;i<genes.length;i++){
      const gene = genes[i];
      const row = {
        gene_symbol: gene,
        log2FoldChange: payload._log2fc[i],
        LR: payload._lr[i],
        FDR: payload._fdr[i],
      };
      table.push(row);
      geneStats[gene] = row;
    }
    payload._table = table;
    payload._geneStats = geneStats;
    payload._decoded = true;
  }
  return payload;
}

function initDGE(){
  const sel=document.getElementById('dgeCelltype');
  DGE_CELLTYPES.forEach(ct=>{
    const opt=document.createElement('option'); opt.value=ct; opt.textContent=ct; sel.appendChild(opt);
  });
  sel.addEventListener('change', renderDGE);
}

function inferDgeGroupNames(boxData){
  if(!boxData || typeof boxData !== 'object') return [];
  for(const value of Object.values(boxData)){
    if(!Array.isArray(value) || !value.length) continue;
    const seen = new Set();
    const names = [];
    value.forEach(entry=>{
      const raw = entry && entry.name;
      if(!raw) return;
      const clean = sanitizeMinusText(raw);
      if(!clean || seen.has(clean)) return;
      seen.add(clean);
      names.push(clean);
    });
    if(names.length) return names;
  }
  return [];
}

function buildContrastCaption(payload){
  if(!payload || typeof payload !== 'object') return '';
  const directRaw = payload.contrastLabel || payload.contrast || payload.comparison;
  const direct = directRaw ? sanitizeMinusText(directRaw) : '';
  if(direct){
    return `Contrast — ${direct}`;
  }
  const groupLabel = payload.groupLabel ? sanitizeMinusText(payload.groupLabel) : '';
  let groupNames = [];
  if(Array.isArray(payload.groupNames)){
    const seen = new Set();
    payload.groupNames.forEach(name => {
      const clean = sanitizeMinusText(name);
      if(clean && !seen.has(clean)){
        seen.add(clean);
        groupNames.push(clean);
      }
    });
  }
  if(!groupNames.length){
    groupNames = inferDgeGroupNames(payload.boxData);
  }
  if(groupLabel && groupNames.length){
    const connector = groupNames.length === 2 ? ' vs ' : ', ';
    return `Contrast — ${groupLabel}: ${groupNames.join(connector)}`;
  }
  if(groupLabel){
    return `Contrast — ${groupLabel}`;
  }
  if(groupNames.length){
    const connector = groupNames.length === 2 ? ' vs ' : ', ';
    return `Contrast — ${groupNames.join(connector)}`;
  }
  return '';
}

function renderDGE(){
  const ct=document.getElementById('dgeCelltype').value;
  const res=materializeDge(ct);
  const tbl=$('#dgeTable');
  const fmt=x=>Number.isFinite(x)?Number.parseFloat(x).toPrecision(3):'';
  const rows = res?res._table.slice():[];
  rows.sort((a,b)=>Math.abs(b.LR)-Math.abs(a.LR));
  let html='<thead><tr><th>Gene</th><th>log2FoldChange</th><th>abs(LR)</th><th>FDR</th></tr></thead><tbody>';
  rows.forEach(r=>{
    const lr=Math.abs(r.LR);
    const fdr=Number.isFinite(r.FDR)?r.FDR:null;
    html+=`<tr data-gene="${r.gene_symbol}"><td>${r.gene_symbol}</td><td data-order="${r.log2FoldChange}">${fmt(r.log2FoldChange)}</td><td data-order="${lr}">${fmt(lr)}</td><td data-order="${fdr ?? ''}">${fmt(fdr)}</td></tr>`;
  });
  html+='</tbody>';
  tbl.html(html);
  const captionText=buildContrastCaption(res);
  const tableEl=document.getElementById('dgeTable');
  if(tableEl){
    const existingCaption=document.getElementById('dgeTableCaption');
    if(existingCaption){
      existingCaption.remove();
    }
    const captionEl=document.createElement('caption');
    captionEl.id='dgeTableCaption';
    captionEl.className='contrast-caption text-muted small';
    captionEl.setAttribute('aria-live','polite');
    captionEl.textContent=captionText || '';
    if(!captionText){
      captionEl.classList.add('d-none');
    }
    tableEl.insertAdjacentElement('afterbegin', captionEl);
  }
  if($.fn.DataTable){
    if(tbl.hasClass('dataTable')) tbl.DataTable().destroy();
    tbl.on('init.dt', function(){
      $(this).closest('.dataTables_wrapper').css({'max-height':'calc(100vh - 300px)','overflow':'auto'}).find('.dt-buttons').addClass('float-end mb-2');
    });
    const buttons = $.fn.DataTable.Buttons ? [{extend:'csv', filename:'dge_'+ct}] : [];
    tbl.DataTable({paging:false,searching:true,info:false,ordering:true,order:[[2,'desc']],columnDefs:[{targets:[1,2,3],type:'num'}],fixedHeader:true,autoWidth:false,dom:'Bfrtip',buttons:buttons});
  }
  const geneStatsMap = res?res._geneStats:{};
  function updateBox(gene){
    const series = sanitizeBoxSeries(res?.boxData?.[gene] || []);
    const stats = geneStatsMap ? geneStatsMap[gene] : null;
    const fdrValue = stats ? sanitizeNumericValue(stats.FDR) : null;
    renderGsvaBoxPlot('dgeBox', series, {
      title: gene,
      yAxisTitle: 'log1p counts',
      groupLabel: res?.groupLabel || '',
      fdrValue
    });
  }
  $('#dgeTable tbody').off('click','tr').on('click','tr',function(){updateBox($(this).data('gene'));});
  if(res && res.defaultGene){
    updateBox(res.defaultGene);
  } else if(rows.length){
    updateBox(rows[0].gene_symbol);
  } else {
    renderGsvaBoxPlot('dgeBox', [], {title:'', yAxisTitle:'log1p counts', groupLabel:'', fdrValue:null});
  }
}

function parseHash(){
  const params=new URLSearchParams(window.location.hash.slice(1));
  return {tab:params.get('tab'), sub:params.get('sub')};
}
function setHash(tab, sub){
  const params=new URLSearchParams();
  if(tab) params.set('tab', tab);
  if(sub) params.set('sub', sub);
  window.location.hash = params.toString();
}
function showTab(tab, sub){
  let targetTab=tab;
  let targetSub=sub;
  if(targetTab && targetTab!=='btm'){
    if(targetTab==='hallmarks' || targetTab==='tf'){
      activeEnrichmentSource=targetTab;
      targetTab='btm';
    } else if(Object.prototype.hasOwnProperty.call(GENESET_TABS, targetTab)){
      activeEnrichmentSource=targetTab;
      targetTab='btm';
    }
  }
  if(targetTab==='btm' && targetSub){
    if(targetSub==='hallmarks' || targetSub==='tf' || Object.prototype.hasOwnProperty.call(GENESET_TABS, targetSub)){
      activeEnrichmentSource=targetSub;
    } else {
      targetSub='';
    }
  }
  if(targetTab==='btm' && !targetSub && activeEnrichmentSource && activeEnrichmentSource!=='btm'){
    targetSub=activeEnrichmentSource;
  }
  tab=targetTab;
  sub=targetSub;
  if(currentTab && tab!==currentTab && document.querySelectorAll('.gl-container').length>CONTEXT_BUDGET){
    if(currentTab==='umapobs'){
      if(purgePlotsIn('#umapObsGrid_'+DOM)) umapObsPurged=true;
    }
  }
  $('.nav.nav-tabs .nav-link').removeClass('active');
  $(`.nav.nav-tabs .nav-link[data-tab='${tab}']`).addClass('active');
  $('.tabpane').removeClass('show');
  $('#'+tab).addClass('show');
  currentTab=tab;
  currentSub=sub||'';
  if(tab==='btm'){
    activateEnrichmentSource(activeEnrichmentSource||'btm');
  } else if(Object.prototype.hasOwnProperty.call(geneSetInit, tab)){
    ensureGeneSetInitialized(tab);
  }
  if(tab==='tfnet'&&!tfNetInit){populateTFNetCelltypes(); tfNetInit=true;}
  if(tab==='volcano' && !volcanoInit){ initVolcano(); volcanoInit=true; }
  if(tab==='dge' && !dgeInit){ initDGE(); dgeInit=true; }
  if(tab==='biology'&&!biologyInit){drawBiologyUMAP(); biologyInit=true;}
  if(tab==='overview'&&!overviewInit){overviewInit=true;}
  if(tab==='umap') plotClusters();
  if(tab==='umapobs'){ void drawUmapObs(); umapObsPurged=false;}
  if(tab==='tfnet') drawTFNetwork();
  if(tab==='volcano') renderVolcano();   // re-draw when returning
  if(tab==='dge') renderDGE();
}
window.addEventListener('hashchange',()=>{const {tab,sub}=parseHash(); if(tab) showTab(tab,sub);});
const HELP_CONTENT={
  overview:`<h5>Summary Dashboard</h5>
<p><strong>Goal:</strong> Get a narrative overview of the dataset before diving into individual plots.</p>
<p><strong>Layout highlights:</strong> The hero section reports sample size, tissue descriptor, and quick links to pathway and AI tabs. Below that, the per-cell-type quick card cycles through annotations, markers, and QC notes; optional sections (alerts, hypotheses, regulators, etc.) appear only when the export produced them.</p>
<p><strong>How to work with it:</strong> Start here when you load a new HTML build. Read the hero description to recall the biological question, then click the cell-type pills to verify the automated labels and markers. Review the alert and robustness sections to catch data-quality warnings before interpreting downstream plots.</p>
<p><strong>Tips for new researchers:</strong> Treat this page as a study plan: note unfamiliar pathways or regulators and follow the shortcut buttons to inspect them in the enrichment tabs. If the overview narrative looks wrong, revisit the upstream annotations before quoting it in a report.</p>`,
  dge:`<h5>Differential Expression (edgeR)</h5>
<p><strong>Goal:</strong> Inspect edgeR TMM-normalised pseudobulk results one cell type at a time.</p>
<p><strong>Table:</strong> Sorted by |LR| (likelihood-ratio). Columns show log2 fold change (positive = enriched in the first group defined by <code>Group_var</code>), |LR| (strength of evidence), and FDR (multiple-testing corrected p value). Use the search box to filter, and click a gene to update the box plot.</p>
<p><strong>Box plot:</strong> Displays log1p TMM-normalised counts per sample for the selected gene, grouped by the experimental condition. Box limits summarise the sample distribution; each dot is one pseudobulk sample.</p>
<p><strong>Workflow:</strong> Pick a cell type, scan for genes with FDR < 0.05 and sizable log2 fold change, then click them to confirm that expression separates the groups in the box plot. Use the CSV button to take candidates into R or Python, and the box plot's camera icon to save an SVG snapshot for reports.</p>
<p><strong>Tips:</strong> Combine this view with the UMAP tab: genes that are significant here but diffuse on UMAP may reflect broad activation rather than cluster-specific markers.</p>`,
  volcano:`<h5>Volcano Plot</h5>
<p><strong>Goal:</strong> Quickly spot genes with both strong effect size and statistical support.</p>
<p><strong>Plot reading:</strong> Each point is a gene. The x axis is log2 fold change (right = higher in the test group, left = higher in the reference group). The y axis is -log10(FDR); higher values mean smaller FDR. Points with FDR < 0.05 are highlighted in red.</p>
<p><strong>Interactions:</strong> Select a cell type, hover for gene IDs, and click a point to load its per-sample expression box plot on the right. Use the reset button after zooming to restore the automatic axes.</p>
<p><strong>Exports:</strong> Use the plot toolbar camera icon to save the volcano scatter and box plots as SVG files. The DGE tab's CSV download contains the same log2FC, LR, and FDR values that drive this view.</p>
<p><strong>Tips:</strong> Genes in the top corners tend to be strong markers. If you see many symmetric points near x = 0, the contrast may be weak; revisit the grouping variable or filtering.</p>`,
  umap:`<h5>Clusters and Genes</h5>
<p><strong>Goal:</strong> Explore how annotated clusters line up with gene expression on the shared UMAP embedding.</p>
<p><strong>Panels:</strong> The left map shows clusters coloured by the exported annotations. The right map paints per-cell RNA expression for the gene you type.</p>
<p><strong>Controls:</strong> Start typing a gene symbol (autocomplete uses the marker list) and press Enter. Use <em>Plot clusters</em> whenever upstream filters change. Zoom or hover to inspect cluster labels and cell IDs.</p>
<p><strong>Interpretation:</strong> Warm colours indicate higher scaled expression. Check that canonical markers peak in the expected clusters and that rare populations are not doublets.</p>
<p><strong>Exports:</strong> The plot toolbar camera icon on each panel saves a high-resolution SVG, handy when you need to drop the UMAPs into slide decks.</p>
<p><strong>Tips:</strong> Cycle through several markers for the same lineage to confirm annotation consistency before accepting automated labels.</p>`,
  umapobs:`<h5>Sample / Condition Breakdown</h5>
<p><strong>Goal:</strong> Test whether a gene behaves differently across donors, conditions, or any categorical metadata.</p>
<p><strong>Views:</strong> UMAP facets show one panel per group with highlighted cells; violin plots summarise the expression distribution per group.</p>
<p><strong>Controls:</strong> Choose a <em>Group by</em> field, type a feature, then switch between UMAP and violin views. <em>Show background</em> keeps the full dataset in grey, <em>Points</em> toggles outlier overlays, and <em>Jitter</em> spreads overlapping cells.</p>
<p><strong>Interpretation:</strong> In facet view, look for panels with brighter colours or different locations. In the violin view, a higher median or longer tail indicates higher expression for that group.</p>
<p><strong>Exports:</strong> Use the camera icon in the toolbar to capture either the faceted UMAP grid or the violin summary as SVG files for presentations.</p>
<p><strong>Tips:</strong> Start with facets for spatial context, then confirm trends with the violin plot before reporting group differences.</p>`,
  btm:`<h5>Enrichment Explorer</h5>
<p><strong>Goal:</strong> Compare pathway programs across BTM modules, Hallmark signatures, transcription-factor regulons, and any custom libraries shipped with the export.</p>
<p><strong>Layout:</strong> Use the pill-shaped toggle above the plots to switch datasets. Each option keeps the same layout: a ranked enrichment chart on the left and a GSVA distribution box plot on the right.</p>
<p><strong>Controls:</strong> Pick the stats engine (GSEA-like ULM versus GSVA sample scores), choose a cell type, adjust the number of terms, and swap between bar or dot visuals. Click a pathway or regulon to refresh the GSVA box plot.</p>
<p><strong>Stats modes:</strong> GSEA (ULM) ranks genes across the contrast to yield a signed enrichment score (positive = higher in the first group) that spotlights pathways with consistent directionality. GSVA recalculates enrichment for each sample and then tests those distributions, making it better for highlighting donor-to-donor heterogeneity or bimodal programmes.</p>
<p><strong>Exports:</strong> The Download CSV button beside the GSVA panel saves the ranked table for the active library, and the plot toolbar camera icon turns either chart into an SVG.</p>
<p><strong>Tips:</strong> Start with BTM modules for a high-level immune readout, pivot to Hallmarks for broad programmes, and confirm upstream drivers in the TF view. Custom tabs inherit the same workflow so collaborators can add bespoke libraries without changing the muscle memory.</p>`,
  hallmarks:`<h5>Hallmark Pathway Enrichment</h5>
<p><strong>Goal:</strong> Track broad cellular programs using the 50 MSigDB Hallmark gene sets.</p>
<p><strong>Plots:</strong> The left chart mirrors the BTM view: scores along the axis, -log10 adjusted p value as colour, and black borders for significant terms. The right box plot shows GSVA activity per sample.</p>
<p><strong>Controls:</strong> Swap between GSEA and GSVA statistics, pick a cell type, and change how many pathways are shown. Use the <em>Gene set</em> autocomplete to jump directly to a pathway.</p>
<p><strong>Stats modes:</strong> GSEA (ULM) leans on the pseudobulk contrast to report a signed enrichment score and FDR for pathways that shift together, whereas GSVA scores each sample first and compares those distributions to surface variability within a group.</p>
<p><strong>Exports:</strong> Use the Download CSV button to capture the Hallmark table for offline analysis, and the plot toolbar camera icon to export either chart as an SVG.</p>
<p><strong>Tips:</strong> Hallmarks are intentionally non-redundant; pair them with BTM modules to separate immune activation from stress or cell-cycle responses.</p>`,
  tf:`<h5>TF Enrichment</h5>
<p><strong>Goal:</strong> Identify transcription factors whose regulons are enriched in a cell type.</p>
<p><strong>Plots:</strong> The left chart ranks regulons by ULM score (GSEA mode) or GSVA statistic (GSVA mode); colour reflects -log10 adjusted p value and outlines flag significant results. The right box plot shows GSVA regulon activity per sample.</p>
<p><strong>Stats modes:</strong> GSEA (ULM) aggregates log fold changes into a signed enrichment score for the contrast, ideal when you want directionality. GSVA recomputes regulon activity per sample before comparing groups, making it better for spotting donor-specific or heterogeneous TF programmes.</p>
<p><strong>Workflow:</strong> Pick a cell type, review the top regulons, and click interesting TFs to inspect variability across donor groups. GSVA mode highlights between-sample heterogeneity.</p>
<p><strong>Exports:</strong> Download the regulon table as CSV with the button next to the GSVA plot, and use the toolbar camera icon to save either plot as an SVG.</p>
<p><strong>Tips:</strong> Regulons that are significant and specifically active point to upstream drivers; double-check them in the TF network tab before prioritising experiments.</p>`,
  receptor:`<h5>Receptor Enrichment</h5>
<p><strong>Goal:</strong> Identify receptors whose downstream signaling activities are enriched in a cell type, based on the RIDDEN receptor interaction model.</p>
<p><strong>Plots:</strong> The left chart ranks receptor activities by ULM score (GSEA mode) or GSVA statistic (GSVA mode); colour reflects -log10 adjusted p value and outlines flag significant results. The right box plot shows GSVA receptor activity per sample.</p>
<p><strong>Stats modes:</strong> GSEA (ULM) aggregates log fold changes into a signed enrichment score for the contrast, capturing receptor-mediated signaling directionality. GSVA recomputes receptor activity per sample before comparing groups, revealing donor-specific or heterogeneous receptor signaling patterns.</p>
<p><strong>Workflow:</strong> Select a cell type, review the top enriched receptors, and click on receptors of interest to inspect activity variability across donor groups. GSVA mode highlights between-sample heterogeneity in receptor signaling.</p>
<p><strong>Exports:</strong> Download the receptor activity table as CSV with the button next to the GSVA plot, and use the toolbar camera icon to save either plot as an SVG.</p>
<p><strong>Tips:</strong> Receptors that show significant and specific enrichment may indicate important cell-cell communication events or responses to microenvironmental cues. Cross-reference with ligand expression patterns for complete interaction insights.</p>`,
  tfnet:`<h5>TF Network</h5>
<p><strong>Goal:</strong> Visualise the strongest TF-to-target links inferred for the chosen cell type.</p>
<p><strong>Diagram:</strong> <span data-color-desc="default">Squares represent transcription factors, circles are target genes. Node colour reflects log fold change (red = higher in the test group, blue = higher in the reference group). Green edges indicate positive influence; red edges indicate negative influence.</span> <span data-color-desc="colorblind" class="d-none">Squares represent transcription factors, circles are target genes. Node colour reflects log fold change using a purple–orange scale (purple = higher in the test group, orange = higher in the reference group). Teal edges indicate positive influence; orange edges indicate negative influence.</span> Hovering highlights neighbours and clicking a node updates the expression box plot on the right.</p>
<p><strong>Controls:</strong> Tune <em>Top TFs</em> to limit how many regulators are shown and <em>Targets</em> to set the number of targets per TF. Use <em>Reset</em> to restore the default layout.</p>
<p><strong>Exports:</strong> The toolbar camera icon lets you save both the network snapshot and the expression box plot as SVG files for slide decks.</p>
<p><strong>Tips:</strong> Focus on TFs whose targets share the same colour sign, then verify their activity in the TF enrichment tab.</p>`,
  biology:`<h5>AI Insights</h5>
<p><strong>Goal:</strong> Read a draft narrative assembled from markers, enrichment results, and QC findings.</p>
<p><strong>Layout:</strong> The UMAP on the left recaps cluster locations. The right-hand panel lists sections such as executive summaries, key markers, enriched processes, candidate regulators, hypotheses, and references (sections appear only when the inputs exist).</p>
<p><strong>How to use:</strong> Treat the generated text as a starting point: copy the parts you need, edit the language to match lab conventions, and cross-check every statement against the relevant tabs (UMAP, DGE, BTM, Hallmarks, TF). Use the <em>Download table</em> button to capture the content for offline editing.</p>
<p><strong>Exports:</strong> The download button saves a CSV of the narrative by cluster, and the UMAP toolbar camera icon exports an SVG if you need the layout for slides.</p>
<p><strong>Tips:</strong> Document any manual edits so you can reproduce them later. If a section is empty, confirm that upstream analyses produced the required inputs.</p>`,
  methods:`<h5>Methods Documentation</h5>
<p><strong>Goal:</strong> Capture how this dashboard build was produced so you can reproduce or describe it in a manuscript.</p>
<p><strong>Contents:</strong> The prose summarises data inputs, preprocessing choices, pseudobulk differential expression, gene-set scoring, AI prompts, and runtime metadata. Code-style names (for example <code>AnnData</code>, <code>decoupler</code>) map to the notebook that exported this HTML.</p>
<p><strong>How to use:</strong> Cite relevant sentences when writing up your study, and update the text if you change the pipeline. Check that file paths and parameter names match the run you are sharing.</p>
<p><strong>Tips:</strong> Keep a changelog of edits alongside this description so collaborators know which HTML snapshot they are viewing.</p>`,
  about:`<h5>About and Support</h5>
<p><strong>Goal:</strong> Provide context for collaborators and point them to the right contacts.</p>
<p><strong>Sections:</strong> Toolkit highlights summarise available analysis modules, dataset metadata records the sample name, layer, and cell count, contributor cards list points of contact, and the legal block documents licences and disclaimers.</p>
<p><strong>How to use:</strong> Update contributor details and dataset notes before sharing the dashboard outside your lab. Direct readers here for licensing terms and recommended citations.</p>
<p><strong>Tips:</strong> If you plan to publish the dataset, replace placeholder text with the official citation and ensure the licence labels match your data-use agreement.</p>`
};


if(HAS_PROT){
  HELP_CONTENT.umap=`<h5>Clusters, RNA and Protein</h5>
<p><strong>Goal:</strong> Compare RNA and surface protein abundance on the same cells.</p>
<p><strong>Panels:</strong> Clusters on the left, RNA expression in the middle, protein expression on the right (shown when features are available).</p>
<p><strong>Controls:</strong> Use the Modality toggle to switch between RNA, protein, or both; <em>Link ranges</em> forces RNA and protein colour scales to share limits so differences reflect biology rather than scaling. <em>Plot clusters</em> refreshes the base map after upstream filters change.</p>
<p><strong>Interpretation:</strong> Concordant RNA and protein patterns reinforce confident annotations, whereas mismatches can reveal post-transcriptional regulation or technical issues.</p>
<p><strong>Exports:</strong> Grab SVG snapshots for RNA, protein, or blended views via the plot toolbar camera icon on each panel.</p>
<p><strong>Tips:</strong> When both layers agree, you have strong marker candidates. If protein is sharper than RNA, prefer it for follow-up sorting experiments.</p>`;
  HELP_CONTENT.umapobs=`<h5>Sample / Condition Breakdown</h5>
<p><strong>Goal:</strong> Test whether a gene or protein behaves differently across donors, conditions, or any categorical metadata.</p>
<p><strong>Modality:</strong> Switch between RNA and protein features; the autocomplete updates to the correct feature list.</p>
<p><strong>Views:</strong> UMAP facets show one panel per group with highlighted cells; violin plots summarise the expression distribution per group.</p>
<p><strong>Controls:</strong> Choose a <em>Group by</em> field, type a feature, then switch between UMAP and violin views. <em>Show background</em> keeps the full dataset in grey, <em>Points</em> toggles outlier overlays, and <em>Jitter</em> spreads overlapping cells.</p>
<p><strong>Interpretation:</strong> In facet view, look for panels with brighter colours or different locations. In the violin view, a higher median or longer tail indicates higher expression for that group.</p>
<p><strong>Exports:</strong> Use the toolbar camera icon to save the modality-specific UMAP facets or violin plot as SVG files before sharing.</p>
<p><strong>Tips:</strong> Start with facets for spatial context, then confirm trends with the violin plot before reporting group differences.</p>`;
}

const TOUR_STEPS = {
  umap: () => [
    { selector: `#geneInput_${DOM}`, text: "Type a gene symbol in the RNA search box and press Enter to map expression across the UMAP." },
    { selector: `#plotCluster_${DOM}`, text: "Click Plot clusters after filtering to redraw the reference map before comparing expression." },
    { selector: `#clusterPlot_${DOM}`, text: "Hover the cluster map to inspect annotations and confirm where the signal localises." }
  ],
  btm: () => [
    { selector: `#enrichmentToggle_${DOM}`, text: "Switch between BTM, Hallmark, TF, or custom libraries with this toggle." },
    { selector: `#btmCelltypeSel_${DOM}`, text: "Choose the cell type and adjust stats, view, and top N to shape the ranked pathway list." },
    { selector: `#btmPlot_${DOM}`, text: "Click a bar or dot in the enrichment plot to refresh the matching GSVA box plot on the right." }
  ],
  biology: () => [
    { selector: `#aiInsightsUMAP_${DOM}`, text: "Use the overview UMAP to keep spatial context in mind while you read the narrative." },
    { selector: `#downloadInsightsBtn`, text: "Download the AI-generated summary if you need to edit or share it offline." },
    { selector: `#biologyContent`, text: "Read the generated insights here and cross-check each section against the other tabs." }
  ]
};
const TOUR_PADDING = 14;
let tourStepsState = [];
let tourStepIndex = 0;
let tourHighlightTarget = null;
let tourFrameEl = null;
let tourStoredOverflow = null;
let tourRepositionHandler = null;

function ensureTourFrame(){
  if(!tourFrameEl){
    tourFrameEl = document.getElementById('tourFrame');
  }
  return tourFrameEl;
}
function isZeroRadius(value){
  return !value || /^0(?:px)?(?:\s+0(?:px)?)*$/.test(value);
}
function computeTourRadius(target){
  const style = window.getComputedStyle(target);
  const radius = style.borderRadius;
  if(isZeroRadius(radius)){
    return '18px';
  }
  return radius;
}
function positionTourFrame(target){
  const frame = ensureTourFrame();
  if(!frame || !target){
    return;
  }
  const rect = target.getBoundingClientRect();
  if(rect.width === 0 && rect.height === 0){
    frame.style.display = 'none';
    return;
  }
  const padding = TOUR_PADDING;
  frame.style.display = 'block';
  frame.style.width = `${rect.width + padding * 2}px`;
  frame.style.height = `${rect.height + padding * 2}px`;
  frame.style.left = `${rect.left - padding}px`;
  frame.style.top = `${rect.top - padding}px`;
  frame.style.borderRadius = computeTourRadius(target);
}
function scheduleTourFrame(target){
  if(!target){
    return;
  }
  window.requestAnimationFrame(()=>{
    positionTourFrame(target);
    window.requestAnimationFrame(()=>positionTourFrame(target));
  });
}
function hideTourFrame(){
  const frame = ensureTourFrame();
  if(frame){
    frame.style.display = 'none';
  }
  tourHighlightTarget = null;
}
function attachTourObservers(){
  if(tourRepositionHandler){
    return;
  }
  tourRepositionHandler = () => {
    if(!tourHighlightTarget){
      return;
    }
    window.requestAnimationFrame(()=>positionTourFrame(tourHighlightTarget));
  };
  window.addEventListener('resize', tourRepositionHandler);
  window.addEventListener('scroll', tourRepositionHandler, true);
}
function detachTourObservers(){
  if(!tourRepositionHandler){
    return;
  }
  window.removeEventListener('resize', tourRepositionHandler);
  window.removeEventListener('scroll', tourRepositionHandler, true);
  tourRepositionHandler = null;
}
function resolveTourSteps(key){
  const entry = TOUR_STEPS[key];
  if(!entry){
    return [];
  }
  const steps = typeof entry === 'function' ? entry() : entry;
  return Array.isArray(steps) ? steps : [];
}
function updateTourStep(index){
  if(!tourStepsState.length){
    return;
  }
  const step = tourStepsState[index];
  if(!step){
    return;
  }
  tourStepIndex = index;
  if(step.html){
    $('#tourText').html(step.html);
  } else {
    $('#tourText').text(step.text || '');
  }
  $('#tourNext').text(index === tourStepsState.length - 1 ? 'Done' : 'Next');
  const target = step.selector ? document.querySelector(step.selector) : null;
  tourHighlightTarget = target || null;
  if(target){
    target.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
    scheduleTourFrame(target);
  } else {
    hideTourFrame();
  }
}
function resetTourState(){
  hideTourFrame();
  detachTourObservers();
  tourStepsState = [];
  tourStepIndex = 0;
}
function endTour(){
  if($('#tourOverlay').hasClass('show')){
    $('#tourOverlay').removeClass('show').attr('aria-hidden','true');
    $('#tourNext').off('click');
    $('#tourText').empty();
  }
  if(tourStoredOverflow !== null){
    document.body.style.overflow = tourStoredOverflow;
    tourStoredOverflow = null;
  }
  document.body.classList.remove('tour-active');
  resetTourState();
}
function getHelpKey(){
  const tab=$('.nav.nav-tabs .nav-link.active').data('tab');
  return {tab,sub:'',key:tab};
}
function startTour(key){
  const steps = resolveTourSteps(key).filter(step=>{
    if(!step) return false;
    if(!step.selector) return true;
    return Boolean(document.querySelector(step.selector));
  });
  if(!steps.length){
    return;
  }
  endTour();
  tourStepsState = steps;
  tourStepIndex = 0;
  tourStoredOverflow = document.body.style.overflow || '';
  document.body.style.overflow = 'hidden';
  document.body.classList.add('tour-active');
  $('#tourOverlay').addClass('show').attr('aria-hidden','false');
  attachTourObservers();
  updateTourStep(0);
  $('#tourNext').off('click').on('click', function(){
    const nextIndex = tourStepIndex + 1;
    if(nextIndex < tourStepsState.length){
      updateTourStep(nextIndex);
    } else {
      endTour();
    }
  });
  $('#tourNext').trigger('focus');
}
function plotClusters(){
  drawUMAP();
  const g=$('#geneInput_'+DOM).val(); if(g) void drawGeneTo('genePlot_'+DOM,g);
  const p=$('#proteinInput_'+DOM).val(); if(p) drawProteinTo('protPlot_'+DOM,p);
}
$(function(){
  if(!SUMMARY_ENABLED){
    $(".nav.nav-tabs .nav-link[data-tab='overview']").closest('li').remove();
    $('#overview').remove();
  }
  populateGenes();
  populateProteins();
  const colorToggle=document.getElementById('colorblindToggle_'+DOM);
  if(colorToggle){
    colorToggle.checked = COLOR_MODE === 'colorblind';
    colorToggle.addEventListener('change',()=>{
      applyColorMode(colorToggle.checked ? 'colorblind' : 'default');
    });
  }
  const rand=GENES[Math.floor(Math.random()*GENES.length)];
  $("#geneInput_"+DOM).val(rand);
  if(PROT_GENES.length===0){
      $('.protCtrl').hide();
      $('#clustCol_'+DOM+',#rnaCol_'+DOM).removeClass('col-lg-4').addClass('col-lg-6');
    } else {
      setUMAPView('BOTH');
      $('#viewBOTH_'+DOM).prop('checked',true);
      $('#viewToggle_'+DOM+' input').on('change',function(){setUMAPView(this.value);});
      const p0=PROT_GENES[0];
      $("#proteinInput_"+DOM).val(p0);
    }
    populateObsGroupBy();
    $('#obsGroupSel_'+DOM).on('change',()=>{ void drawUmapObs(); });
    $('#obsShowBackground_'+DOM).on('change',()=>{ void drawUmapObs(); });
    $('#umapObsPoints_'+DOM).on('change',()=>{ void drawUmapObs(); });
    $('#umapObsJitter_'+DOM).on('change',()=>{ void drawUmapObs(); });
    $('input[name="umapObsView_'+DOM+'"]').on('change',()=>{ void drawUmapObs(); });
    $('#umapObsFeat_'+DOM)
      .attr('list','geneList_'+DOM)
      .on('input',()=>{ umapObsGeneConfirmed=false; })
      .on('change',()=>{ umapObsGeneConfirmed=true; void drawUmapObs(); });
    $('#umapObsPlot_'+DOM).on('click',()=>{ umapObsGeneConfirmed=true; void drawUmapObs(); });
    if(HAS_PROT){
      $('#umapObsMod_'+DOM).on('change',function(){
        const m=$(this).val();
        $('#umapObsFeat_'+DOM).attr('list', m==='RNA' ? 'geneList_'+DOM : 'protList_'+DOM);
        setRandomUmapObsFeature(m);
        void drawUmapObs();
      }).val('RNA');
    }
    setRandomUmapObsFeature('RNA');
    $('#linkRanges_'+DOM).on('change',function(){
      if(this.checked){
        const cp=document.getElementById('clusterPlot_'+DOM);
        if(cp&&cp.layout){
          const xr=cp.layout.xaxis.range, yr=cp.layout.yaxis.range;
          SYNC_IDS.forEach(o=>{if(o!==cp.id) Plotly.relayout(o,{'xaxis.range':xr,'yaxis.range':yr});});
      }
    }
  });
  setupGeneSetTabs();
  Object.keys(GENESET_TABS).forEach(key=>bindGeneSetEvents(key));
  $('#enrichmentToggle_'+DOM).on('change', `input[name="enrichmentSource_${DOM}"]`, function(){
    if(this.checked){
      activateEnrichmentSource(this.value);
    }
  });
  activateEnrichmentSource(activeEnrichmentSource);
  $("#hallmarkCelltypeSel_"+DOM).on("change",drawHallmark);
  $("#hallmarkStatSel_"+DOM).on("change",drawHallmark);
  $("#hallmarkVisSel_"+DOM).on("change",drawHallmark);
  $("#hallmarkTopSel_"+DOM).on("change",drawHallmark);
  $("#hallmarkGsvaInput_"+DOM).on("input",drawHallmarkBox);
  $("#hallmarkGsvaDownload_"+DOM).on("click",downloadHallmarkGsvaCSV);
  $("#tfCelltypeSel_"+DOM).on("change",drawTF);
  $("#tfStatSel_"+DOM).on("change",drawTF);
  $("#tfVisSel_"+DOM).on("change",drawTF);
  $("#tfTopSel_"+DOM).on("change",drawTF);
  $("#tfGsvaInput_"+DOM).on("input",drawTFBox);
  $("#tfGsvaDownload_"+DOM).on("click",downloadTfGsvaCSV);
  $("#tfNetCelltypeSel_"+DOM).on("change",drawTFNetwork);
  $("#tfNetTopSel_"+DOM).on("change",drawTFNetwork);
  $("#tfNetTargetSel_"+DOM).on("change",drawTFNetwork);
  $("#tfNetReset_"+DOM).on("click",()=>{
    const topSel=$("#tfNetTopSel_"+DOM);
    const topDefault=topSel.data('default');
    if(topDefault!==undefined){
      topSel.val(String(topDefault));
    }
    const targetInput=$("#tfNetTargetSel_"+DOM);
    const targetDefault=targetInput.data('default');
    if(targetDefault!==undefined){
      targetInput.val(String(targetDefault));
    }
    drawTFNetwork();
  });
  $(".nav.nav-tabs .nav-link").on("click",function(e){
    e.preventDefault();
    const tab=$(this).data("tab");
    setHash(tab);
  });
  const init=parseHash();
  const hasSummaryTab=document.querySelector("a[data-tab='overview']") && document.getElementById('overview');
  const defaultTab=init.tab || (hasSummaryTab ? 'overview' : 'umap');
  showTab(defaultTab, init.sub);
  $("#plotCluster_"+DOM).on("click",plotClusters);
  let geneRAF=null;
  $("#geneInput_"+DOM).on("input",function(){
    const g=this.value;
    if(geneRAF) cancelAnimationFrame(geneRAF);
    geneRAF=requestAnimationFrame(()=>{
      const sym=baseGene(g);
      const fb=document.getElementById("geneFeedback_"+DOM);
      if(GENE_INDEX[sym] !== undefined){
        fb.textContent="";
        void drawGene(g).catch(err=>{
          console.error('Failed to render gene expression', err);
          fb.textContent = 'Failed to load expression';
        });
      } else {
        fb.textContent="No match";
      }
    });
  });
  $("#proteinInput_"+DOM).on("input",function(){
    const p=this.value;
    if(PROT_INDEX[p] !== undefined){ drawProteinTo("protPlot_"+DOM,p); }
    });
    function to_markdown(text){
      return marked.parse(text);
    }
    const biology_md = inflateExp(§BIOLOGY_MD);
    const overview_md = SUMMARY_ENABLED ? inflateExp(§OVERVIEW_MD) : '';
    const overview_json = SUMMARY_ENABLED ? inflateExp(§OVERVIEW_JSON) : null;
    const insightsBtn = $('#downloadInsightsBtn');
    const insightsBtnWrap = insightsBtn.closest('.d-flex');
    insightsBtnWrap.addClass('d-none');
    insightsBtn.prop('disabled', true);
    let biologyNarrative = '';
    let biologyJsonBlocks = [];
    const insightsSectionIndex = new Map();
    const insightsPayloadIndex = new Map();
    const insightsAlias = new Map();
    const insightsOrder = [];
    let activeInsightKey = null;
    let insightsDownloadRows = [];
    const insightsNarrativeSections = new Map();

    function isMeaningfulValue(value){
      if(value === null || value === undefined) return false;
      if(typeof value === 'string') return value.trim().length > 0;
      if(Array.isArray(value)) return value.some(item=>isMeaningfulValue(item));
      if(typeof value === 'object') return Object.keys(value).length > 0;
      return true;
    }

    function toList(value){
      if(!isMeaningfulValue(value)) return [];
      if(Array.isArray(value)){
        return value
          .map(item=>typeof item === 'string' ? item.trim() : item)
          .filter(item=>isMeaningfulValue(item));
      }
      if(typeof value === 'string'){
        const trimmed = value.trim();
        return trimmed ? [trimmed] : [];
      }
      return [value];
    }

    function pickPayloadValue(payload, ...keys){
      if(!payload || typeof payload !== 'object') return null;

      const toPath = value=>{
        if(Array.isArray(value)){
          return value.flatMap(item=>toPath(item));
        }
        if(value === null || value === undefined) return [];
        if(typeof value === 'number') return [value];
        return String(value).split('.').filter(Boolean);
      };

      for(const rawKey of keys){
        if(rawKey === null || rawKey === undefined) continue;
        const path = toPath(rawKey);
        if(!path.length) continue;

        let current = payload;
        let valid = true;
        for(const part of path){
          if(current == null || typeof current !== 'object' || !(part in current)){ valid = false; break; }
          current = current[part];
        }
        if(valid && isMeaningfulValue(current)){
          return current;
        }
      }
      return null;
    }

    function normalizeInsightPayload(payload){
      if(!payload || typeof payload !== 'object') return payload;
      const result = {...payload};

      const setIfMissing = (key, value, {asArray=false}={})=>{
        if(!isMeaningfulValue(value)) return;
        const current = result[key];
        if(isMeaningfulValue(current)) return;
        if(asArray){
          const arr = toList(value);
          if(arr.length) result[key] = arr;
        } else {
          result[key] = value;
        }
      };

      setIfMissing('executive_summary', pickPayloadValue(payload, 'executive_summary', 'summary', 'overview'));
      setIfMissing('key_findings', pickPayloadValue(payload, 'key_findings', 'key_findings_by_cell_type', 'findings', 'cell_state_annotation'), {asArray:true});

      const transcriptionalProfile = (result.transcriptional_profile && typeof result.transcriptional_profile === 'object') ? {...result.transcriptional_profile} : {};
      const legacyTopUp = pickPayloadValue(payload, ['transcriptional_profile','top_up'], 'top_up_genes', 'top_up', 'genes_up', 'up_genes');
      const legacyTopDown = pickPayloadValue(payload, ['transcriptional_profile','top_down'], 'top_down_genes', 'top_down', 'genes_down', 'down_genes');
      if(isMeaningfulValue(legacyTopUp)) transcriptionalProfile.top_up = toList(legacyTopUp);
      if(isMeaningfulValue(legacyTopDown)) transcriptionalProfile.top_down = toList(legacyTopDown);
      if(Object.keys(transcriptionalProfile).length){
        result.transcriptional_profile = transcriptionalProfile;
      }

      setIfMissing('enriched_processes', pickPayloadValue(payload, 'enriched_processes', 'enriched_processes_and_pathways_with_leading_edge_genes', 'enriched_processes_and_pathways', ['pathways','programs'], 'pathways', 'pathway_enrichment'), {asArray:true});
      setIfMissing('candidate_regulators', pickPayloadValue(payload, 'candidate_regulators', 'candidate_regulators_and_inferred_activities', 'candidate_regulators_and_inferred_activities_from_tf_enrichment', 'regulators'), {asArray:true});
      setIfMissing('disease_links', pickPayloadValue(payload, 'disease_links', 'disease_links_and_therapeutic_angles', 'disease'), {asArray:true});
      setIfMissing('hypotheses', pickPayloadValue(payload, 'hypotheses', 'top_hypotheses_and_proposed_validations'), {asArray:true});
      setIfMissing('references', pickPayloadValue(payload, 'references', 'references_to_papers', 'literature', 'citations', 'papers'), {asArray:true});

      if(!isMeaningfulValue(result.key_findings)){
        const legacyInteractions = pickPayloadValue(payload, 'likely_cell_cell_interactions_hypothesized', 'likely_cell_cell_interactions', 'cell_cell_interactions');
        if(isMeaningfulValue(legacyInteractions)){
          setIfMissing('key_findings', legacyInteractions, {asArray:true});
        }
      }

      return result;
    }

    function normalizeHarmonizedPayload(payload){
      const sectionKeys = ['executive_summary','key_findings','transcriptional_profile','enriched_processes','candidate_regulators','disease_links','hypotheses','references'];
      const aliasMap = {
        executive_summary: ['executive_summary','summary','overview'],
        key_findings: ['key_findings','findings','key_points'],
        transcriptional_profile: ['transcriptional_profile','transcriptionalprofile','transcriptional_profile_summary'],
        enriched_processes: ['enriched_processes','enriched_pathways','pathways','processes'],
        candidate_regulators: ['candidate_regulators','regulators','regulatory_candidates'],
        disease_links: ['disease_links','disease','disease_and_therapeutics'],
        hypotheses: ['hypotheses','validations','mechanistic_hypotheses'],
        references: ['references','literature','citations','papers']
      };
      const aliasSlugMap = {};
      Object.entries(aliasMap).forEach(([key, aliases])=>{
        aliasSlugMap[key] = new Set(aliases.map(slugifyKey));
      });
      const allSectionSlugs = new Set();
      Object.values(aliasSlugMap).forEach(set=>set.forEach(slug=>allSectionSlugs.add(slug)));

      const emptySections = ()=>({
        executive_summary: '',
        key_findings: [],
        transcriptional_profile: {top_up: [], top_down: []},
        enriched_processes: [],
        candidate_regulators: [],
        disease_links: [],
        hypotheses: [],
        references: []
      });

      const canonicalKey = value => {
        if(value === null || value === undefined) return '';
        return slugifyKey(String(value).replace(/&/g,' and '));
      };

      const result = {
        runMetadata: {},
        inputs: [],
        global: emptySections(),
        globalMeta: {},
        perCellType: {},
        order: [],
        entries: [],
        specificity: [],
        contradictions: [],
        sensitivity: {leave_one_state_out_changes: [], background_rule_effect: [], checks: []},
        limitations: [],
        notes: [],
        hasGlobalData: false
      };

      if(!payload || typeof payload !== 'object'){
        return result;
      }

      if(payload.run_metadata && typeof payload.run_metadata === 'object'){
        result.runMetadata = {...payload.run_metadata};
      }
      if(Array.isArray(payload.inputs)){
        result.inputs = payload.inputs.slice();
      }

      const pickSectionValue = (source, section)=>{
        if(!source || typeof source !== 'object') return null;
        const candidates = aliasSlugMap[section] || new Set([section]);
        for(const [key, value] of Object.entries(source)){
          if(candidates.has(slugifyKey(key))){
            return value;
          }
        }
        return null;
      };

      const fillSections = (target, source)=>{
        if(!source || typeof source !== 'object') return;
        sectionKeys.forEach(section=>{
          if(section === 'transcriptional_profile') return;
          const value = pickSectionValue(source, section);
          if(!isMeaningfulValue(value)) return;
          if(section === 'executive_summary'){
            target.executive_summary = typeof value === 'string' ? value.trim() : formatInsightValue(value);
          } else {
            target[section] = toList(value);
          }
        });
        const profileSource = pickSectionValue(source, 'transcriptional_profile');
        if(profileSource && typeof profileSource === 'object'){
          const up = ['top_up','up','upregulated'].map(key=>pickSectionValue(profileSource, key) || profileSource[key]).find(isMeaningfulValue);
          const down = ['top_down','down','downregulated'].map(key=>pickSectionValue(profileSource, key) || profileSource[key]).find(isMeaningfulValue);
          if(isMeaningfulValue(up)) target.transcriptional_profile.top_up = toList(up);
          if(isMeaningfulValue(down)) target.transcriptional_profile.top_down = toList(down);
        }
      };

      const globalSource = (payload.global && typeof payload.global === 'object') ? payload.global : (payload.global_rollup && typeof payload.global_rollup === 'object' ? payload.global_rollup : null);
      fillSections(result.global, globalSource || {});

      if(globalSource){
        const extras = {};
        Object.entries(globalSource).forEach(([key, value])=>{
          const slug = slugifyKey(key);
          if(allSectionSlugs.has(slug)) return;
          if(slug === 'transcriptional_profile') return;
          extras[key] = value;
        });
        if(Object.keys(extras).length){
          result.globalMeta = extras;
        }
      }

      const perCell = (payload.per_cell_type && typeof payload.per_cell_type === 'object') ? payload.per_cell_type : {};
      const perCellType = {};
      Object.entries(perCell).forEach(([key, entry])=>{
        if(!entry || typeof entry !== 'object') return;
        const canonical = canonicalKey(entry.canonical_key || key || entry.cell_type || entry.name || entry.label);
        if(!canonical) return;
        const record = emptySections();
        record.cell_type = entry.cell_type || entry.name || entry.label || key || canonical;
        fillSections(record, entry);
        if(entry.aliases) record.aliases = toList(entry.aliases);
        const meta = {};
        Object.entries(entry).forEach(([innerKey, innerValue])=>{
          const slug = slugifyKey(innerKey);
          if(allSectionSlugs.has(slug)) return;
          if(slug === 'transcriptional_profile' || slug === 'cell_type' || slug === 'name' || slug === 'label' || slug === 'display' || slug === 'display_name' || slug === 'canonical_key') return;
          meta[innerKey] = innerValue;
        });
        if(Object.keys(meta).length){
          record.meta = meta;
        }
        perCellType[canonical] = record;
      });

      const orderSource = Array.isArray(payload.per_cell_type_order) ? payload.per_cell_type_order : (Array.isArray(payload.order) ? payload.order : []);
      const order = [];
      orderSource.forEach(item=>{
        const canonical = canonicalKey(item);
        if(canonical && perCellType[canonical] && !order.includes(canonical)){
          order.push(canonical);
        }
      });
      Object.keys(perCellType)
        .sort((a,b)=>{
          const left = perCellType[a].cell_type || a;
          const right = perCellType[b].cell_type || b;
          return left.localeCompare(right, undefined, {sensitivity:'base'});
        })
        .forEach(key=>{ if(!order.includes(key)) order.push(key); });

      result.perCellType = perCellType;
      result.order = order;
      result.entries = order.map(key=>({key, ...(perCellType[key] || {})}));

      const listify = value => Array.isArray(value) ? value.slice() : (isMeaningfulValue(value) ? [value] : []);
      result.specificity = listify(payload.specificity);
      result.contradictions = listify(payload.contradictions);
      result.limitations = listify(payload.limitations);
      result.notes = listify(payload.notes);

      const sensitivity = payload.sensitivity && typeof payload.sensitivity === 'object' ? payload.sensitivity : {};
      result.sensitivity = {
        leave_one_state_out_changes: listify(sensitivity.leave_one_state_out_changes),
        background_rule_effect: listify(sensitivity.background_rule_effect),
        checks: listify(sensitivity.checks)
      };

      const global = result.global;
      const hasProfile = (global.transcriptional_profile.top_up && global.transcriptional_profile.top_up.length) || (global.transcriptional_profile.top_down && global.transcriptional_profile.top_down.length);
      const hasOther = ['executive_summary','key_findings','enriched_processes','candidate_regulators','disease_links','hypotheses','references']
        .some(section=>section === 'executive_summary' ? isMeaningfulValue(global.executive_summary) : (global[section] && global[section].length));
      result.hasGlobalData = Boolean(hasProfile || hasOther || Object.keys(result.runMetadata).length);

      return result;
    }

    function formatTranscriptionalProfile(profile){
      if(!profile || typeof profile !== 'object') return '';
      const upList = toList(profile.top_up || profile.up || profile.upregulated).map(item=>formatInsightValue(item)).filter(Boolean);
      const downList = toList(profile.top_down || profile.down || profile.downregulated).map(item=>formatInsightValue(item)).filter(Boolean);
      const pieces = [];
      if(upList.length) pieces.push(`Up: ${upList.join(', ')}`);
      if(downList.length) pieces.push(`Down: ${downList.join(', ')}`);
      return pieces.join(' | ');
    }

    const INSIGHT_COLUMN_CONFIG = [
      {label:'Executive summary', slugs:['executive_summary','summary'], fallbackToAll:true},
      {label:'Key findings', slugs:['key_findings','key_findings_by_cell_type','findings','cell_state_annotation'], fallbackToAll:true},
      {label:'Transcriptional profile (top up/down)', slugs:['transcriptional_profile','transcriptional_profile_top_up','transcriptional_profile_top_down','top_up_genes','top_down_genes','genes_up','genes_down']},
      {label:'Enriched processes/pathways with leading-edge genes', slugs:['enriched_processes','enriched_processes_and_pathways_with_leading_edge_genes','enriched_processes_and_pathways','enriched_processes_and_pathways_with_leading_edge','pathways','pathway_enrichment']},
      {label:'Candidate regulators/activities', slugs:['candidate_regulators','candidate_regulators_and_inferred_activities','candidate_regulators_and_inferred_activities_from_tf_enrichment','regulators']},
      {label:'Disease links/therapeutics', slugs:['disease_links','disease_links_and_therapeutic_angles','disease']},
      {label:'Top hypotheses/validations', slugs:['hypotheses','top_hypotheses_and_proposed_validations']},
      {label:'References to papers', slugs:['references','references_to_papers','literature','citations','papers']}
    ];
    const INSIGHT_COLUMN_LABELS = INSIGHT_COLUMN_CONFIG.map(col=>col.label);
    const globalScope = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {});
    globalScope.biology_json = {blocks: [], byCluster: {}, orphans: []};
    globalScope.biology_narrative = '';

    const knownClusterLabels = new Map();
    const CLUSTER_NAME_FIELDS = [
      'cluster_key','cluster','cluster_label','cluster_name','celltype','cell_type','annotation','label','name',
      'display_name','display_label','cell_state','cell_state_annotation'
    ];

    function registerKnownClusterLabel(label){
      if(label === null || label === undefined) return;
      const text = String(label).trim();
      if(!text) return;
      const canonical = normaliseClusterKey(text);
      if(!canonical) return;
      const existing = knownClusterLabels.get(canonical);
      if(existing){
        existing.labels.add(text);
        if(!existing.primary){
          existing.primary = text;
        }
      } else {
        knownClusterLabels.set(canonical, {labels: new Set([text]), primary: text});
      }
    }

    function getPrimaryClusterLabel(canonical){
      if(!canonical) return '';
      const entry = knownClusterLabels.get(canonical);
      if(!entry) return '';
      if(entry.primary) return entry.primary;
      const first = entry.labels.values().next();
      return first && !first.done ? first.value : '';
    }

    function collectKnownClustersFromPayload(payload){
      if(!payload || typeof payload !== 'object') return;
      CLUSTER_NAME_FIELDS.forEach(field=>{
        const value = payload[field];
        if(Array.isArray(value)){
          value.forEach(item=>{
            if(typeof item === 'string' || typeof item === 'number'){
              registerKnownClusterLabel(item);
            }
          });
        } else if(typeof value === 'string' || typeof value === 'number'){
          registerKnownClusterLabel(value);
        }
      });
      if(Object.prototype.hasOwnProperty.call(payload, 'cluster_id') && payload.cluster_id !== null && payload.cluster_id !== undefined){
        registerKnownClusterLabel(`Cluster ${payload.cluster_id}`);
        registerKnownClusterLabel(String(payload.cluster_id));
      }
    }

    function keysMatchWithBoundary(primary, candidate){
      if(!primary || !candidate) return false;
      if(primary === candidate) return true;
      if(primary.startsWith(candidate)){
        const next = primary.charAt(candidate.length);
        if(!next || !/[a-z0-9]/.test(next)) return true;
      }
      if(candidate.startsWith(primary)){
        const next = candidate.charAt(primary.length);
        if(!next || !/[a-z0-9]/.test(next)) return true;
      }
      return false;
    }

    function resolveKnownClusterHeading(label){
      if(label === null || label === undefined) return null;
      const text = String(label).trim();
      if(!text) return null;
      const normalized = normaliseClusterKey(text);
      if(!normalized) return null;
      if(knownClusterLabels.has(normalized)){
        const display = getPrimaryClusterLabel(normalized) || text;
        return {canonical: normalized, heading: text, display};
      }
      for(const [canonical, entry] of knownClusterLabels.entries()){
        if(entry.labels.has(text)){
          const display = entry.primary || text;
          return {canonical, heading: text, display};
        }
        if(keysMatchWithBoundary(normalized, canonical)){
          const display = entry.primary || text;
          return {canonical, heading: text, display};
        }
        for(const variant of entry.labels){
          const variantNorm = normaliseClusterKey(variant);
          if(variantNorm && keysMatchWithBoundary(normalized, variantNorm)){
            const display = entry.primary || text;
            return {canonical, heading: text, display};
          }
        }
      }
      return null;
    }

    function tryParseJsonBlock(text){
      if(typeof text !== 'string' || !text.trim()) return null;
      try {
        return JSON.parse(text);
      } catch(err){
        const start = text.indexOf('{');
        const end = text.lastIndexOf('}');
        if(start !== -1 && end !== -1 && end > start){
          try {
            return JSON.parse(text.slice(start, end + 1));
          } catch(innerErr){
            return null;
          }
        }
      }
      return null;
    }

    function splitBiologyMarkdown(payload){
      knownClusterLabels.clear();
      if(Array.isArray(CLUSTERS)){
        CLUSTERS.forEach(registerKnownClusterLabel);
      }
      if(typeof payload !== 'string'){
        return {narrative:'', jsonBlocks: [], sectionsByCluster:{}};
      }
      const normalizedPayload = payload
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');

      const preflightJsonRegex = /```json([\s\S]*?)```/gi;
      let preflightMatch;
      while((preflightMatch = preflightJsonRegex.exec(normalizedPayload)) !== null){
        const parsed = tryParseJsonBlock(preflightMatch[1].trim());
        if(parsed !== null){
          collectKnownClustersFromPayload(parsed);
          const normalizedBlock = normalizeInsightPayload(parsed);
          collectKnownClustersFromPayload(normalizedBlock);
        }
      }

      const clusterHeadings = [];
      const headingRegex = /^###\s+([^\n]+)/gm;
      let headingMatch;
      while((headingMatch = headingRegex.exec(normalizedPayload)) !== null){
        const headingText = headingMatch[1].trim();
        const resolved = resolveKnownClusterHeading(headingText);
        if(resolved){
          registerKnownClusterLabel(resolved.heading);
          clusterHeadings.push({
            index: headingMatch.index,
            heading: resolved.heading,
            canonical: resolved.canonical,
            display: resolved.display
          });
        }
      }

      const narrativeSections = [];
      const jsonBlocks = [];
      const sectionsByCluster = {};

      const processJsonBlocks = (text, clusterDisplay)=>{
        if(typeof text !== 'string' || !text) return;
        const jsonRegex = /```json([\s\S]*?)```/gi;
        let jsonMatch;
        while((jsonMatch = jsonRegex.exec(text)) !== null){
          const parsed = tryParseJsonBlock(jsonMatch[1].trim());
          if(parsed !== null){
            collectKnownClustersFromPayload(parsed);
            const normalizedBlock = normalizeInsightPayload(parsed);
            collectKnownClustersFromPayload(normalizedBlock);
            const label = typeof clusterDisplay === 'string' ? clusterDisplay.trim() : '';
            jsonBlocks.push({cluster: label || null, payload: normalizedBlock});
          }
        }
      };

      if(clusterHeadings.length){
        const intro = normalizedPayload.slice(0, clusterHeadings[0].index);
        if(intro.trim()){
          processJsonBlocks(intro, null);
          const cleanedIntro = intro.replace(/```json([\s\S]*?)```/gi, '\n\n').trim();
          if(cleanedIntro){
            narrativeSections.push(cleanedIntro);
          }
        }
        clusterHeadings.forEach((info, idx)=>{
          const start = info.index;
          const end = idx + 1 < clusterHeadings.length ? clusterHeadings[idx + 1].index : normalizedPayload.length;
          const sectionText = normalizedPayload.slice(start, end);
          processJsonBlocks(sectionText, info.display);
          const cleanedSection = sectionText.replace(/```json([\s\S]*?)```/gi, '\n\n').trim();
          if(cleanedSection){
            narrativeSections.push(cleanedSection);
            const canonicalKey = info.canonical || normaliseClusterKey(info.display || info.heading || '');
            if(canonicalKey){
              const display = info.display || info.heading || canonicalKey;
              registerKnownClusterLabel(display);
              sectionsByCluster[canonicalKey] = {
                cluster: info.heading,
                display,
                raw: cleanedSection,
                sections: extractSectionsFromMarkdown(cleanedSection, info.heading)
              };
            }
          }
        });
      } else {
        processJsonBlocks(normalizedPayload, null);
        const cleaned = normalizedPayload.replace(/```json([\s\S]*?)```/gi, '\n\n').trim();
        if(cleaned){
          narrativeSections.push(cleaned);
        }
      }
      return {narrative: narrativeSections.join('\n\n'), jsonBlocks, sectionsByCluster};
    }

    function normaliseClusterKey(value){
      if(value === null || value === undefined) return '';
        return String(value)
          .toLowerCase()
          .replace(/[‘’“”]/g, '')
        .replace(/&/g, ' and ')
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\bcell\s*type\b/g, 'celltype')
        .replace(/\bcluster\s+/g, 'cluster ')
        .trim();
    }

    function registerAlias(label, canonical){
      const key = normaliseClusterKey(label);
      if(!key) return;
      const target = canonical || key;
      if(!insightsAlias.has(key)){
        insightsAlias.set(key, target);
      }
    }

    function registerInsightPayload(block){
      if(!block) return;
      const payload = normalizeInsightPayload(block.payload || {});
      block.payload = payload;
      const candidates = [];
      if(block.cluster) candidates.push(block.cluster);
      ['cluster_key','cluster','cluster_label','cluster_name','celltype','cell_type','annotation','label','name','display_name','display_label','cell_state','cell_state_annotation']
        .forEach(key=>{ if(payload && payload[key]) candidates.push(payload[key]); });
      if(payload && payload.cluster_id !== undefined && payload.cluster_id !== null){
        candidates.push(`Cluster ${payload.cluster_id}`);
        candidates.push(String(payload.cluster_id));
      }
      const primary = candidates.find(v=>typeof v === 'string' && v.trim().length>0);
      const canonicalKey = normaliseClusterKey(primary || (payload && payload.cluster_id !== undefined ? `Cluster ${payload.cluster_id}` : ''));
      const displayLabel = (primary && primary.trim()) || (typeof block.cluster === 'string' ? block.cluster.trim() : '') ||
        (payload && payload.cluster_id !== undefined ? `Cluster ${payload.cluster_id}` : '') || '';
      if(canonicalKey && !insightsPayloadIndex.has(canonicalKey)){
        insightsPayloadIndex.set(canonicalKey, {payload, display: displayLabel || canonicalKey});
        insightsOrder.push(canonicalKey);
      }
      if(canonicalKey){
        registerAlias(displayLabel || canonicalKey, canonicalKey);
      }
      candidates.forEach(candidate=>{
        registerAlias(candidate, canonicalKey || normaliseClusterKey(candidate));
      });
    }

    function indexBiologyPayloads(blocks){
      insightsPayloadIndex.clear();
      insightsAlias.clear();
      insightsOrder.length = 0;
      (blocks||[]).forEach(registerInsightPayload);
      CLUSTERS.forEach(name=>registerAlias(name));
    }

    function slugifyKey(label){
      return String(label||'')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g,'_')
        .replace(/_+/g,'_')
        .replace(/^_|_$/g,'');
    }

    function extractSectionsFromMarkdown(markdown, clusterId){
      if(typeof markdown !== 'string'){ return {}; }
      const trimmed = markdown.trim();
      if(!trimmed){ return {}; }
      let content = trimmed;
      if(/^###\s+/i.test(content)){
        const idx = content.indexOf('\n');
        if(idx !== -1){
          content = content.slice(idx + 1);
        }
      }
      const sections = {};
      const clusterSlug = slugifyKey(clusterId || '');
      const tokens = (typeof marked !== 'undefined' && marked.lexer) ? marked.lexer(content) : [];
      const buckets = {};
      let currentSlug = null;
      if(tokens && tokens.length){
        tokens.forEach(token=>{
          if(token.type === 'heading'){
            const slug = slugifyKey(token.text || '');
            if(!slug || slug === clusterSlug){
              currentSlug = null;
              return;
            }
            currentSlug = slug;
            if(!buckets[slug]) buckets[slug] = [];
            return;
          }
          if(!currentSlug) return;
          const text = flattenTokenText(token);
          if(text){
            buckets[currentSlug].push(text);
          }
        });
      }
      Object.entries(buckets).forEach(([slug, texts])=>{
        const combined = texts.join(' ').replace(/\s+/g,' ').trim();
        if(combined){
          sections[slug] = combined;
        }
      });
      const cleaned = content.replace(/\s+/g,' ').trim();
      if(cleaned){
        sections.__all = cleaned;
      }
      sections.__raw = trimmed;
      return sections;
    }

    function flattenTokenText(token){
      if(!token) return '';
      if(typeof token === 'string') return token;
      const parts = [];
      if(typeof token.text === 'string') parts.push(token.text);
      if(Array.isArray(token.tokens)){
        parts.push(token.tokens.map(flattenTokenText).join(' '));
      }
      if(Array.isArray(token.items)){
        parts.push(token.items.map(flattenTokenText).join('; '));
      }
      if(token.type === 'table'){
        const header = (token.header || []).map(flattenTokenText).join(' | ');
        const rows = (token.rows || []).map(row=>row.map(flattenTokenText).join(' | ')).join('; ');
        if(header) parts.push(header);
        if(rows) parts.push(rows);
      }
      if(parts.length === 0 && typeof token.raw === 'string'){
        parts.push(token.raw);
      }
      return parts.filter(Boolean).join(' ').replace(/\s+/g,' ').trim();
    }

    function getSectionValue(store, key){
      if(!store || !key) return '';
      if(store instanceof Map) return store.get(key) || '';
      return store[key];
    }

    function sectionKeys(store){
      if(!store) return [];
      if(store instanceof Map) return Array.from(store.keys());
      return Object.keys(store);
    }

    function findClosestSectionKey(store, slug){
      if(!store || !slug) return null;
      const keys = sectionKeys(store).filter(key=>key && !/^__/.test(key));
      const exact = keys.find(key=>key === slug);
      if(exact) return exact;
      return keys.find(key=>key.includes(slug) || slug.includes(key)) || null;
    }

    function pickNarrativeSection(store, slugs){
      if(!store) return '';
      const candidates = Array.isArray(slugs) ? slugs : [slugs];
      for(const slug of candidates){
        const match = findClosestSectionKey(store, slug);
        if(match){
          const val = getSectionValue(store, match);
          if(val) return val;
        }
      }
      return '';
    }

    function pickInsightField(payload, targetSlug){
      if(!payload || typeof payload !== 'object') return null;
      const visited = new Set();
      const search = value => {
        if(value === null || value === undefined) return null;
        if(typeof value !== 'object') return null;
        if(visited.has(value)) return null;
        visited.add(value);
        let fallback = null;
        for(const [key, val] of Object.entries(value)){
          if(val === null || val === undefined) continue;
          const slug = slugifyKey(key);
          if(slug === targetSlug) return val;
          if(!fallback && slug && (slug.includes(targetSlug) || targetSlug.includes(slug))){
            fallback = val;
          }
          if(typeof val === 'object'){
            const nested = search(val);
            if(nested !== null && nested !== undefined){
              if(slug === targetSlug) return nested;
              if(!fallback) fallback = nested;
            }
          }
          if(Array.isArray(val)){
            for(const item of val){
              if(item && typeof item === 'object'){
                const nested = search(item);
                if(nested !== null && nested !== undefined) return nested;
              }
            }
          }
        }
        return fallback;
      };
      const direct = search(payload);
      return direct;
    }

    function beautifyKey(key){
      return String(key||'')
        .replace(/_/g,' ')
        .replace(/\s+/g,' ')
        .trim()
        .replace(/\b\w/g, c=>c.toUpperCase());
    }

    function formatInsightValue(value){
      if(value === null || value === undefined) return '';
      if(typeof value === 'string') return value.replace(/\s+/g,' ').trim();
      if(typeof value === 'number' || typeof value === 'boolean') return String(value);
      if(Array.isArray(value)){
        return value.map(item=>{
          const formatted = formatInsightValue(item);
          return formatted;
        }).filter(Boolean).join('; ');
      }
      if(typeof value === 'object'){
        if(value.summary) return formatInsightValue(value.summary);
        if(value.description) return formatInsightValue(value.description);
        if(value.text) return formatInsightValue(value.text);
        if(value.leading_edge_genes){
          const genes = formatInsightValue(value.leading_edge_genes);
          const label = value.pathway || value.name || value.title || '';
          const extras = Object.entries(value)
            .filter(([k])=>!['leading_edge_genes','pathway','name','title','summary','description','text'].includes(k))
            .map(([k,v])=>`${beautifyKey(k)}: ${formatInsightValue(v)}`)
            .filter(Boolean);
          return [label, genes ? `Genes: ${genes}` : '', ...extras].filter(Boolean).join(' | ');
        }
        if(value.title || value.doi || value.pmid){
          const parts = [];
          if(value.title) parts.push(formatInsightValue(value.title));
          const journalBits = [value.journal, value.year, value.authors && Array.isArray(value.authors) ? value.authors.join(', ') : null]
            .map(bit=>formatInsightValue(bit))
            .filter(Boolean);
          if(journalBits.length){
            parts.push(journalBits.join(', '));
          }
          if(value.pmid) parts.push(`PMID: ${formatInsightValue(value.pmid)}`);
          if(value.doi) parts.push(`DOI: ${formatInsightValue(value.doi)}`);
          return parts.filter(Boolean).join(' | ') || JSON.stringify(value);
        }
        return Object.entries(value)
          .map(([k,v])=>`${beautifyKey(k)}: ${formatInsightValue(v)}`)
          .filter(Boolean)
          .join('; ');
      }
      return String(value);
    }

    function decorateBiologySections(container){
      if(!container) return;
      const headings = Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));
      const clusterHeadings = headings.filter(heading=>{
        if(!heading || heading.closest('.insight-section')) return false;
        return !!resolveKnownClusterHeading(heading.textContent || '');
      });
      clusterHeadings.forEach((heading, idx)=>{
        if(!heading || heading.closest('.insight-section')) return;
        const resolved = resolveKnownClusterHeading(heading.textContent || '');
        if(!resolved) return;
        const parent = heading.parentNode;
        if(!parent) return;
        const wrapper = document.createElement('div');
        wrapper.className = 'insight-section';
        parent.insertBefore(wrapper, heading);
        wrapper.appendChild(heading);
        const nextCluster = clusterHeadings[idx + 1] || null;
        let sibling = wrapper.nextSibling;
        while(sibling && sibling !== nextCluster){
          const next = sibling.nextSibling;
          wrapper.appendChild(sibling);
          sibling = next;
        }
        const canonicalKey = resolved.canonical || normaliseClusterKey(heading.textContent || '');
        if(canonicalKey){
          wrapper.dataset.insightKey = canonicalKey;
          const primary = resolved.display || '';
          if(primary) registerAlias(primary, canonicalKey);
          const headingText = heading.textContent || '';
          if(headingText) registerAlias(headingText, canonicalKey);
        }
      });
    }

    function indexBiologySections(){
      insightsSectionIndex.clear();
      const container = document.getElementById('biologyContent');
      if(!container) return;
      const sections = container.querySelectorAll('.insight-section');
      sections.forEach(section=>{
        const key = section.dataset.insightKey || normaliseClusterKey(
          (section.querySelector('h1, h2, h3, h4, h5, h6')||{}).textContent || ''
        );
        if(!key) return;
        insightsSectionIndex.set(key, section);
        if(!insightsAlias.has(key)) insightsAlias.set(key, key);
      });
    }

    function findInsightSection(key){
      if(!key) return null;
      if(insightsSectionIndex.has(key)) return insightsSectionIndex.get(key);
      for(const [sectionKey, sectionEl] of insightsSectionIndex.entries()){
        if(sectionKey.includes(key) || key.includes(sectionKey)){
          return sectionEl;
        }
      }
      return null;
    }

    function resolveInsightKey(raw){
      const norm = normaliseClusterKey(raw);
      if(!norm) return null;
      if(insightsPayloadIndex.has(norm) || insightsSectionIndex.has(norm)) return norm;
      if(insightsAlias.has(norm)){
        const canonical = insightsAlias.get(norm);
        if(insightsPayloadIndex.has(canonical) || insightsSectionIndex.has(canonical)){
          return canonical;
        }
      }
      // First check for exact matches in aliases
      for(const [alias, canonical] of insightsAlias.entries()){
        if(alias === norm && (insightsPayloadIndex.has(canonical) || insightsSectionIndex.has(canonical))){
          return canonical;
        }
      }
      // Then check for exact matches in section index
      for(const key of insightsSectionIndex.keys()){
        if(key === norm) return key;
      }
      // Then check for exact matches in payload index
      for(const key of insightsPayloadIndex.keys()){
        if(key === norm) return key;
      }
      // Fall back to substring matching in aliases
      for(const [alias, canonical] of insightsAlias.entries()){
        if(alias.includes(norm) && (insightsPayloadIndex.has(canonical) || insightsSectionIndex.has(canonical))){
          return canonical;
        }
      }
      // Fall back to substring matching in section index
      for(const key of insightsSectionIndex.keys()){
        if(key.includes(norm) || norm.includes(key)) return key;
      }
      // Fall back to substring matching in payload index
      for(const key of insightsPayloadIndex.keys()){
        if(key.includes(norm) || norm.includes(key)) return key;
      }
      return null;
    }

    function focusBiologySection(raw){
      const container = document.getElementById('biologyContent');
      if(!container) return false;
      const resolved = resolveInsightKey(raw);
      if(!resolved) return false;
      const section = findInsightSection(resolved);
      if(!section) return false;
      if(activeInsightKey && activeInsightKey !== resolved){
        const previous = findInsightSection(activeInsightKey);
        if(previous) previous.classList.remove('active');
      }
      section.classList.add('active');
      activeInsightKey = resolved;
      const containerRect = container.getBoundingClientRect();
      const sectionRect = section.getBoundingClientRect();
      const offset = sectionRect.top - containerRect.top + container.scrollTop - 12;
      container.scrollTo({top: Math.max(offset, 0), behavior:'smooth'});
      return true;
    }

    function buildInsightRow(display, payload, canonicalKey = null){
      const narrativeEntry = canonicalKey ? insightsNarrativeSections.get(canonicalKey) : null;
      const sectionsStore = narrativeEntry && narrativeEntry.sections ? narrativeEntry.sections : null;
      const rawText = sectionsStore ? getSectionValue(sectionsStore, '__raw') || getSectionValue(sectionsStore, '__all') : '';
      const label = display || (narrativeEntry && narrativeEntry.display) || canonicalKey || '';
      const row = [label];
      INSIGHT_COLUMN_CONFIG.forEach(column=>{
        const slugs = (column.slugs && column.slugs.length) ? column.slugs : [slugifyKey(column.label)];
        let value = null;
        if(payload){
          for(const slug of slugs){
            const candidate = pickInsightField(payload, slug);
            if(candidate !== null && candidate !== undefined && !(typeof candidate === 'string' && candidate.trim() === '')){
              value = candidate;
              break;
            }
          }
        }
        if((value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) && sectionsStore){
          const narrativeVal = pickNarrativeSection(sectionsStore, slugs);
          if(narrativeVal){
            value = narrativeVal;
          }
        }
        if((value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) && sectionsStore){
          if(column.label === 'Key findings'){
            const extra = pickNarrativeSection(sectionsStore, ['key_findings','findings','cell_state_annotation']);
            if(extra){ value = extra; }
          }
          if(column.label === 'References to papers'){
            const extra = pickNarrativeSection(sectionsStore, ['references','references_to_papers','literature','citations']);
            if(extra){ value = extra; }
          }
        }
        if((value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) && column.fallbackToAll && sectionsStore){
          const allText = getSectionValue(sectionsStore, '__all') || rawText;
          if(allText){ value = allText; }
        }
        if(column.label === 'Transcriptional profile (top up/down)'){
          let profile = (value && typeof value === 'object' && !Array.isArray(value)) ? value : null;
          if(!profile && payload){
            profile = pickInsightField(payload, 'transcriptional_profile');
          }
          const formatted = formatTranscriptionalProfile(profile);
          if(formatted){
            value = formatted;
          } else if(!value || (typeof value === 'string' && !value.trim())){
            const upList = toList(pickInsightField(payload, 'top_up_genes') || pickInsightField(payload, 'genes_up')).slice(0,5).join(', ');
            const downList = toList(pickInsightField(payload, 'top_down_genes') || pickInsightField(payload, 'genes_down')).slice(0,5).join(', ');
            const pieces = [];
            if(upList) pieces.push(`Up: ${upList}`);
            if(downList) pieces.push(`Down: ${downList}`);
            if(pieces.length){ value = pieces.join(' | '); }
          }
        }
        row.push(formatInsightValue(value));
      });
      return row;
    }

    function rebuildInsightsDownloadRows(){
      const rows = [];
      const used = new Set();
      const appendForKey = key => {
        if(!key || used.has(key)) return;
        const entry = insightsPayloadIndex.get(key);
        const narrative = insightsNarrativeSections.get(key);
        const display = (entry && entry.display) || (narrative && narrative.display) || key;
        const payload = entry ? entry.payload : null;
        rows.push(buildInsightRow(display, payload, key));
        used.add(key);
      };
      insightsOrder.forEach(appendForKey);
      insightsNarrativeSections.forEach((_, key)=>appendForKey(key));
      insightsPayloadIndex.forEach((_, key)=>appendForKey(key));
      if(!rows.length && biologyNarrative){
        const fallback = parseInsights(biologyNarrative);
        fallback.forEach(item=>{
          const key = item.key || normaliseClusterKey(item.display || item.cluster || '');
          const display = item.display || item.cluster || key;
          const payload = key && insightsPayloadIndex.has(key) ? insightsPayloadIndex.get(key).payload : null;
          rows.push(buildInsightRow(display, payload, key));
        });
      }
      insightsDownloadRows = rows;
      return rows;
    }

    function ensureInsightsDownloadRows(){
      if(!insightsDownloadRows.length){
        rebuildInsightsDownloadRows();
      }
      return insightsDownloadRows;
    }

    function csvEscape(value){
      const str = value == null ? '' : String(value).replace(/\r?\n/g,' ').trim();
      if(/[",]/.test(str)){
        return '"'+str.replace(/"/g,'""')+'"';
      }
      return str;
    }

    function prepareBiologyNarrative(){
      const container = document.getElementById('biologyContent');
      if(!container) return;
      activeInsightKey = null;
      container.scrollTop = 0;
      container.querySelectorAll('pre code.language-json').forEach(code=>{
        const pre = code.closest('pre');
        if(pre) pre.remove();
      });
      decorateBiologySections(container);
      indexBiologySections();
    }

    function updateInsightsDownloadState(){
      const rows = rebuildInsightsDownloadRows();
      if(rows.length){
        insightsBtnWrap.removeClass('d-none');
        insightsBtn.prop('disabled', false);
      } else {
        insightsBtnWrap.addClass('d-none');
        insightsBtn.prop('disabled', true);
      }
    }

    if(globalScope && typeof globalScope === 'object'){
      globalScope.focusBiologySection = focusBiologySection;
    }

    function parseInsights(md){
      if(!insightsNarrativeSections.size && typeof md === 'string' && md.trim()){
        const split = splitBiologyMarkdown(md);
        if(split.sectionsByCluster && typeof split.sectionsByCluster === 'object'){
          Object.entries(split.sectionsByCluster).forEach(([key, entry])=>{
            if(!key) return;
            if(!insightsNarrativeSections.has(key)){
              const record = {
                display: entry && entry.display ? entry.display : (entry && entry.cluster ? entry.cluster : key),
                sections: entry && entry.sections ? entry.sections : {},
                raw: entry && entry.raw ? entry.raw : ''
              };
              insightsNarrativeSections.set(key, record);
              if(record.display){
                registerAlias(record.display, key);
              }
            }
          });
        }
      }
      const entries = [];
      insightsNarrativeSections.forEach((entry, key)=>{
        entries.push({
          key,
          display: entry && entry.display ? entry.display : key,
          sections: entry && entry.sections ? entry.sections : {},
          raw: entry && entry.raw ? entry.raw : ''
        });
      });
      return entries;
    }

    function downloadInsights(){
      const rows = ensureInsightsDownloadRows();
      if(!rows.length){
        console.warn('No AI insights available for download.');
        return;
      }
      const header = ['Cluster', ...INSIGHT_COLUMN_LABELS];
      const csvLines = [header.map(csvEscape).join(',')];
      rows.forEach(row=>{
        const padded = row.slice(0, header.length);
        while(padded.length < header.length){
          padded.push('');
        }
        csvLines.push(padded.map(csvEscape).join(','));
      });
      const blob = new Blob([csvLines.join('\n')], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ai_insights.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Summary per-celltype helpers
    const SUMMARY_CELLTYPE_PATHS = {
      genes: 'llm/genes.csv',
      regulators: 'llm/regulators.csv',
      pathways: 'llm/pathways.csv',
      manifest: 'llm_per_cell/manifest.json',
      markdownBase: 'llm_per_cell'
    };
    const SUMMARY_CELLTYPE_BASE = (() => {
      if(typeof window !== 'undefined' && window.SUMMARY_CELLTYPE_BASE){
        const base = String(window.SUMMARY_CELLTYPE_BASE || '').trim();
        if(base){
          return base.replace(/\/+$/, '');
        }
      }
      return SUMMARY_CELLTYPE_PATHS.markdownBase.replace(/\/+$/, '');
    })();
    SUMMARY_CELLTYPE_PATHS.markdownBase = SUMMARY_CELLTYPE_BASE;
    function joinSummaryPath(base, target){
      const cleanBase = (base || '').replace(/\/+$/, '');
      const raw = String(target || '').trim();
      if(!raw){
        return '';
      }
      if(/^https?:\/\//i.test(raw) || raw.startsWith('data:') || raw.startsWith('blob:')){
        return raw;
      }
      if(raw.startsWith('/')){
        return raw.replace(/\/{2,}/g, '/');
      }
      const stripped = raw.replace(/^\.\//, '').replace(/^\/+/, '');
      if(cleanBase && stripped.startsWith(cleanBase + '/')){
        return stripped;
      }
      return cleanBase ? `${cleanBase}/${stripped}` : stripped;
    }
    const summaryCelltypeState = {
      initialised: false,
      labels: [],
      labelBySlug: new Map(),
      pillsContainer: null,
      cardContainer: null,
      selectedSlug: null,
      dataLoaded: false,
      loadingPromise: null,
      genesMap: new Map(),
      tfMap: new Map(),
      pathwayMap: new Map(),
      markdownCache: new Map(),
      sourceHints: new Map(),
      manifest: null,
      celltypeKey: null,
      celltypeKeyResolved: false
    };
    const summaryEmbeddedIndex = new Map();
    let summaryEmbeddedHydrated = false;

    function getEmbeddedEntry(slug){
      if(!SUMMARY_CELLTYPE_DATA || typeof SUMMARY_CELLTYPE_DATA !== 'object'){
        return null;
      }
      if(slug && SUMMARY_CELLTYPE_DATA[slug]){
        return SUMMARY_CELLTYPE_DATA[slug];
      }
      const normalized = slugify(slug || '');
      if(!normalized){
        return null;
      }
      if(SUMMARY_CELLTYPE_DATA[normalized]){
        return SUMMARY_CELLTYPE_DATA[normalized];
      }
      for(const [key, value] of Object.entries(SUMMARY_CELLTYPE_DATA)){
        if(slugify(key) === normalized){
          return value;
        }
      }
      return null;
    }

    function hydrateSummaryFromEmbedded(){
      if(summaryEmbeddedHydrated){
        return summaryCelltypeState.dataLoaded && (
          summaryCelltypeState.genesMap.size > 0 ||
          summaryCelltypeState.tfMap.size > 0 ||
          summaryCelltypeState.pathwayMap.size > 0
        );
      }
      summaryEmbeddedHydrated = true;
      const data = SUMMARY_CELLTYPE_DATA;
      if(!data || typeof data !== 'object'){
        return false;
      }
      const keys = Object.keys(data);
      if(!keys.length){
        return false;
      }
      const genes = new Map();
      const tfMap = new Map();
      const pathwayMap = new Map();
      summaryEmbeddedIndex.clear();
      keys.forEach(key => {
        const entry = data[key];
        if(!entry){
          return;
        }
        const slug = slugify(key);
        if(!slug){
          return;
        }
        summaryEmbeddedIndex.set(slug, entry);
        if(entry.genes){
          const up = Array.isArray(entry.genes.up) ? entry.genes.up : [];
          const down = Array.isArray(entry.genes.down) ? entry.genes.down : [];
          genes.set(slug, {up, down});
        }
        if(Array.isArray(entry.tf) && entry.tf.length){
          tfMap.set(slug, entry.tf);
        }
        if(Array.isArray(entry.pathways) && entry.pathways.length){
          pathwayMap.set(slug, entry.pathways);
        }
        if(typeof entry.markdown === 'string'){
          summaryCelltypeState.markdownCache.set(slug, entry.markdown);
        }
        if(entry.label && !summaryCelltypeState.labelBySlug.has(slug)){
          summaryCelltypeState.labelBySlug.set(slug, {label: entry.label, slug});
        }
      });
      if(genes.size || tfMap.size || pathwayMap.size){
        summaryCelltypeState.genesMap = genes;
        summaryCelltypeState.tfMap = tfMap;
        summaryCelltypeState.pathwayMap = pathwayMap;
        summaryCelltypeState.dataLoaded = true;
        return true;
      }
      return false;
    }
    function registerSourceHint(slug, path){
      if(!slug || !path){
        return;
      }
      const trimmed = String(path).trim();
      if(!trimmed){
        return;
      }
      if(!summaryCelltypeState.sourceHints.has(slug)){
        summaryCelltypeState.sourceHints.set(slug, new Set());
      }
      summaryCelltypeState.sourceHints.get(slug).add(trimmed);
    }
    function slugify(label){
      return slugifyKey(label);
    }
    function splitCSVLine(line, delimiter){
      const result = [];
      let current = '';
      let inQuotes = false;
      for(let i = 0; i < line.length; i++){
        const char = line[i];
        if(char === '"'){
          if(inQuotes && line[i + 1] === '"'){
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if(char === delimiter && !inQuotes){
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    }
    function parseCSV(text){
      if(typeof text !== 'string'){
        return [];
      }
      const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      let headerIndex = -1;
      for(let i = 0; i < lines.length; i++){
        if(lines[i].trim().length){
          headerIndex = i;
          break;
        }
      }
      if(headerIndex === -1){
        return [];
      }
      const headerLine = lines[headerIndex];
      const commaCount = (headerLine.match(/,/g) || []).length;
      const semiCount = (headerLine.match(/;/g) || []).length;
      const delimiter = semiCount > commaCount ? ';' : ',';
      const headers = splitCSVLine(headerLine, delimiter).map(h => h.trim());
      const rows = [];
      for(let i = headerIndex + 1; i < lines.length; i++){
        const line = lines[i];
        if(!line || !line.trim()){
          continue;
        }
        const values = splitCSVLine(line, delimiter);
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = values[idx] !== undefined ? values[idx].trim() : '';
        });
        rows.push(row);
      }
      return rows;
    }
    function coerceNumber(value){
      if(value === undefined || value === null || value === ''){
        return null;
      }
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }
    function normaliseDirection(direction, fallback = null){
      if(direction === undefined || direction === null){
        return fallback;
      }
      const text = String(direction).toLowerCase();
      if(/down|neg|deplet/.test(text)){
        return 'down';
      }
      if(/up|pos|enrich|increase/.test(text)){
        return 'up';
      }
      return fallback;
    }
    function deriveCellSlugs(row, keyHint){
      const keys = Array.isArray(keyHint) ? keyHint.slice() : (keyHint ? [keyHint] : []);
      ['cell_type_key','cell_type','cell_type_label','celltype','celltype_label','cluster','cluster_name','cluster_label','name','label','group'].forEach(k => {
        if(!keys.includes(k)){
          keys.push(k);
        }
      });
      const slugs = new Set();
      keys.forEach(key => {
        const raw = row && row[key];
        if(raw === undefined || raw === null){
          return;
        }
        if(Array.isArray(raw)){
          raw.forEach(value => {
            const slug = slugify(value);
            if(slug){
              slugs.add(slug);
            }
          });
          return;
        }
        String(raw).split(/[|;,]/).forEach(token => {
          const slug = slugify(token);
          if(slug){
            slugs.add(slug);
          }
        });
      });
      return slugs;
    }
    function indexByCell(rows, key = 'cell_type'){
      const map = new Map();
      if(!Array.isArray(rows)){
        return map;
      }
      rows.forEach(row => {
        if(!row || typeof row !== 'object'){
          return;
        }
        const slugs = deriveCellSlugs(row, key);
        if(!slugs.size){
          return;
        }
        slugs.forEach(slug => {
          if(!map.has(slug)){
            map.set(slug, []);
          }
          map.get(slug).push(row);
        });
      });
      return map;
    }
    function splitWideGenes(row){
      if(!row || typeof row !== 'object'){
        return [];
      }
      const entries = [];
      const configs = [
        {dir: 'up', genesKey: 'up_genes', scoresKey: 'up_scores'},
        {dir: 'down', genesKey: 'down_genes', scoresKey: 'down_scores'},
        {dir: 'up', genesKey: 'genes_up', scoresKey: 'scores_up'},
        {dir: 'down', genesKey: 'genes_down', scoresKey: 'scores_down'}
      ];
      configs.forEach(cfg => {
        const genesRaw = row[cfg.genesKey];
        if(!genesRaw){
          return;
        }
        const scoreRaw = row[cfg.scoresKey] || row[`${cfg.genesKey}_scores`] || '';
        const scoreTokens = typeof scoreRaw === 'string' ? scoreRaw.split(/[|;,]/) : [];
        String(genesRaw).split(/[|;,]/).forEach((token, idx) => {
          const gene = token.trim();
          if(!gene){
            return;
          }
          const scoreToken = scoreTokens[idx] !== undefined ? scoreTokens[idx].trim() : '';
          const score = scoreToken !== '' ? (coerceNumber(scoreToken) ?? scoreToken) : null;
          entries.push({
            direction: cfg.dir,
            gene,
            score
          });
        });
      });
      return entries;
    }
    function mergeListMap(target, source){
      if(!(source instanceof Map)){
        return target;
      }
      source.forEach((value, key) => {
        if(!target.has(key)){
          target.set(key, Array.isArray(value) ? value.slice() : []);
        } else if(Array.isArray(value)){
          target.get(key).push(...value);
        }
      });
      return target;
    }
    function buildGeneMap(rows){
      const map = new Map();
      if(!Array.isArray(rows)){
        return map;
      }
      rows.forEach(row => {
        if(!row){
          return;
        }
        const slugs = deriveCellSlugs(row);
        if(!slugs.size){
          return;
        }
        const wide = splitWideGenes(row);
        const entries = [];
        if(wide.length){
          wide.forEach(entry => {
            const rawScore = entry.score !== undefined ? entry.score : null;
            const numericScore = typeof rawScore === 'number' ? rawScore : coerceNumber(rawScore);
            const baseScore = numericScore !== null ? numericScore : coerceNumber(row.score || row.logfc || row.logFC || row.lfc || row.stat || row.value);
            const direction = normaliseDirection(entry.direction, normaliseDirection(row.direction, baseScore !== null ? (baseScore >= 0 ? 'up' : 'down') : 'up'));
            entries.push({
              direction: direction || 'up',
              gene: entry.gene || row.gene || row.symbol || row.name,
              score: numericScore !== null ? numericScore : baseScore,
              rawScore: rawScore !== null ? rawScore : (row.score || row.logfc || row.logFC || row.lfc || row.stat || row.value)
            });
          });
        } else {
          const gene = row.gene || row.symbol || row.name;
          if(!gene){
            return;
          }
          const scoreCandidate = row.score ?? row.logfc ?? row.logFC ?? row.avg_log2fc ?? row.avg_logFC ?? row.lfc ?? row.stat ?? row.value ?? row.activity_z;
          const numericScore = coerceNumber(scoreCandidate);
          const direction = normaliseDirection(row.direction, numericScore !== null ? (numericScore >= 0 ? 'up' : 'down') : 'up');
          entries.push({
            direction: direction || 'up',
            gene,
            score: numericScore,
            rawScore: scoreCandidate
          });
        }
        if(!entries.length){
          return;
        }
        slugs.forEach(slug => {
          registerSourceHint(slug, row.source_file || row.summary_file);
          if(!map.has(slug)){
            map.set(slug, {up: [], down: []});
          }
          const bucket = map.get(slug);
          entries.forEach(entry => {
            if(entry.direction === 'down'){
              bucket.down.push(entry);
            } else {
              bucket.up.push(entry);
            }
          });
        });
      });
      const sorter = (a, b) => {
        const aScore = a.score !== null && a.score !== undefined ? Math.abs(a.score) : null;
        const bScore = b.score !== null && b.score !== undefined ? Math.abs(b.score) : null;
        if(aScore !== null && bScore !== null && aScore !== bScore){
          return bScore - aScore;
        }
        if(aScore !== null && bScore === null){
          return -1;
        }
        if(aScore === null && bScore !== null){
          return 1;
        }
        return String(a.gene).localeCompare(String(b.gene));
      };
      map.forEach(bucket => {
        bucket.up.sort(sorter);
        bucket.down.sort(sorter);
      });
      return map;
    }
    function buildPathwayMap(rows){
      const map = new Map();
      if(!Array.isArray(rows)){
        return map;
      }
      rows.forEach(row => {
        if(!row){
          return;
        }
        const slugs = deriveCellSlugs(row);
        if(!slugs.size){
          return;
        }
        const term = row.term || row.pathway || row.program || row.name || row.label;
        if(!term){
          return;
        }
        const scoreCandidate = row.NES ?? row.score ?? row.activity ?? row.stat ?? row.value;
        const numericScore = coerceNumber(scoreCandidate);
        const padjCandidate = row.padj ?? row.fdr ?? row.q ?? row.q_value ?? row.qval;
        const padj = coerceNumber(padjCandidate);
        const direction = normaliseDirection(row.direction, numericScore !== null ? (numericScore >= 0 ? 'up' : 'down') : null);
        const entry = {
          term,
          score: numericScore,
          rawScore: scoreCandidate,
          padj,
          direction: direction || null
        };
        slugs.forEach(slug => {
          registerSourceHint(slug, row.source_file || row.summary_file);
          if(!map.has(slug)){
            map.set(slug, []);
          }
          map.get(slug).push(entry);
        });
      });
      const sorter = (a, b) => {
        const aScore = a.score !== null && a.score !== undefined ? Math.abs(a.score) : null;
        const bScore = b.score !== null && b.score !== undefined ? Math.abs(b.score) : null;
        if(aScore !== null && bScore !== null && aScore !== bScore){
          return bScore - aScore;
        }
        if(aScore !== null && bScore === null){
          return -1;
        }
        if(aScore === null && bScore !== null){
          return 1;
        }
        return String(a.term).localeCompare(String(b.term));
      };
      map.forEach(list => list.sort(sorter));
      return map;
    }
    function buildRegulatorMaps(rows){
      const tfMap = new Map();
      const pathwayMap = new Map();
      if(!Array.isArray(rows)){
        return {tfMap, pathwayMap};
      }
      rows.forEach(row => {
        if(!row){
          return;
        }
        const slugs = deriveCellSlugs(row);
        if(!slugs.size){
          return;
        }
        const tfName = row.name || row.tf || row.factor || row.regulator;
        if(tfName){
          const scoreCandidate = row.activity_z ?? row.score ?? row.stat ?? row.value ?? row.NES;
          const score = coerceNumber(scoreCandidate);
          const padjCandidate = row.padj ?? row.fdr ?? row.q ?? row.q_value ?? row.qval;
          const padj = coerceNumber(padjCandidate);
          const direction = normaliseDirection(row.direction, score !== null ? (score >= 0 ? 'up' : 'down') : null);
          const entry = {name: tfName, score, rawScore: scoreCandidate, padj, direction: direction || null};
          slugs.forEach(slug => {
            registerSourceHint(slug, row.source_file || row.summary_file);
            if(!tfMap.has(slug)){
              tfMap.set(slug, []);
            }
            tfMap.get(slug).push(entry);
          });
        }
        const term = row.term || row.pathway || row.program;
        if(term){
          const scoreCandidate = row.NES ?? row.score ?? row.activity ?? row.stat ?? row.value;
          const score = coerceNumber(scoreCandidate);
          const padjCandidate = row.padj ?? row.fdr ?? row.q ?? row.q_value ?? row.qval;
          const padj = coerceNumber(padjCandidate);
          const direction = normaliseDirection(row.direction, score !== null ? (score >= 0 ? 'up' : 'down') : null);
          const entry = {term, score, rawScore: scoreCandidate, padj, direction: direction || null};
          slugs.forEach(slug => {
            registerSourceHint(slug, row.source_file || row.summary_file);
            if(!pathwayMap.has(slug)){
              pathwayMap.set(slug, []);
            }
            pathwayMap.get(slug).push(entry);
          });
        }
      });
      const sortByScoreDesc = (a, b, key) => {
        const aScore = a[key];
        const bScore = b[key];
        if(aScore !== null && aScore !== undefined && bScore !== null && bScore !== undefined){
          return Math.abs(bScore) - Math.abs(aScore);
        }
        if(aScore !== null && aScore !== undefined){
          return -1;
        }
        if(bScore !== null && bScore !== undefined){
          return 1;
        }
        return 0;
      };
      tfMap.forEach(list => list.sort((a, b) => {
        const scoreOrder = sortByScoreDesc(a, b, 'score');
        if(scoreOrder !== 0){
          return scoreOrder;
        }
        return String(a.name).localeCompare(String(b.name));
      }));
      pathwayMap.forEach(list => list.sort((a, b) => {
        const scoreOrder = sortByScoreDesc(a, b, 'score');
        if(scoreOrder !== 0){
          return scoreOrder;
        }
        return String(a.term).localeCompare(String(b.term));
      }));
      return {tfMap, pathwayMap};
    }
    function fetchTextSafe(path){
      return fetch(path, {cache: 'no-store'}).then(resp => {
        if(!resp.ok){
          throw new Error(`${resp.status} ${resp.statusText}`);
        }
        return resp.text();
      });
    }
    function safeParseJSON(text){
      if(!text){
        return null;
      }
      try {
        return JSON.parse(text);
      } catch(err){
        console.warn('Failed to parse JSON', err);
        return null;
      }
    }
    function loadCelltypeManifest(){
      if(summaryCelltypeState.manifest !== null){
        return Promise.resolve(summaryCelltypeState.manifest);
      }
      return fetchTextSafe(SUMMARY_CELLTYPE_PATHS.manifest)
        .then(text => {
          const parsed = safeParseJSON(text);
          summaryCelltypeState.manifest = parsed;
          return parsed;
        })
        .catch(err => {
          console.warn('Celltype manifest unavailable', err);
          summaryCelltypeState.manifest = null;
          return null;
        });
    }
    function resolveMarkdownPaths(slug){
      const candidates = [];
      const pushCandidate = path => {
        const resolved = joinSummaryPath(SUMMARY_CELLTYPE_PATHS.markdownBase, path);
        if(resolved && !candidates.includes(resolved)){
          candidates.push(resolved);
        }
      };
      const manifest = summaryCelltypeState.manifest;
      if(manifest){
        if(Array.isArray(manifest)){
          for(const entry of manifest){
            if(!entry){
              continue;
            }
            const candidateSlug = slugify(entry.slug || entry.label || entry.cell_type || entry.name || entry.key || '');
            if(candidateSlug === slug){
              ['path','file','markdown','href','url'].forEach(key => {
                if(entry[key]){
                  pushCandidate(entry[key]);
                }
              });
            }
          }
        } else if(typeof manifest === 'object'){
          if(typeof manifest[slug] === 'string'){
            pushCandidate(manifest[slug]);
          }
          for(const [key, value] of Object.entries(manifest)){
            const candidateSlug = slugify(key);
            if(candidateSlug === slug){
              if(typeof value === 'string'){
                pushCandidate(value);
              } else if(value && typeof value === 'object'){
                ['path','file','markdown','href','url','slug'].forEach(prop => {
                  if(value[prop]){
                    pushCandidate(value[prop]);
                  }
                });
              }
            }
          }
        }
      }
      if(summaryCelltypeState.sourceHints.has(slug)){
        summaryCelltypeState.sourceHints.get(slug).forEach(raw => {
          pushCandidate(raw);
          if(/_response\.txt$/i.test(raw)){
            pushCandidate(raw.replace(/_response\.txt$/i, '_summary.md'));
            pushCandidate(raw.replace(/_response\.txt$/i, '.md'));
          }
          if(/\.txt$/i.test(raw)){
            pushCandidate(raw.replace(/\.txt$/i, '.md'));
          }
          const withoutExt = String(raw).trim().replace(/\.[^.]+$/, '');
          if(withoutExt){
            pushCandidate(`${withoutExt}_summary.md`);
            pushCandidate(`${withoutExt}.md`);
          }
        });
      }
      if(slug){
        pushCandidate(`${slug}_summary.md`);
        pushCandidate(`${slug}.md`);
        pushCandidate(`${slug}.markdown`);
      }
      return candidates;
    }
    function loadCelltypeMarkdown(slug){
      if(!slug){
        return Promise.resolve('');
      }
      hydrateSummaryFromEmbedded();
      const normalized = slugify(slug);
      if(summaryCelltypeState.markdownCache.has(normalized)){
        return Promise.resolve(summaryCelltypeState.markdownCache.get(normalized));
      }
      const embeddedEntry = summaryEmbeddedIndex.get(normalized) || getEmbeddedEntry(normalized);
      if(embeddedEntry && typeof embeddedEntry.markdown === 'string'){
        const text = embeddedEntry.markdown;
        summaryCelltypeState.markdownCache.set(normalized, text);
        return Promise.resolve(text);
      }
      const candidates = resolveMarkdownPaths(normalized);
      if(!candidates.length){
        summaryCelltypeState.markdownCache.set(normalized, '');
        return Promise.resolve('');
      }
      let index = 0;
      const fetchNext = () => {
        if(index >= candidates.length){
          summaryCelltypeState.markdownCache.set(normalized, '');
          return Promise.resolve('');
        }
        const path = candidates[index++];
        return fetchTextSafe(path)
          .then(text => {
            const value = text || '';
            summaryCelltypeState.markdownCache.set(normalized, value);
            return value;
          })
          .catch(err => {
            console.warn('Celltype markdown missing', path, err);
            return fetchNext();
          });
      };
      return fetchNext();
    }
    function extractKeyFindings(markdown){
      if(!markdown){
        return [];
      }
      const html = typeof marked !== 'undefined' && marked.parse ? marked.parse(markdown) : markdown;
      const temp = document.createElement('div');
      temp.innerHTML = html;
      const headings = Array.from(temp.querySelectorAll('h1,h2,h3,h4,h5,h6'));
      let targetList = null;
      for(const heading of headings){
        if(!heading || !heading.textContent){
          continue;
        }
        if(heading.textContent.trim().toLowerCase() === 'key findings'){
          let node = heading.nextElementSibling;
          while(node && node.tagName && node.tagName.toLowerCase() === 'p' && !node.textContent.trim()){
            node = node.nextElementSibling;
          }
          if(node && /^(ul|ol)$/i.test(node.tagName)){
            targetList = node;
          }
          break;
        }
      }
      if(!targetList){
        targetList = temp.querySelector('ul, ol');
      }
      if(targetList){
        const items = Array.from(targetList.querySelectorAll('li')).map(li => (li.textContent || '').trim()).filter(Boolean);
        if(items.length){
          return items.slice(0, 3);
        }
      }
      const lines = markdown.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      const bulletLines = lines.filter(line => /^[-*+]\s+/.test(line)).map(line => line.replace(/^[-*+]\s+/, '').trim());
      if(bulletLines.length){
        return bulletLines.slice(0, 3);
      }
      return lines.slice(0, 3);
    }
    function loadCelltypeData(){
      if(summaryCelltypeState.loadingPromise){
        return summaryCelltypeState.loadingPromise;
      }
      if(hydrateSummaryFromEmbedded()){
        summaryCelltypeState.loadingPromise = Promise.resolve(summaryCelltypeState);
        return summaryCelltypeState.loadingPromise;
      }
      summaryCelltypeState.loadingPromise = Promise.all([
        fetchTextSafe(SUMMARY_CELLTYPE_PATHS.genes).then(parseCSV).catch(err => {
          console.warn('Gene CSV unavailable', err);
          return [];
        }),
        fetchTextSafe(SUMMARY_CELLTYPE_PATHS.regulators).then(parseCSV).catch(err => {
          console.warn('Regulator CSV unavailable', err);
          return [];
        }),
        fetchTextSafe(SUMMARY_CELLTYPE_PATHS.pathways).then(parseCSV).catch(err => {
          console.warn('Pathway CSV unavailable', err);
          return [];
        }),
        loadCelltypeManifest()
      ]).then(([genesRows, regulatorRows, pathwayRows]) => {
        summaryCelltypeState.genesMap = buildGeneMap(genesRows);
        const {tfMap, pathwayMap} = buildRegulatorMaps(regulatorRows);
        const externalPathwayMap = buildPathwayMap(pathwayRows);
        summaryCelltypeState.tfMap = tfMap;
        summaryCelltypeState.pathwayMap = mergeListMap(pathwayMap, externalPathwayMap);
        summaryCelltypeState.dataLoaded = true;
        return summaryCelltypeState;
      }).catch(err => {
        console.warn('Celltype summary data load failed', err);
        summaryCelltypeState.genesMap = new Map();
        summaryCelltypeState.tfMap = new Map();
        summaryCelltypeState.pathwayMap = new Map();
        summaryCelltypeState.dataLoaded = true;
        return summaryCelltypeState;
      }).then(state => {
        if((!state.genesMap.size && !state.tfMap.size && !state.pathwayMap.size) && hydrateSummaryFromEmbedded()){
          return summaryCelltypeState;
        }
        return state;
      });
      return summaryCelltypeState.loadingPromise;
    }

    function buildOverview(data, overviewMarkdown = '', overviewHtml = ''){
      const wrapper = $('#summaryWrapper');
      if(!wrapper.length){
        return;
      }

      summaryCelltypeState.celltypeKeyResolved = false;
      summaryCelltypeState.celltypeKey = CELLTYPE_VAR || null;
      summaryCelltypeState.labels = [];
      summaryCelltypeState.labelBySlug = new Map();
      summaryCelltypeState.initialised = false;
      summaryCelltypeState.selectedSlug = null;
      summaryCelltypeState.dataLoaded = false;
      summaryCelltypeState.loadingPromise = null;
      summaryCelltypeState.genesMap = new Map();
      summaryCelltypeState.tfMap = new Map();
      summaryCelltypeState.pathwayMap = new Map();
      summaryCelltypeState.markdownCache = new Map();
      summaryCelltypeState.sourceHints = new Map();
      summaryEmbeddedHydrated = false;
      summaryEmbeddedIndex.clear();

      const json = (data && typeof data === 'object') ? data : {};
      const summaryBlock = (json.summary && typeof json.summary === 'object') ? json.summary : {};
      const ensureArray = value => Array.isArray(value) ? value : [];
      const metadata = (json.metadata && typeof json.metadata === 'object') ? json.metadata : (json.run_metadata && typeof json.run_metadata === 'object' ? json.run_metadata : {});

      function pick(obj, keys, fallback = ''){
        if(!obj) return fallback;
        for(const key of keys){
          if(Object.prototype.hasOwnProperty.call(obj, key)){
            const value = obj[key];
            if(value !== undefined && value !== null && value !== ''){
              return value;
            }
          }
        }
        return fallback;
      }

      function formatNumber(value, digits = 2){
        if(value === null || value === undefined || value === '') return '';
        const num = Number(value);
        if(Number.isNaN(num)) return String(value);
        if(Math.abs(num) >= 1000) return num.toLocaleString();
        if(Math.abs(num) >= 10) return num.toFixed(Math.min(digits, 1));
        return num.toFixed(digits);
      }

      function formatPercent(value){
        if(value === null || value === undefined || value === '') return '';
        const num = Number(value);
        if(Number.isNaN(num)) return String(value);
        return `${(num * 100).toFixed(1)}%`;
      }

      function setText(selector, text){
        const el = $(selector);
        if(!el.length) return false;
        if(text && String(text).trim().length){
          el.text(text);
          el.removeClass('d-none');
          return true;
        }
        el.text('');
        el.addClass('d-none');
        return false;
      }

      function showSection(selector, show){
        const section = $(selector);
        if(!section.length) return;
        if(show){
          section.removeClass('d-none');
        } else {
          section.addClass('d-none');
        }
      }

      function slugifyHeading(text){
        if(!text) return '';
        return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 120);
      }

      function enhanceSummaryNarrative(){
        const section = $('#summaryNarrativeSection');
        const container = $('#summaryMarkdown');
        if(!section.length || !container.length){
          return;
        }

        section.find('.summary-narrative-toolbar').remove();

        const isHeadlineCandidate = (text, nextEl) => {
          if(!text) return false;
          if(text.length > 140) return false;
          if(/^[-•\u2022\u2013]/.test(text)) return false;
          if(/[.!?]$/.test(text)) return false;
          if(!nextEl || !nextEl.length) return false;
          const tag = (nextEl.prop('tagName') || '').toUpperCase();
          return tag === 'UL' || tag === 'OL';
        };

        container.contents().each(function(){
          if(this.nodeType !== Node.ELEMENT_NODE || this.tagName !== 'P'){
            return;
          }
          const paragraph = $(this);
          let text = (paragraph.text() || '').trim();
          text = text.replace(/^["'“”]+|["'“”]+$/g, '').trim();
          if(!text) return;
          const nextElement = paragraph.nextAll().filter(function(){
            return this.nodeType === Node.ELEMENT_NODE;
          }).first();
          if(!isHeadlineCandidate(text, nextElement)){
            return;
          }
          const heading = $('<h2></h2>').text(text);
          paragraph.replaceWith(heading);
        });

        const headings = container.find('h2');
        if(!headings.length){
          return;
        }

        const blocks = [];
        headings.each(function(idx){
          const heading = $(this);
          const following = heading.nextUntil('h1,h2');
          const block = $('<article class="summary-narrative-block"></article>');
          const label = (heading.text() || `Section ${idx + 1}`).replace(/^["'“”]+|["'“”]+$/g, '').trim();
          const baseSlug = heading.attr('id') || slugifyHeading(label) || `narrative-${idx + 1}`;
          let slug = baseSlug;
          let attempt = 1;
          while(container.find(`#${slug}`).length){
            slug = `${baseSlug}-${++attempt}`;
          }
          heading.attr('id', slug);

          const bodyId = `${slug}-body`;
          const toggle = $('<button type="button" class="summary-narrative-toggle"></button>');
          toggle.attr({ 'aria-expanded': 'false', 'aria-controls': bodyId });
          toggle.append($('<span class="summary-narrative-title"></span>').text(label));
          toggle.append($('<span class="summary-narrative-icon" aria-hidden="true"></span>'));

          heading.empty().append(toggle);

          const body = $('<div class="summary-narrative-body"></div>').attr('id', bodyId);
          body.append(following);

          heading.before(block);
          block.append(heading, body);

          const entry = { block, heading, toggle, body, label, slug, chip: null };
          blocks.push(entry);
        });

        if(!blocks.length){
          return;
        }

        const toolbar = $('<div class="summary-narrative-toolbar"></div>');
        const labelEl = $('<span class="summary-narrative-label"></span>').text('Jump to');
        const toc = $('<div class="summary-narrative-toc" role="list"></div>');
        const actions = $('<div class="summary-narrative-actions"></div>');
        const expandAll = $('<button type="button" class="summary-narrative-action"></button>').text('Expand all');
        const collapseAll = $('<button type="button" class="summary-narrative-action"></button>').text('Collapse all');
        actions.append(expandAll, collapseAll);
        toolbar.append(labelEl, toc, actions);
        container.before(toolbar);

        function setBlockState(entry, expanded, animate, manageChip = true){
          entry.toggle.attr('aria-expanded', expanded);
          entry.block.toggleClass('is-open', expanded);
          if(animate){
            if(expanded){
              entry.body.stop(true, true).slideDown(160);
            } else {
              entry.body.stop(true, true).slideUp(140);
            }
          } else {
            entry.body.stop(true, true);
            entry.body[expanded ? 'show' : 'hide']();
          }
          if(manageChip && entry.chip){
            entry.chip.toggleClass('active', expanded);
          }
        }

        blocks.forEach((entry, idx) => {
          const chip = $('<button type="button" class="summary-toc-chip" role="listitem"></button>').text(entry.label);
          chip.attr('aria-controls', `${entry.slug}-body`);
          chip.on('click', () => {
            blocks.forEach(item => setBlockState(item, item === entry, true));
            entry.block[0].scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
          });
          if(idx === 0){
            chip.addClass('active');
          }
          entry.chip = chip;
          toc.append(chip);
        });

        expandAll.on('click', () => {
          blocks.forEach(entry => setBlockState(entry, true, true, false));
        });

        collapseAll.on('click', () => {
          blocks.forEach(entry => setBlockState(entry, false, true, false));
          toc.find('.summary-toc-chip').removeClass('active');
        });

        blocks.forEach((entry, idx) => {
          const defaultOpen = idx === 0;
          setBlockState(entry, defaultOpen, false);
          entry.toggle.on('click', () => {
            const expanded = entry.toggle.attr('aria-expanded') === 'true';
            setBlockState(entry, !expanded, true);
            if(!expanded){
              toc.find('.summary-toc-chip').removeClass('active');
              entry.chip?.addClass('active');
            }
          });
          entry.toggle.on('keydown', event => {
            if(event.key === 'Enter' || event.key === ' '){
              event.preventDefault();
              entry.toggle.trigger('click');
            }
          });
        });
      }

      function firstParagraph(html){
        if(!html) return '';
        const temp = document.createElement('div');
        temp.innerHTML = html;
        const paragraphs = temp.querySelectorAll('p');
        for(const p of paragraphs){
          const text = (p.textContent || '').trim();
          if(text) return text;
        }
        const text = (temp.textContent || '').trim();
        if(text){
          const lines = text.split(/\n+/);
          return lines.find(line => line.trim()) || '';
        }
        return '';
      }

      function resolveClusterColor(label, slug){
        if(CLUSTER_COLORS && typeof CLUSTER_COLORS === 'object'){
          if(CLUSTER_COLORS[label]){
            return CLUSTER_COLORS[label];
          }
      for(const [key, value] of Object.entries(CLUSTER_COLORS)){
        if(slugify(key) === slug){
          return value;
        }
      }
    }
    const idx = CLUSTER_NAMES.indexOf(label);
    if(idx !== -1){
      return fallbackOrdinalColor(idx, CLUSTERS.length || 1, COLOR_MODE);
    }
    return fallbackOrdinalColor(0, CLUSTERS.length || 1, COLOR_MODE);
  }

      function resolveCelltypeKey(){
        if(summaryCelltypeState.celltypeKeyResolved){
          return summaryCelltypeState.celltypeKey;
        }
        // Prioritize CELLTYPE_VAR environment variable
        if(CELLTYPE_VAR){
          const obsKeys = (OBS_LEVELS && typeof OBS_LEVELS === 'object') ? Object.keys(OBS_LEVELS) : [];
          const normalizedMap = new Map();
          obsKeys.forEach(key => {
            normalizedMap.set(slugifyKey(key), key);
          });
          const slug = slugifyKey(String(CELLTYPE_VAR));
          if(slug && normalizedMap.has(slug)){
            summaryCelltypeState.celltypeKey = normalizedMap.get(slug);
            summaryCelltypeState.celltypeKeyResolved = true;
            return summaryCelltypeState.celltypeKey;
          }
        }
        // Fallback to default behavior if CELLTYPE_VAR not found
        summaryCelltypeState.celltypeKeyResolved = true;
        summaryCelltypeState.celltypeKey = null;
        return null;
      }

      function getCelltypeLabels(){
        const seen = new Set();
        const labels = [];
        const resolvedKey = resolveCelltypeKey();
        const primaryLevels = (OBS_LEVELS && resolvedKey && Array.isArray(OBS_LEVELS[resolvedKey])) ? OBS_LEVELS[resolvedKey] : [];
        const fallback = primaryLevels.length ? primaryLevels : (Array.isArray(CLUSTER_NAMES) ? CLUSTER_NAMES : []);
        fallback.forEach(label => {
          if(!label){
            return;
          }
          const slug = slugify(label);
          if(!slug || seen.has(slug)){
            return;
          }
          const color = resolveClusterColor(label, slug);
          labels.push({label, slug, color});
          seen.add(slug);
        });
        summaryCelltypeState.labels = labels;
        summaryCelltypeState.labelBySlug = new Map(labels.map(item => [item.slug, item]));
        return labels;
      }

      function ensureSummaryCelltypeContainers(){
        if(summaryCelltypeState.pillsContainer && summaryCelltypeState.cardContainer){
          return true;
        }
        summaryCelltypeState.pillsContainer = $('#summaryCelltypePills');
        summaryCelltypeState.cardContainer = $('#summaryCelltypeCard');
        return summaryCelltypeState.pillsContainer.length > 0 && summaryCelltypeState.cardContainer.length > 0;
      }

      function updatePillStates(activeSlug){
        if(!summaryCelltypeState.pillsContainer){
          return;
        }
        summaryCelltypeState.pillsContainer.find('button[data-slug]').each(function(){
          const btn = $(this);
          const slug = btn.attr('data-slug');
          const isActive = slug === activeSlug;
          btn.toggleClass('active', isActive);
          btn.attr('aria-pressed', isActive ? 'true' : 'false');
          const color = btn.data('color');
          if(color){
            if(isActive){
              btn.css({backgroundColor: color, color: '#fff', borderColor: color});
            } else {
              btn.css({backgroundColor: 'transparent', color, borderColor: color});
            }
          }
        });
      }

      function formatScoreDisplay(entry){
        if(!entry){
          return '';
        }
        if(entry.score !== null && entry.score !== undefined){
          return formatNumber(entry.score);
        }
        if(entry.rawScore !== undefined && entry.rawScore !== null && entry.rawScore !== ''){
          return String(entry.rawScore);
        }
        return '';
      }

      function buildGeneCard(slug, label){
        const card = $('<div class="summary-card"></div>');
        card.append($('<h4></h4>').text(label + ' Transcriptional Profile'));
        const bucket = summaryCelltypeState.genesMap.get(slug) || {up: [], down: []};
        const upWrap = $('<div></div>');
        upWrap.append($('<h5 class="summary-subtitle"></h5>').text('Upregulated Genes'));
        const upList = $('<ul class="summary-chip-list"></ul>');
        const upItems = bucket.up.slice(0, 8);
        if(upItems.length){
          upItems.forEach(entry => {
            const scoreText = formatScoreDisplay(entry);
            const chip = $('<li class="summary-chip"></li>');
            chip.text(scoreText ? entry.gene + ' (' + scoreText + ')' : entry.gene);
            upList.append(chip);
          });
        } else {
          upList.append($('<li class="summary-chip neutral"></li>').text('No data'));
        }
        upWrap.append(upList);
        const downWrap = $('<div></div>');
        downWrap.append($('<h5 class="summary-subtitle"></h5>').text('Downregulated Genes'));
        const downList = $('<ul class="summary-chip-list"></ul>');
        const downItems = bucket.down.slice(0, 8);
        if(downItems.length){
          downItems.forEach(entry => {
            const scoreText = formatScoreDisplay(entry);
            const chip = $('<li class="summary-chip negative"></li>');
            chip.text(scoreText ? entry.gene + ' (' + scoreText + ')' : entry.gene);
            downList.append(chip);
          });
        } else {
          downList.append($('<li class="summary-chip neutral"></li>').text('No data'));
        }
        downWrap.append(downList);
        card.append(upWrap, downWrap);
        return card;
      }

      function buildTfCard(slug){
        const card = $('<div class="summary-card"></div>');
        card.append($('<h4></h4>').text('Transcription Factor Activity'));
        const entries = summaryCelltypeState.tfMap.get(slug) || [];
        if(!entries.length){
          card.append($('<p class="text-muted mb-0"></p>').text('No transcription factor activity available.'));
          return card;
        }
        const list = $('<ul class="summary-list"></ul>');
        entries.slice(0, 4).forEach(entry => {
          const item = $('<li class="summary-list-item"></li>');
          const row = $('<div class="d-flex flex-wrap gap-2 justify-content-between align-items-center"></div>');
          row.append($('<strong></strong>').text(entry.name));
          const parts = [];
          const scoreText = formatScoreDisplay(entry);
          if(scoreText){
            parts.push(scoreText);
          }
          if(entry.direction){
            parts.push(entry.direction === 'down' ? 'down' : 'up');
          }
          if(parts.length){
            row.append($('<span class="summary-chip neutral"></span>').text(parts.join(' • ')));
          }
          if(entry.padj !== null && entry.padj !== undefined && entry.padj < 0.05){
            row.append($('<span class="summary-chip"></span>').text('FDR<0.05'));
          }
          item.append(row);
          list.append(item);
        });
        card.append(list);
        return card;
      }

      function buildPathwayCard(slug){
        const card = $('<div class="summary-card"></div>');
        card.append($('<h4></h4>').text('Pathway Enrichment'));
        const entries = summaryCelltypeState.pathwayMap.get(slug) || [];
        if(!entries.length){
          card.append($('<p class="text-muted mb-0"></p>').text('No pathway enrichment available.'));
          return card;
        }
        const top = entries.slice(0, 3);
        const maxScore = Math.max.apply(null, top.map(entry => entry.score !== null && entry.score !== undefined ? Math.abs(entry.score) : 0).concat(0));
        top.forEach(entry => {
          const row = $('<div class="d-flex flex-column gap-1"></div>');
          const header = $('<div class="d-flex justify-content-between align-items-center gap-2"></div>');
          header.append($('<strong class="text-truncate"></strong>').text(entry.term));
          const scoreText = formatScoreDisplay(entry);
          if(scoreText){
            header.append($('<span class="text-muted small"></span>').text(scoreText));
          }
          row.append(header);
          const track = $('<div class="summary-composition-track" style="height:8px;"></div>');
          const fill = $('<div class="summary-composition-fill"></div>');
          let width = 0;
          if(entry.score !== null && entry.score !== undefined && maxScore > 0){
            width = Math.max((Math.abs(entry.score) / maxScore) * 100, 6);
          }
          fill.css('width', Math.min(width || 6, 100) + '%');
          if(entry.direction === 'down'){
            fill.css('background', 'linear-gradient(90deg, rgba(248,113,113,0.85), rgba(220,38,38,0.9))');
          }
          if(entry.padj !== null && entry.padj !== undefined && entry.padj < 0.05){
            fill.css('box-shadow', '0 0 0 1px rgba(0,0,0,0.7)');
          }
          track.empty().append(fill);
          row.append(track);
          card.append(row);
        });
        return card;
      }

      function buildFindingsCard(slug){
        const card = $('<div class="summary-card"></div>');
        card.append($('<h4></h4>').text('Key Findings'));
        const placeholder = $('<p class="text-muted mb-0"></p>').text('Loading key findings...');
        card.append(placeholder);
        loadCelltypeMarkdown(slug).then(markdown => {
          if(slug !== summaryCelltypeState.selectedSlug){
            return;
          }
          const findings = extractKeyFindings(markdown).slice(0, 3);
          placeholder.remove();
          if(!findings.length){
            card.append($('<p class="text-muted mb-0"></p>').text('No key findings available.'));
            return;
          }
          const list = $('<ul class="summary-list"></ul>');
          findings.forEach(item => {
            list.append($('<li class="summary-list-item"></li>').text(item));
          });
          card.append(list);
        }).catch(() => {
          if(slug !== summaryCelltypeState.selectedSlug){
            return;
          }
          placeholder.text('No key findings available.');
        });
        return card;
      }

      function renderSummaryCelltypeCard(slug){
        if(!summaryCelltypeState.cardContainer){
          return;
        }
        const container = summaryCelltypeState.cardContainer;
        container.empty();
        if(!summaryCelltypeState.dataLoaded){
          container.append($('<div class="col-12 text-muted"></div>').text('Loading per-celltype summary...'));
          return;
        }
        const labelEntry = summaryCelltypeState.labelBySlug.get(slug) || {label: slug, slug: slug};
        summaryCelltypeState.labelBySlug.set(slug, labelEntry);
        const geneCol = $('<div class="col-12 col-xl-3"></div>').append(buildGeneCard(slug, labelEntry.label || slug));
        const tfCol = $('<div class="col-12 col-xl-3"></div>').append(buildTfCard(slug));
        const pathwayCol = $('<div class="col-12 col-xl-3"></div>').append(buildPathwayCard(slug));
        const findingsCol = $('<div class="col-12 col-xl-3"></div>').append(buildFindingsCard(slug));
        container.append(geneCol, tfCol, pathwayCol, findingsCol);
      }

      function renderCelltypePills(labels){
        if(!summaryCelltypeState.pillsContainer){
          return;
        }
        summaryCelltypeState.pillsContainer.empty();
        const cardContainer = summaryCelltypeState.cardContainer;
        if(!labels.length){
          summaryCelltypeState.pillsContainer.append($('<span class="text-muted small"></span>').text('No cell types available.'));
          if(cardContainer){
            cardContainer.empty().append($('<div class="col-12 text-muted"></div>').text('No cell types available.'));
          }
          return;
        }
        labels.forEach(item => {
          const btn = $('<button type="button" class="btn btn-sm btn-outline-primary"></button>');
          btn.text(item.label);
          btn.attr('data-slug', item.slug);
          btn.attr('aria-pressed', 'false');
          if(item.color){
            btn.css({borderColor: item.color, color: item.color});
            btn.data('color', item.color);
          }
          btn.on('click', () => selectCelltype(item.slug));
          summaryCelltypeState.pillsContainer.append(btn);
        });
      }

      function selectCelltype(slug){
        if(!slug){
          return;
        }
        summaryCelltypeState.selectedSlug = slug;
        updatePillStates(slug);
        renderSummaryCelltypeCard(slug);
      }

      function initSummaryCelltypeSection(){
        if(!ensureSummaryCelltypeContainers()){
          return;
        }
        const labels = getCelltypeLabels();
        if(!summaryCelltypeState.initialised){
          renderCelltypePills(labels);
          summaryCelltypeState.initialised = true;
          if(labels.length){
            selectCelltype(labels[0].slug);
          }
        } else {
          if(!summaryCelltypeState.pillsContainer.children().length){
            renderCelltypePills(labels);
          }
          if(summaryCelltypeState.selectedSlug){
            updatePillStates(summaryCelltypeState.selectedSlug);
          }
        }
        loadCelltypeData().then(() => {
          if(!summaryCelltypeState.selectedSlug && labels.length){
            summaryCelltypeState.selectedSlug = labels[0].slug;
          }
          if(summaryCelltypeState.selectedSlug){
            selectCelltype(summaryCelltypeState.selectedSlug);
          }
        }).catch(() => {
          summaryCelltypeState.dataLoaded = true;
          if(summaryCelltypeState.cardContainer){
            summaryCelltypeState.cardContainer.empty().append($('<div class="col-12 text-muted"></div>').text('No per-celltype data available.'));
          }
        });
      }
      const toolkitTagline = 'Streamlined Toolkit for Real-time Exploratory Analysis of Multiomics';
      const envProjectTitle = typeof PROJECT_TITLE === 'string' ? PROJECT_TITLE : '';
      let pageHeading = envProjectTitle || pick(metadata, ['project_title','title','study','dataset_name','dataset','cohort'], '');
      pageHeading = pageHeading == null ? '' : String(pageHeading).trim();

      const pageHeadingEl = $('#pageProjectTitle');
      if(pageHeadingEl.length){
        pageHeadingEl.text(pageHeading || toolkitTagline);
      }

      const pageTaglineEl = $('#pageToolkitTagline');
      if(pageTaglineEl.length){
        pageTaglineEl.text(toolkitTagline);
      }

      const heroTitle = pick(metadata, ['title','project_title','study','dataset_name','dataset','cohort'], '') || 'Integrated tissue overview';
      $('#summaryHeroTitle').text(heroTitle);

      const kicker = pick(metadata, ['contrast','contrast_var','comparison','group','condition'], '');
      if(kicker){
        $('#summaryHeroKicker').text(kicker).removeClass('d-none');
      } else {
        $('#summaryHeroKicker').addClass('d-none').text('');
      }

      let heroDescription = pick(summaryBlock, ['description','text','summary','overview'], '');
      const highlights = ensureArray(summaryBlock.highlights);
      if(!heroDescription && highlights.length){
        const first = highlights[0];
        if(typeof first === 'string'){
          heroDescription = first;
        } else if(first && typeof first === 'object'){
          heroDescription = pick(first, ['summary','description','detail','text'], '');
        }
      }
      if(!heroDescription){
        heroDescription = firstParagraph(overviewHtml);
      }
      setText('#summaryHeroDescription', heroDescription);

      const metricsContainer = $('#summaryHeroMetrics').empty();
      const metrics = ensureArray(summaryBlock.metrics);
      if(metrics.length){
        metrics.forEach(metric => {
          const card = $('<div class="summary-metric-card"></div>');
          const label = pick(metric, ['label','name','title'], 'Metric');
          const value = metric.formatted_value != null ? metric.formatted_value : pick(metric, ['value','score'], '');
          const valueText = typeof value === 'number' ? formatNumber(value) : (value || '—');
          card.append($('<div class="summary-metric-label"></div>').text(label));
          card.append($('<div class="summary-metric-value"></div>').text(String(valueText)));
          const delta = pick(metric, ['delta','change'], null);
          const note = pick(metric, ['note','detail','comment'], '');
          if(delta !== null && delta !== ''){
            const deltaText = typeof delta === 'number' ? formatPercent(delta) : String(delta);
            card.append($('<div class="summary-metric-note"></div>').text(`Δ ${deltaText}`));
          } else if(note){
            card.append($('<div class="summary-metric-note"></div>').text(note));
          }
          metricsContainer.append(card);
        });
        metricsContainer.removeClass('d-none');
      } else {
        metricsContainer.addClass('d-none');
      }

      const warnings = ensureArray(summaryBlock.warnings);
      const warningsList = $('#summaryWarningsList').empty();
      if(warnings.length){
        warnings.forEach(message => {
          const text = typeof message === 'string' ? message : pick(message, ['text','message','warning'], '');
          if(!text) return;
          warningsList.append($('<div class="summary-alert"></div>').text(text));
        });
        showSection('#summaryWarnings', true);
      } else {
        showSection('#summaryWarnings', false);
      }

      const highlightsGrid = $('#summaryHighlightsGrid').empty();
      if(highlights.length){
        const iconFallbacks = ['activity','cpu','shield','target','layers','zap'];
        highlights.slice(0, 3).forEach((item, idx) => {
          let title = `Highlight ${idx + 1}`;
          let detail = '';
          let context = '';
          let iconName = '';
          if(typeof item === 'string'){
            detail = item;
          } else if(item && typeof item === 'object'){
            title = pick(item, ['title','name','label'], title);
            detail = pick(item, ['summary','description','detail','text'], detail);
            context = pick(item, ['context','evidence','score','confidence'], '');
            iconName = pick(item, ['icon','glyph','symbol'], '');
          }
          if(iconName && typeof iconName === 'string'){
            const trimmed = iconName.trim().toLowerCase();
            iconName = /^[a-z0-9-]+$/.test(trimmed) ? trimmed : '';
          } else {
            iconName = '';
          }
          if(!iconName){
            iconName = iconFallbacks[idx % iconFallbacks.length];
          }
          const card = $('<article class="summary-highlight-card"></article>');
          const iconWrap = $('<div class="summary-highlight-icon"></div>');
          if(iconName){
            iconWrap.append($(`<i data-feather="${iconName}"></i>`));
          } else {
            iconWrap.text(idx + 1);
          }
          const content = $('<div class="summary-highlight-content"></div>');
          content.append($('<h4></h4>').text(title));
          if(detail){
            content.append($('<p></p>').text(detail));
          }
          if(context){
            content.append($('<span class="summary-highlight-context"></span>').text(context));
          }
          card.append(iconWrap, content);
          highlightsGrid.append(card);
        });
        showSection('#summaryHighlightsSection', true);
      } else {
        showSection('#summaryHighlightsSection', false);
      }

      const fractions = ensureArray((json.composition || {}).fractions);
      const compositionList = $('#summaryCompositionList').empty();
      if(fractions.length){
        const sorted = fractions.slice().sort((a,b)=>{
          const av = Number(pick(a, ['fraction','value','percent'], 0));
          const bv = Number(pick(b, ['fraction','value','percent'], 0));
          return bv - av;
        });
        sorted.slice(0, 10).forEach(entry => {
          const cell = pick(entry, ['cell_type','type','name'], 'Cell type');
          const group = pick(entry, ['group','condition','cohort'], '');
          const frac = pick(entry, ['fraction','value','percent'], null);
          const pct = frac === null || frac === '' ? null : Number(frac);
          const percentText = pct === null || Number.isNaN(pct) ? '' : formatPercent(pct);
          const item = $('<div class="summary-composition-item"></div>');
          const header = $('<div class="summary-composition-header"></div>');
          header.append($('<span></span>').text(cell));
          if(group){
            header.append($('<span class="summary-composition-value"></span>').text(group));
          }
          item.append(header);
          const track = $('<div class="summary-composition-track"></div>');
          const fill = $('<div class="summary-composition-fill"></div>');
          if(pct !== null && !Number.isNaN(pct)){
            fill.css('width', `${Math.min(Math.max(pct * 100, 0), 100)}%`);
          } else {
            fill.css('width', '0%');
          }
          track.append(fill);
          item.append(track);
          if(percentText){
            item.append($('<div class="summary-composition-value"></div>').text(percentText));
          }
          compositionList.append(item);
        });
        showSection('#summaryCompositionSection', true);
      } else {
        showSection('#summaryCompositionSection', false);
      }

      const genes = json.genes || {};
      const topUp = ensureArray(genes.top_up);
      const topDown = ensureArray(genes.top_down);
      const upList = $('#summaryGenesUp').empty();
      const downList = $('#summaryGenesDown').empty();
      if(topUp.length || topDown.length){
        if(topUp.length){
          topUp.slice(0, 12).forEach(entry => {
            const symbol = pick(entry, ['gene','symbol','name','gene_symbol'], '');
            const change = pick(entry, ['logfc','log2fc','log2_fold_change','log2foldchange'], null);
            const chip = $('<li class="summary-chip"></li>');
            chip.text(change !== null && change !== '' ? `${symbol} (${formatNumber(change)})` : symbol);
            upList.append(chip);
          });
        } else {
          upList.append($('<li class="summary-chip neutral"></li>').text('No data'));
        }
        if(topDown.length){
          topDown.slice(0, 12).forEach(entry => {
            const symbol = pick(entry, ['gene','symbol','name','gene_symbol'], '');
            const change = pick(entry, ['logfc','log2fc','log2_fold_change','log2foldchange'], null);
            const chip = $('<li class="summary-chip negative"></li>');
            chip.text(change !== null && change !== '' ? `${symbol} (${formatNumber(change)})` : symbol);
            downList.append(chip);
          });
        } else {
          downList.append($('<li class="summary-chip neutral"></li>').text('No data'));
        }
        showSection('#summaryGenesSection', true);
      } else {
        showSection('#summaryGenesSection', false);
      }

      let harmonizedRaw = null;
      if(json && typeof json === 'object'){
        if(json.harmonized && typeof json.harmonized === 'object'){
          harmonizedRaw = json.harmonized;
        } else if(json.ai_harmonized && typeof json.ai_harmonized === 'object'){
          harmonizedRaw = json.ai_harmonized;
        } else if(json.per_cell_type && typeof json.per_cell_type === 'object'){
          harmonizedRaw = {
            per_cell_type: json.per_cell_type,
            global: json.global || {},
            global_rollup: json.global || {},
            run_metadata: json.run_metadata || json.metadata || {}
          };
        }
      }

      if($('#summaryHarmonizedSection').length){
        const harmonizedGlobal = $('#summaryHarmonizedGlobal').empty();
        const harmonizedTable = $('#summaryHarmonizedTable');
        const harmonizedWrapper = harmonizedTable.closest('.table-responsive');
        const harmonizedBody = harmonizedTable.find('tbody').empty();

        if(harmonizedRaw){
          const harmonized = normalizeHarmonizedPayload(harmonizedRaw);
          const globalBlock = harmonized.global || {};

          const addListCard = (label, values)=>{
            const items = toList(values).map(item=>formatInsightValue(item)).filter(Boolean);
            if(!items.length) return;
            const card = $('<div class="summary-card"></div>');
            card.append($('<h4></h4>').text(label));
            const list = $('<ul class="summary-list"></ul>');
            items.forEach(item=>{
              list.append($('<li class="summary-list-item"></li>').text(item));
            });
            card.append(list);
            harmonizedGlobal.append(card);
          };

          if(Object.keys(harmonized.runMetadata || {}).length){
            const card = $('<div class="summary-card"></div>');
            card.append($('<h4></h4>').text('Harmonization settings'));
            const list = $('<ul class="summary-list"></ul>');
            Object.entries(harmonized.runMetadata).forEach(([key, value])=>{
              if(!isMeaningfulValue(value)) return;
              list.append($('<li class="summary-list-item"></li>').text(`${beautifyKey(key)}: ${formatInsightValue(value)}`));
            });
            if(list.children().length){
              card.append(list);
              harmonizedGlobal.append(card);
            }
          }

          if(isMeaningfulValue(harmonized.globalMeta)){
            const metaCard = $('<div class="summary-card"></div>');
            metaCard.append($('<h4></h4>').text('Global metadata'));
            const list = $('<ul class="summary-list"></ul>');
            Object.entries(harmonized.globalMeta || {}).forEach(([key,value])=>{
              if(!isMeaningfulValue(value)) return;
              list.append($('<li class="summary-list-item"></li>').text(`${beautifyKey(key)}: ${formatInsightValue(value)}`));
            });
            if(list.children().length){
              metaCard.append(list);
              harmonizedGlobal.append(metaCard);
            }
          }

          if(isMeaningfulValue(globalBlock.executive_summary)){
            const card = $('<div class="summary-card"></div>');
            card.append($('<h4></h4>').text('Global executive summary'));
            card.append($('<p></p>').text(typeof globalBlock.executive_summary === 'string' ? globalBlock.executive_summary : formatInsightValue(globalBlock.executive_summary)));
            harmonizedGlobal.append(card);
          }

          const profileText = formatTranscriptionalProfile(globalBlock.transcriptional_profile || {});
          if(profileText){
            const card = $('<div class="summary-card"></div>');
            card.append($('<h4></h4>').text('Global transcriptional profile'));
            card.append($('<p></p>').text(profileText));
            harmonizedGlobal.append(card);
          }

          addListCard('Global key findings', globalBlock.key_findings);
          addListCard('Global enriched processes', globalBlock.enriched_processes);
          addListCard('Global candidate regulators', globalBlock.candidate_regulators);
          addListCard('Global disease links', globalBlock.disease_links);
          addListCard('Global hypotheses', globalBlock.hypotheses);
          addListCard('Global references', globalBlock.references);

          const toSummary = values => toList(values).map(item=>formatInsightValue(item)).filter(Boolean).join(' • ');
          harmonized.entries.forEach(entry => {
            const row = $('<tr></tr>');
            row.append($('<th scope="row"></th>').text(entry.cell_type || entry.key || ''));
            row.append($('<td></td>').text(entry.executive_summary ? formatInsightValue(entry.executive_summary) : ''));
            row.append($('<td></td>').text(toSummary(entry.key_findings)));
            row.append($('<td></td>').text(formatTranscriptionalProfile(entry.transcriptional_profile || {})));
            row.append($('<td></td>').text(toSummary(entry.enriched_processes)));
            row.append($('<td></td>').text(toSummary(entry.candidate_regulators)));
            row.append($('<td></td>').text(toSummary(entry.disease_links)));
            row.append($('<td></td>').text(toSummary(entry.hypotheses)));
            row.append($('<td></td>').text(toSummary(entry.references)));
            harmonizedBody.append(row);
          });

          if(harmonized.entries.length){
            harmonizedWrapper.removeClass('d-none');
          } else {
            harmonizedWrapper.addClass('d-none');
          }

          showSection('#summaryHarmonizedSection', harmonized.entries.length || harmonized.hasGlobalData);
        } else {
          harmonizedWrapper.addClass('d-none');
          showSection('#summaryHarmonizedSection', false);
        }
      }

      const pathwaysGrid = $('#summaryPathwaysGrid').empty();
      const pathways = ensureArray((json.pathways || {}).programs);
      if(pathways.length){
        pathways.slice(0, 9).forEach((entry, idx) => {
          const title = pick(entry, ['name','pathway','program','term','label'], `Program ${idx + 1}`);
          const summaryText = pick(entry, ['summary','description','detail'], '');
          const score = pick(entry, ['score','z','activity'], null);
          const q = pick(entry, ['q','q_value','fdr'], null);
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(title));
          if(summaryText){
            card.append($('<p></p>').text(summaryText));
          }
          const extras = [];
          if(score !== null && score !== '') extras.push(`score ${formatNumber(score)}`);
          if(q !== null && q !== '') extras.push(`q ${formatNumber(q,3)}`);
          const genesList = ensureArray(entry.leading_edge_genes || entry.genes || entry.drivers);
          if(genesList.length){
            const chips = $('<ul class="summary-chip-list"></ul>');
            genesList.slice(0, 6).forEach(g => {
              const label = typeof g === 'string' ? g : pick(g, ['gene','symbol','name'], '');
              chips.append($('<li class="summary-chip"></li>').text(label));
            });
            card.append(chips);
          }
          if(extras.length){
            card.append($('<small></small>').text(extras.join(' • ')));
          }
          pathwaysGrid.append(card);
        });
        showSection('#summaryPathwaysSection', true);
      } else {
        showSection('#summaryPathwaysSection', false);
      }

      const regulatorsGrid = $('#summaryRegulatorsList').empty();
      const regulators = ensureArray((json.regulators || {}).entries);
      if(regulators.length){
        regulators.slice(0, 9).forEach((entry, idx) => {
          const name = pick(entry, ['name','tf','factor','label'], `Regulator ${idx + 1}`);
          const direction = pick(entry, ['direction','effect','status'], '');
          const score = pick(entry, ['score','activity','z'], null);
          const summaryText = pick(entry, ['summary','description','detail'], '');
          const targets = ensureArray(entry.targets || entry.leading_edge_genes).slice(0,5).join(', ');
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(name));
          const meta = [direction, score !== null && score !== '' ? `z=${formatNumber(score)}` : null].filter(Boolean).join(' • ');
          if(meta){
            card.append($('<small></small>').text(meta));
          }
          if(summaryText){
            card.append($('<p></p>').text(summaryText));
          }
          if(targets){
            card.append($('<small></small>').text(`Targets: ${targets}`));
          }
          regulatorsGrid.append(card);
        });
        showSection('#summaryRegulatorsSection', true);
      } else {
        showSection('#summaryRegulatorsSection', false);
      }

      const interactionsGrid = $('#summaryInteractionsList').empty();
      const edges = ensureArray((json.interactions || {}).edges);
      if(edges.length){
        edges.slice(0, 8).forEach((edge, idx) => {
          const sender = pick(edge, ['sender','source','from'], 'Sender');
          const receiver = pick(edge, ['receiver','target','to'], 'Receiver');
          const ligand = pick(edge, ['ligand','signal','cytokine'], '');
          const receptor = pick(edge, ['receptor','partner'], '');
          const score = pick(edge, ['score','weight','z'], null);
          const evidence = pick(edge, ['evidence','note','comment','detail'], '');
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(`${sender} → ${receiver}`));
          const meta = [ligand && receptor ? `${ligand} / ${receptor}` : ligand || receptor, score !== null && score !== '' ? `score ${formatNumber(score)}` : null].filter(Boolean).join(' • ');
          if(meta){
            card.append($('<small></small>').text(meta));
          }
          if(evidence){
            card.append($('<p></p>').text(evidence));
          }
          interactionsGrid.append(card);
        });
        showSection('#summaryInteractionsSection', true);
      } else {
        showSection('#summaryInteractionsSection', false);
      }

      const diseaseGrid = $('#summaryDiseaseList').empty();
      const diseaseLinks = ensureArray((json.disease || {}).links || json.disease_links);
      const levers = ensureArray(json.combination_levers);
      if(diseaseLinks.length || levers.length){
        diseaseLinks.slice(0, 6).forEach((entry, idx) => {
          const name = pick(entry, ['disease','condition','term','name'], `Condition ${idx + 1}`);
          const detail = pick(entry, ['summary','description','note','comment'], '');
          const score = pick(entry, ['score','z','evidence_score'], null);
          const q = pick(entry, ['q','q_value','fdr'], null);
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(name));
          const meta = [score !== null && score !== '' ? `score ${formatNumber(score)}` : null, q !== null && q !== '' ? `q ${formatNumber(q,3)}` : null].filter(Boolean).join(' • ');
          if(meta){
            card.append($('<small></small>').text(meta));
          }
          if(detail){
            card.append($('<p></p>').text(detail));
          }
          const links = ensureArray(entry.targets || entry.axes || entry.regulators).slice(0,5).join(', ');
          if(links){
            card.append($('<small></small>').text(`Linked: ${links}`));
          }
          diseaseGrid.append(card);
        });
        levers.slice(0, 6).forEach((entry, idx) => {
          const axis = pick(entry, ['axis','program','context'], `Lever ${idx + 1}`);
          const lever = pick(entry, ['lever','target','therapy'], '');
          const partners = ensureArray(entry.partners || entry.combinations).join(', ');
          const rationale = pick(entry, ['rationale','note','comment','detail'], '');
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(axis));
          if(lever){
            card.append($('<small></small>').text(`Lever: ${lever}`));
          }
          if(partners){
            card.append($('<small></small>').text(`Partner: ${partners}`));
          }
          if(rationale){
            card.append($('<p></p>').text(rationale));
          }
          diseaseGrid.append(card);
        });
        showSection('#summaryDiseaseSection', true);
      } else {
        showSection('#summaryDiseaseSection', false);
      }

      const hypothesesGrid = $('#summaryHypothesesList').empty();
      const hypotheses = ensureArray(json.hypotheses);
      if(hypotheses.length){
        hypotheses.slice(0, 6).forEach((hyp, idx) => {
          const title = pick(hyp, ['title','name'], `Hypothesis ${idx + 1}`);
          const summaryText = pick(hyp, ['summary','finding','description','text'], '');
          const validations = ensureArray(hyp.validation || hyp.tests || hyp.readouts);
          const evidence = ensureArray(hyp.evidence).join('; ');
          const card = $('<div class="summary-card"></div>');
          card.append($('<h4></h4>').text(title));
          if(summaryText){
            card.append($('<p></p>').text(summaryText));
          }
          if(evidence){
            card.append($('<small></small>').text(`Evidence: ${evidence}`));
          }
          if(validations.length){
            const list = $('<ul class="summary-list"></ul>');
            validations.slice(0, 4).forEach(item => {
              list.append($('<li class="summary-list-item"></li>').text(item));
            });
            card.append(list);
          }
          hypothesesGrid.append(card);
        });
        showSection('#summaryHypothesesSection', true);
      } else {
        showSection('#summaryHypothesesSection', false);
      }

      const sensitivityList = $('#summarySensitivityList').empty();
      const checks = ensureArray((json.sensitivity || {}).checks);
      const anomalies = ensureArray(json.anomalies || (json.sensitivity || {}).anomalies);
      const limitations = ensureArray(json.limitations);
      const differences = ensureArray(json.differences_vs_prior || json.differences);
      if(checks.length || anomalies.length || limitations.length || differences.length){
        const addItems = (items, fallbackTitle) => {
          items.forEach(item => {
            const title = typeof item === 'string' ? fallbackTitle : pick(item, ['name','title','type','category'], fallbackTitle);
            const detail = typeof item === 'string' ? item : pick(item, ['description','detail','note','text','summary'], '');
            const impact = typeof item === 'string' ? '' : pick(item, ['impact','result','direction'], '');
            const entry = $('<div class="summary-list-item"></div>');
            entry.append($('<h4></h4>').text(title));
            if(detail){
              entry.append($('<p></p>').text(detail));
            }
            if(impact){
              entry.append($('<small></small>').text(impact));
            }
            sensitivityList.append(entry);
          });
        };
        addItems(checks, 'Robustness check');
        addItems(anomalies, 'Anomaly');
        addItems(limitations, 'Limitation');
        addItems(differences, 'Difference vs prior');
        showSection('#summarySensitivitySection', true);
      } else {
        showSection('#summarySensitivitySection', false);
      }

      const metadataList = $('#summaryMetadataList').empty();
      if(metadata && typeof metadata === 'object' && Object.keys(metadata).length){
        Object.entries(metadata).forEach(([key, value]) => {
          const dt = $('<dt></dt>').text(key.replace(/_/g, ' '));
          const dd = $('<dd></dd>').text(typeof value === 'string' ? value : JSON.stringify(value));
          metadataList.append(dt, dd);
        });
        showSection('#summaryMetadataSection', true);
      } else {
        showSection('#summaryMetadataSection', false);
      }

      if(overviewHtml && $('#summaryMarkdown').length){
        const temp = $('<div></div>').html(overviewHtml);
        temp.find('h1,h2,h3,h4,h5,h6').each(function(){
          const heading = $(this);
          const text = (heading.text() || '').trim().toLowerCase();
          if(text.startsWith('block 2:') && text.includes('json payload')){
            let next = heading.next();
            while(next && next.length){
              const tag = (next.prop('tagName') || '').toUpperCase();
              if(/^H[1-6]$/.test(tag)){
                break;
              }
              const current = next;
              next = next.next();
              current.remove();
            }
            heading.remove();
          }
          // Remove Executive Summary section
          if(text === 'executive summary'){
            let next = heading.next();
            while(next && next.length){
              const tag = (next.prop('tagName') || '').toUpperCase();
              if(/^H[1-6]$/.test(tag)){
                break;
              }
              const current = next;
              next = next.next();
              current.remove();
            }
            heading.remove();
          }
        });
        temp.find('pre code.language-json').each(function(){
          const pre = $(this).closest('pre');
          if(pre && pre.length){
            pre.remove();
          }
        });
        const cleaned = (temp.html() || '').trim();
        if(cleaned){
          $('#summaryMarkdown').html(cleaned);
          enhanceSummaryNarrative();
          showSection('#summaryNarrativeSection', true);
        } else {
          $('#summaryMarkdown').empty();
          $('#summaryNarrativeSection .summary-narrative-toolbar').remove();
          showSection('#summaryNarrativeSection', false);
        }
      } else {
        showSection('#summaryNarrativeSection', false);
        $('#summaryNarrativeSection .summary-narrative-toolbar').remove();
      }

      $('#overview').off('click.summaryNav').on('click.summaryNav', '.summary-btn[data-target]', function(event){
        const target = $(this).data('target');
        if(target){
          event.preventDefault();
          const tab = String(target);
          if(typeof setHash === 'function'){
            setHash(tab);
          } else if(typeof showTab === 'function'){
            showTab(tab);
          }
        }
      });

      initSummaryCelltypeSection();

      if(window.feather && typeof window.feather.replace === 'function'){
        window.feather.replace();
      }
    }
    if (biology_md && biology_md.trim()) {
      const split = splitBiologyMarkdown(biology_md);
      biologyNarrative = split.narrative;
      biologyJsonBlocks = split.jsonBlocks;
      indexBiologyPayloads(biologyJsonBlocks);
      insightsNarrativeSections.clear();
      if(split.sectionsByCluster && typeof split.sectionsByCluster === 'object'){
        Object.entries(split.sectionsByCluster).forEach(([key, entry])=>{
          if(!key) return;
          const record = {
            display: entry && entry.display ? entry.display : (entry && entry.cluster ? entry.cluster : key),
            sections: entry && entry.sections ? entry.sections : {},
            raw: entry && entry.raw ? entry.raw : ''
          };
          insightsNarrativeSections.set(key, record);
          if(record.display){
            registerAlias(record.display, key);
          }
        });
      }
      const byCluster = {};
      const orphans = [];
      biologyJsonBlocks.forEach(block=>{
        if(block.cluster){
          byCluster[block.cluster] = block.payload;
        } else {
          orphans.push(block.payload);
        }
      });
      const normalized = {};
      insightsOrder.forEach(key=>{
        const entry = insightsPayloadIndex.get(key);
        if(entry) normalized[key] = entry.payload;
      });
      const aliasMap = {};
      insightsAlias.forEach((value, key)=>{
        if(key) aliasMap[key] = value;
      });
      globalScope.biology_json = {blocks: biologyJsonBlocks, byCluster, orphans, normalized, alias: aliasMap, order: insightsOrder.slice()};
      globalScope.biology_narrative = biologyNarrative;
      const hasNarrative = biologyNarrative && biologyNarrative.trim();
      if (hasNarrative) {
        $('#biologyContent').html(to_markdown(biologyNarrative));
        prepareBiologyNarrative();
      } else {
        $('#biologyContent').html('<p class="text-muted mb-0">AI narrative is unavailable.</p>');
      }
      updateInsightsDownloadState();
      if(ensureInsightsDownloadRows().length){
        insightsBtn.off('click').on('click', downloadInsights);
      } else {
        insightsBtn.off('click');
      }
    } else {
      insightsBtnWrap.remove();
      $("a[data-tab='biology']").closest('li').remove();
      $('#biology').remove();
      insightsNarrativeSections.clear();
    }
    if (SUMMARY_ENABLED) {
      const hasOverviewMarkdown = typeof overview_md === 'string' && overview_md.trim().length > 0;
      const overviewMarkdown = hasOverviewMarkdown ? overview_md.trim() : '';
      const overviewHtml = overviewMarkdown ? to_markdown(overviewMarkdown) : '';
      const hasOverviewJson = overview_json && typeof overview_json === 'object';
      if (hasOverviewMarkdown || hasOverviewJson) {
        if (hasOverviewJson) {
          buildOverview(overview_json, overviewMarkdown, overviewHtml);
        } else {
          if (overview_json != null && typeof overview_json !== 'object') {
            console.warn('Overview JSON is not an object; skipping structured overview rendering.', overview_json);
          }
          buildOverview({}, overviewMarkdown, overviewHtml);
        }
        overviewInit = true;
      } else {
        console.warn('Overview content is missing or invalid; removing summary tab.', overview_md, overview_json);
        $("a[data-tab='overview']").closest('li').remove();
        $('#overview').remove();
        if(currentTab==='overview'){
          const fallbackLink=document.querySelector('.nav.nav-tabs .nav-link');
          if(fallbackLink){
            const fallbackTab=fallbackLink.getAttribute('data-tab');
            if(fallbackTab){
              showTab(fallbackTab);
              setHash(fallbackTab);
            }
          }
        }
      }
    }
  $('#helpChip').on('click',function(){
    const {key}=getHelpKey();
    $('#helpContent').html(HELP_CONTENT[key]||'<p>No help available.</p>');
    $('#helpOverlay').addClass('show');
    $('#helpBackdrop').addClass('show');
    $('#startTourBtn').off('click').on('click',function(){
      $('#helpOverlay').removeClass('show');
      $('#helpBackdrop').removeClass('show');
      startTour(key);
    });
  });
  $('.help-close,#helpBackdrop').on('click',function(){
    $('#helpOverlay').removeClass('show');
    $('#helpBackdrop').removeClass('show');
  });
  $('#tourOverlay').on('click',function(e){
    if(e.target.id==='tourOverlay') endTour();
  });
  $(document).on('keydown',function(e){
    if(e.key==='Escape' && $('#tourOverlay').hasClass('show')){
      endTour();
    }
  });
});
</script>
<script>
  // CHANGELOG: Fill dynamic dataset facts in the About tab.
  (function(){
    const setStat = (id, value, formatter) => {
      const el = document.getElementById(id);
      if (!el) return;
      if (value == null || Number.isNaN(value)) {
        el.textContent = '–';
        return;
      }
      if (typeof formatter === 'function') {
        el.textContent = formatter(value);
      } else if (typeof value === 'number' && typeof value.toLocaleString === 'function') {
        el.textContent = value.toLocaleString();
      } else {
        el.textContent = String(value);
      }
    };

    const toFiniteArray = (arr) => Array.from(arr || []).filter((val) => Number.isFinite(val));
    const formatCount = (value) => Math.round(value).toLocaleString();
    const median = (values) => {
      if (!values.length) return null;
      const sorted = values.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    };
    const renderGroupStat = (payload) => {
      if (payload == null) return null;
      if (typeof payload === 'number') {
        return Number.isFinite(payload) ? formatCount(payload) : null;
      }
      if (Array.isArray(payload)) {
        const finite = toFiniteArray(payload);
        if (!finite.length) return null;
        return formatCount(median(finite));
      }
      if (typeof payload === 'object') {
        const entries = Object.entries(payload).filter(([, val]) => Number.isFinite(val));
        if (!entries.length) return null;
        return entries.map(([label, val]) => `${label}: ${formatCount(val)}`).join(' | ');
      }
      if (typeof payload === 'string') {
        const trimmed = payload.trim();
        return trimmed ? trimmed : null;
      }
      return null;
    };

    setStat('about-cells', typeof NCELLS === 'number' ? NCELLS : null, formatCount);

    const umiValues = toFiniteArray(NCOUNTS);
    const umiDisplay = renderGroupStat(ABOUT_MEDIAN_UMIS);
    if (umiDisplay !== null) {
      setStat('about-umis-cell', umiDisplay);
    } else if (umiValues.length) {
      const umiMedian = median(umiValues);
      setStat('about-umis-cell', umiMedian, formatCount);
    } else {
      setStat('about-umis-cell', null);
    }

    if (Number.isFinite(ABOUT_TOTAL_UMIS)) {
      setStat('about-umis-total', ABOUT_TOTAL_UMIS, formatCount);
    } else if (umiValues.length) {
      const umiTotal = umiValues.reduce((acc, val) => acc + val, 0);
      setStat('about-umis-total', umiTotal, formatCount);
    } else {
      setStat('about-umis-total', null);
    }

    const geneValues = toFiniteArray(NGENES);
    const geneDisplay = renderGroupStat(ABOUT_MEDIAN_GENES);
    if (geneDisplay !== null) {
      setStat('about-genes-cell', geneDisplay);
    } else if (geneValues.length) {
      const geneMedian = median(geneValues);
      setStat('about-genes-cell', geneMedian, formatCount);
    } else {
      setStat('about-genes-cell', null);
    }

    if (Array.isArray(BATCH) && BATCH.length) {
      const samples = BATCH.map((val) => (val == null ? '' : String(val).trim())).filter(Boolean);
      const uniqueCount = new Set(samples).size;
      setStat('about-samples', uniqueCount > 0 ? uniqueCount : null, formatCount);
    } else {
      setStat('about-samples', null);
    }
  })();
</script>
</body>
</html>
